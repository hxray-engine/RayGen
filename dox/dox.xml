<!-- This file can be parsed by haxe.rtti.XmlParser -->
<haxe>
	<abstract path="Any" params="" file="D:\Haxe\haxe\std/Any.hx">
		<from><icast field="__cast"><c path="__cast.T"/></icast></from>
		<this><d/></this>
		<to><icast field="__promote"><c path="__promote.T"/></icast></to>
		<haxe_doc>`Any` is a type that is compatible with any other in both ways.

	This means that a value of any type can be assigned to `Any`, and
	vice-versa, a value of `Any` type can be assigned to any other type.

	It's a more type-safe alternative to `Dynamic`, because it doesn't
	support field access or operators and it's bound to monomorphs. So,
	to work with the actual value, it needs to be explicitly promoted
	to another type.</haxe_doc>
		<meta><m n=":forward.variance"/></meta>
		<impl><class path="_Any.Any_Impl_" params="" file="D:\Haxe\haxe\std/Any.hx" private="1" module="Any" final="1">
	<__promote params="T" get="inline" set="null" line="37" static="1">
		<f a="this">
			<d/>
			<c path="__promote.T"/>
		</f>
		<meta>
			<m n=":noCompletion"/>
			<m n=":to"/>
		</meta>
	</__promote>
	<__cast params="T" get="inline" set="null" line="40" static="1">
		<f a="value">
			<c path="__cast.T"/>
			<x path="Any"/>
		</f>
		<meta>
			<m n=":noCompletion"/>
			<m n=":from"/>
		</meta>
	</__cast>
	<toString get="inline" set="null" line="43" static="1">
		<f a="this">
			<d/>
			<c path="String"/>
		</f>
		<meta><m n=":noCompletion"/></meta>
	</toString>
	<meta><m n=":keep"/></meta>
</class></impl>
	</abstract>
	<class path="_Any.Any_Impl_" params="" file="D:\Haxe\haxe\std/Any.hx" private="1" module="Any" final="1">
		<__promote params="T" get="inline" set="null" line="37" static="1">
			<f a="this">
				<d/>
				<c path="__promote.T"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":to"/>
			</meta>
		</__promote>
		<__cast params="T" get="inline" set="null" line="40" static="1">
			<f a="value">
				<c path="__cast.T"/>
				<x path="Any"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":from"/>
			</meta>
		</__cast>
		<toString get="inline" set="null" line="43" static="1">
			<f a="this">
				<d/>
				<c path="String"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</toString>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="Array" params="T" file="D:\Haxe\haxe\std/Array.hx" extern="1">
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` Array.</haxe_doc>
		</length>
		<concat public="1" set="method">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns a new Array by appending the elements of `a` to the elements of
		`this` Array.

		This operation does not modify `this` Array.

		If `a` is the empty Array `[]`, a copy of `this` Array is returned.

		The length of the returned Array is equal to the sum of `this.length`
		and `a.length`.

		If `a` is `null`, the result is unspecified.</haxe_doc>
		</concat>
		<join public="1" set="method">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representation of `this` Array, with `sep` separating
		each element.

		The result of this operation is equal to `Std.string(this[0]) + sep +
		Std.string(this[1]) + sep + ... + sep + Std.string(this[this.length-1])`

		If `this` is the empty Array `[]`, the result is the empty String `""`.
		If `this` has exactly one element, the result is equal to a call to
		`Std.string(this[0])`.

		If `sep` is null, the result is unspecified.</haxe_doc>
		</join>
		<pop public="1" set="method">
			<f a=""><x path="Null"><c path="Array.T"/></x></f>
			<haxe_doc>Removes the last element of `this` Array and returns it.

		This operation modifies `this` Array in place.

		If `this` has at least one element, `this.length` will decrease by 1.

		If `this` is the empty Array `[]`, null is returned and the length
		remains 0.</haxe_doc>
		</pop>
		<push public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Adds the element `x` at the end of `this` Array and returns the new
		length of `this` Array.

		This operation modifies `this` Array in place.

		`this.length` increases by 1.</haxe_doc>
		</push>
		<reverse public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[Reverse the order of elements of `this` Array.

		This operation modifies `this` Array in place.

		If `this.length < 2`, `this` remains unchanged.]]></haxe_doc>
		</reverse>
		<shift public="1" set="method">
			<f a=""><x path="Null"><c path="Array.T"/></x></f>
			<haxe_doc>Removes the first element of `this` Array and returns it.

		This operation modifies `this` Array in place.

		If `this` has at least one element, `this`.length and the index of each
		remaining element is decreased by 1.

		If `this` is the empty Array `[]`, `null` is returned and the length
		remains 0.</haxe_doc>
		</shift>
		<slice public="1" set="method">
			<f a="pos:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Creates a shallow copy of the range of `this` Array, starting at and
		including `pos`, up to but not including `end`.

		This operation does not modify `this` Array.

		The elements are not copied and retain their identity.

		If `end` is omitted or exceeds `this.length`, it defaults to the end of
		`this` Array.

		If `pos` or `end` are negative, their offsets are calculated from the
		end of `this` Array by `this.length + pos` and `this.length + end`
		respectively. If this yields a negative value, 0 is used instead.

		If `pos` exceeds `this.length` or if `end` is less than or equals
		`pos`, the result is `[]`.</haxe_doc>
		</slice>
		<sort public="1" set="method">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<x path="Int"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sorts `this` Array according to the comparison function `f`, where
		`f(x,y)` returns 0 if x == y, a positive Int if x > y and a
		negative Int if x < y.

		This operation modifies `this` Array in place.

		The sort operation is not guaranteed to be stable, which means that the
		order of equal elements may not be retained. For a stable Array sorting
		algorithm, `haxe.ds.ArraySort.sort()` can be used instead.

		If `f` is null, the result is unspecified.]]></haxe_doc>
		</sort>
		<splice public="1" set="method">
			<f a="pos:len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc><![CDATA[Removes `len` elements from `this` Array, starting at and including
		`pos`, an returns them.

		This operation modifies `this` Array in place.

		If `len` is < 0 or `pos` exceeds `this`.length, an empty Array [] is
		returned and `this` Array is unchanged.

		If `pos` is negative, its value is calculated from the end	of `this`
		Array by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the sum of the resulting values for `len` and `pos` exceed
		`this.length`, this operation will affect the elements from `pos` to the
		end of `this` Array.

		The length of the returned Array is equal to the new length of `this`
		Array subtracted from the original length of `this` Array. In other
		words, each element of the original `this` Array either remains in
		`this` Array or becomes an element of the returned Array.]]></haxe_doc>
		</splice>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of `this` Array.

		The result will include the individual elements' String representations
		separated by comma. The enclosing [ ] may be missing on some platforms,
		use `Std.string()` to get a String representation that is consistent
		across platforms.</haxe_doc>
		</toString>
		<unshift public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds the element `x` at the start of `this` Array.

		This operation modifies `this` Array in place.

		`this.length` and the index of each Array element increases by 1.</haxe_doc>
		</unshift>
		<insert public="1" set="method">
			<f a="pos:x">
				<x path="Int"/>
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Inserts the element `x` at the position `pos`.

		This operation modifies `this` Array in place.

		The offset is calculated like so:

		- If `pos` exceeds `this.length`, the offset is `this.length`.
		- If `pos` is negative, the offset is calculated from the end of `this`
		  Array, i.e. `this.length + pos`. If this yields a negative value, the
		  offset is 0.
		- Otherwise, the offset is `pos`.

		If the resulting offset does not exceed `this.length`, all elements from
		and including that offset to the end of `this` Array are moved one index
		ahead.</haxe_doc>
		</insert>
		<remove public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the first occurrence of `x` in `this` Array.

		This operation modifies `this` Array in place.

		If `x` is found by checking standard equality, it is removed from `this`
		Array and all following elements are reindexed accordingly. The function
		then returns true.

		If `x` is not found, `this` Array is not changed and the function
		returns false.</haxe_doc>
		</remove>
		<contains public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns whether `this` Array contains `x`.

		If `x` is found by checking standard equality, the function returns `true`, otherwise
		the function returns `false`.</haxe_doc>
		</contains>
		<indexOf public="1" set="method">
			<f a="x:?fromIndex">
				<c path="Array.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns position of the first occurrence of `x` in `this` Array, searching front to back.

		If `x` is found by checking standard equality, the function returns its index.

		If `x` is not found, the function returns -1.

		If `fromIndex` is specified, it will be used as the starting index to search from,
		otherwise search starts with zero index. If it is negative, it will be taken as the
		offset from the end of `this` Array to compute the starting index. If given or computed
		starting index is less than 0, the whole array will be searched, if it is greater than
		or equal to the length of `this` Array, the function returns -1.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="x:?fromIndex">
				<c path="Array.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns position of the last occurrence of `x` in `this` Array, searching back to front.

		If `x` is found by checking standard equality, the function returns its index.

		If `x` is not found, the function returns -1.

		If `fromIndex` is specified, it will be used as the starting index to search from,
		otherwise search starts with the last element index. If it is negative, it will be
		taken as the offset from the end of `this` Array to compute the starting index. If
		given or computed starting index is greater than or equal to the length of `this` Array,
		the whole array will be searched, if it is less than 0, the function returns -1.</haxe_doc>
		</lastIndexOf>
		<copy public="1" set="method">
			<f a=""><c path="Array"><c path="Array.T"/></c></f>
			<haxe_doc>Returns a shallow copy of `this` Array.

		The elements are not copied and retain their identity, so
		`a[i] == a.copy()[i]` is true for any valid `i`. However,
		`a == a.copy()` is always false.</haxe_doc>
		</copy>
		<iterator public="1" get="inline" set="null" line="280">
			<f a=""><c path="haxe.iterators.ArrayIterator"><c path="Array.T"/></c></f>
			<meta><m n=":runtime"/></meta>
			<haxe_doc>Returns an iterator of the Array values.</haxe_doc>
		</iterator>
		<keyValueIterator public="1" get="inline" set="null" line="287">
			<f a=""><c path="haxe.iterators.ArrayKeyValueIterator"><c path="Array.T"/></c></f>
			<meta><m n=":runtime"/></meta>
			<haxe_doc>Returns an iterator of the Array indices and values.</haxe_doc>
		</keyValueIterator>
		<map public="1" params="S" get="inline" set="null" line="298">
			<f a="f">
				<f a="">
					<c path="Array.T"/>
					<c path="map.S"/>
				</f>
				<c path="Array"><c path="map.S"/></c>
			</f>
			<meta><m n=":runtime"/></meta>
			<haxe_doc>Creates a new Array by applying function `f` to all elements of `this`.

		The order of elements is preserved.

		If `f` is null, the result is unspecified.</haxe_doc>
		</map>
		<filter public="1" get="inline" set="null" line="316">
			<f a="f">
				<f a="">
					<c path="Array.T"/>
					<x path="Bool"/>
				</f>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<meta><m n=":runtime"/></meta>
			<haxe_doc>Returns an Array containing those elements of `this` for which `f`
		returned true.

		The individual elements are not duplicated and retain their identity.

		If `f` is null, the result is unspecified.</haxe_doc>
		</filter>
		<resize public="1" set="method">
			<f a="len">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the length of the Array.

		If `len` is shorter than the array's current size, the last
		`length - len` elements will be removed. If `len` is longer, the Array
		will be extended, with new elements set to a target-specific default
		value:

		- always null on dynamic targets
		- 0, 0.0 or false for Int, Float and Bool respectively on static targets
		- null for other types on static targets</haxe_doc>
		</resize>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Array.</haxe_doc>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="Class" params="T" file="D:\Haxe\haxe\std/Class.hx">
		<this><x path="Class"><c path="Class.T"/></x></this>
		<haxe_doc>An abstract type that represents a Class.

	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-class-instance.html</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<class path="EReg" params="" file="D:\Haxe\haxe\std/cpp/_std/EReg.hx">
		<_hx_regexp_new_options set="method" static="1">
			<f a="s:options">
				<c path="String"/>
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":native"><e>"_hx_regexp_new_options"</e></m></meta>
		</_hx_regexp_new_options>
		<_hx_regexp_match set="method" static="1">
			<f a="handler:string:pos:len">
				<d/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"_hx_regexp_match"</e></m></meta>
		</_hx_regexp_match>
		<_hx_regexp_matched set="method" static="1">
			<f a="handle:pos">
				<d/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":native"><e>"_hx_regexp_matched"</e></m></meta>
		</_hx_regexp_matched>
		<_hx_regexp_matched_pos set="method" static="1">
			<f a="handle:match">
				<d/>
				<x path="Int"/>
				<a>
					<pos><x path="Int"/></pos>
					<len><x path="Int"/></len>
				</a>
			</f>
			<meta><m n=":native"><e>"_hx_regexp_matched_pos"</e></m></meta>
		</_hx_regexp_matched_pos>
		<r><d/></r>
		<last><c path="String"/></last>
		<global><x path="Bool"/></global>
		<match public="1" set="method" line="36">
			<f a="s">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `this` regular expression matches String `s`.

		This method modifies the internal state.

		If `s` is `null`, the result is unspecified.</haxe_doc>
		</match>
		<matched public="1" set="method" line="45">
			<f a="n">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the matched sub-group `n` of `this` EReg.

		This method should only be called after `this.match` or
		`this.matchSub`, and then operates on the String of that operation.

		The index `n` corresponds to the n-th set of parentheses in the pattern
		of `this` EReg. If no such sub-group exists, the result is unspecified.

		If `n` equals 0, the whole matched substring is returned.</haxe_doc>
		</matched>
		<new public="1" set="method" line="28">
			<f a="r:opt">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new regular expression with pattern `r` and modifiers `opt`.

		This is equivalent to the shorthand syntax `~/r/opt`

		If `r` or `opt` are null, the result is unspecified.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[The EReg class represents regular expressions.

	While basic usage and patterns consistently work across platforms, some more
	complex operations may yield different results. This is a necessary trade-
	off to retain a certain level of performance.

	EReg instances can be created by calling the constructor, or with the
	special syntax `~/pattern/modifier`

	EReg instances maintain an internal state, which is affected by several of
	its methods.

	A detailed explanation of the supported operations is available at
	<https://haxe.org/manual/std-regex.html>]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":buildXml"><e><![CDATA["<include name=\"${HXCPP}/src/hx/libs/regexp/Build.xml\"/>"]]></e></m>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Enum" params="T" file="D:\Haxe\haxe\std/Enum.hx">
		<this><x path="Enum"><c path="Enum.T"/></x></this>
		<haxe_doc>An abstract type that represents an Enum type.

	The corresponding enum instance type is `EnumValue`.

	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-enum-instance.html</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="EnumValue" params="" file="D:\Haxe\haxe\std/EnumValue.hx">
		<this><x path="EnumValue"/></this>
		<haxe_doc>An abstract type that represents any enum value.
	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-enum-instance.html</haxe_doc>
		<meta><m n=":coreType"/></meta>
		<impl><class path="_EnumValue.EnumValue_Impl_" params="" file="D:\Haxe\haxe\std/EnumValue.hx" private="1" module="EnumValue" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<typedef path="Map" params="K:V" file="D:\Haxe\haxe\std/Map.hx"><x path="haxe.ds.Map">
	<c path="Map.K"/>
	<c path="Map.V"/>
</x></typedef>
	<typedef path="IMap" params="K:V" file="D:\Haxe\haxe\std/Map.hx" module="Map">
		<c path="haxe.IMap">
			<c path="IMap.K"/>
			<c path="IMap.V"/>
		</c>
		<meta>
			<m n=":dox"><e>hide</e></m>
			<m n=":deprecated"/>
		</meta>
	</typedef>
	<class path="Math" params="" file="D:\Haxe\haxe\std/Math.hx" extern="1">
		<PI public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>Represents the ratio of the circumference of a circle to its diameter,
		specified by the constant, π. `PI` is approximately `3.141592653589793`.</haxe_doc>
		</PI>
		<NEGATIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special `Float` constant which denotes negative infinity.

		For example, this is the result of `-1.0 / 0.0`.

		Operations with `NEGATIVE_INFINITY` as an operand may result in
		`NEGATIVE_INFINITY`, `POSITIVE_INFINITY` or `NaN`.

		If this constant is converted to an `Int`, e.g. through `Std.int()`, the
		result is unspecified.</haxe_doc>
		</NEGATIVE_INFINITY>
		<POSITIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special `Float` constant which denotes positive infinity.

		For example, this is the result of `1.0 / 0.0`.

		Operations with `POSITIVE_INFINITY` as an operand may result in
		`NEGATIVE_INFINITY`, `POSITIVE_INFINITY` or `NaN`.

		If this constant is converted to an `Int`, e.g. through `Std.int()`, the
		result is unspecified.</haxe_doc>
		</POSITIVE_INFINITY>
		<NaN public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special `Float` constant which denotes an invalid number.

		`NaN` stands for "Not a Number". It occurs when a mathematically incorrect
		operation is executed, such as taking the square root of a negative
		number: `Math.sqrt(-1)`.

		All further operations with `NaN` as an operand will result in `NaN`.

		If this constant is converted to an `Int`, e.g. through `Std.int()`, the
		result is unspecified.

		In order to test if a value is `NaN`, you should use `Math.isNaN()` function.</haxe_doc>
		</NaN>
		<abs public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the absolute value of `v`.

		- If `v` is positive or `0`, the result is unchanged. Otherwise the result is `-v`.
		- If `v` is `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		- If `v` is `NaN`, the result is `NaN`.</haxe_doc>
		</abs>
		<min public="1" set="method" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the smaller of values `a` and `b`.

		- If `a` or `b` are `NaN`, the result is `NaN`.
		- If `a` or `b` are `NEGATIVE_INFINITY`, the result is `NEGATIVE_INFINITY`.
		- If `a` and `b` are `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.</haxe_doc>
		</min>
		<max public="1" set="method" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the greater of values `a` and `b`.

		- If `a` or `b` are `NaN`, the result is `NaN`.
		- If `a` or `b` are `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		- If `a` and `b` are `NEGATIVE_INFINITY`, the result is `NEGATIVE_INFINITY`.</haxe_doc>
		</max>
		<sin public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric sine of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</sin>
		<cos public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric cosine of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</cos>
		<tan public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric tangent of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</tan>
		<asin public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</asin>
		<acos public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc cosine of the specified angle `v`,
		in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</acos>
		<atan public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc tangent of the specified angle `v`,
		in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</atan>
		<atan2 public="1" set="method" static="1">
			<f a="y:x">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc tangent whose tangent is the quotient of
		two specified numbers, in radians.

		If parameter `x` or `y`  is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`,
		the result is `NaN`.</haxe_doc>
		</atan2>
		<exp public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns Euler's number, raised to the power of `v`.

		`exp(1.0)` is approximately `2.718281828459`.

		- If `v` is `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		- If `v` is `NEGATIVE_INFINITY`, the result is `0.0`.
		- If `v` is `NaN`, the result is `NaN`.</haxe_doc>
		</exp>
		<log public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the natural logarithm of `v`.

		This is the mathematical inverse operation of exp,
		i.e. `log(exp(v)) == v` always holds.

		- If `v` is negative (including `NEGATIVE_INFINITY`) or `NaN`, the result is `NaN`.
		- If `v` is `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		- If `v` is `0.0`, the result is `NEGATIVE_INFINITY`.</haxe_doc>
		</log>
		<pow public="1" set="method" static="1">
			<f a="v:exp">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns a specified base `v` raised to the specified power `exp`.</haxe_doc>
		</pow>
		<sqrt public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the square root of `v`.

		- If `v` is negative (including `NEGATIVE_INFINITY`) or `NaN`, the result is `NaN`.
		- If `v` is `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		- If `v` is `0.0`, the result is `0.0`.</haxe_doc>
		</sqrt>
		<round public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Rounds `v` to the nearest integer value.

		Ties are rounded up, so that `0.5` becomes `1` and `-0.5` becomes `0`.

		If `v` is outside of the signed `Int32` range, or is `NaN`, `NEGATIVE_INFINITY`
		or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</round>
		<floor public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the largest integer value that is not greater than `v`.

		If `v` is outside of the signed `Int32` range, or is `NaN`, `NEGATIVE_INFINITY`
		or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</floor>
		<ceil public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the smallest integer value that is not less than `v`.

		If `v` is outside of the signed `Int32` range, or is `NaN`, `NEGATIVE_INFINITY`
		or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</ceil>
		<random public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns a pseudo-random number which is greater than or equal to `0.0`,
		and less than `1.0`.</haxe_doc>
		</random>
		<ffloor public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the largest integer value that is not greater than `v`, as a `Float`.

		If `v` is is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`,
		the result is unspecified.</haxe_doc>
		</ffloor>
		<fceil public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the smallest integer value that is not less than `v`, as a `Float`.

		If `v` is is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`,
		the result is unspecified.</haxe_doc>
		</fceil>
		<fround public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Rounds `v` to the nearest integer value, as a Float.

		Ties are rounded up, so that `0.5` becomes `1` and `-0.5` becomes `0`.

		If `v` is is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`,
		the result is unspecified.</haxe_doc>
		</fround>
		<isFinite public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is a finite number.

		If `f` is `POSITIVE_INFINITY`, `NEGATIVE_INFINITY` or `NaN`, the result
		is `false`, otherwise the result is `true`.</haxe_doc>
		</isFinite>
		<isNaN public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is not a valid number.

		If `f` is `NaN`, the result is `true`, otherwise the result is `false`.
		In particular, both `POSITIVE_INFINITY` and `NEGATIVE_INFINITY` are
		not considered `NaN`.</haxe_doc>
		</isNaN>
		<haxe_doc>This class defines mathematical functions and constants.

	@see https://haxe.org/manual/std-math.html</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":include"><e>"hxMath.h"</e></m>
		</meta>
	</class>
	<class path="Colors" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl" extern="1">
		<LIGHTGRAY public="1" static="1">
			<t path="Color"/>
			<meta><m n=":native"><e>"LIGHTGRAY"</e></m></meta>
		</LIGHTGRAY>
		<GRAY public="1" static="1">
			<t path="Color"/>
			<meta><m n=":native"><e>"GRAY"</e></m></meta>
		</GRAY>
		<DARKGRAY public="1" static="1">
			<t path="Color"/>
			<meta><m n=":native"><e>"DARKGRAY"</e></m></meta>
		</DARKGRAY>
		<YELLOW public="1" static="1">
			<t path="Color"/>
			<meta><m n=":native"><e>"YELLOW"</e></m></meta>
		</YELLOW>
		<GOLD public="1" static="1">
			<t path="Color"/>
			<meta><m n=":native"><e>"GOLD"</e></m></meta>
		</GOLD>
		<ORANGE public="1" static="1">
			<t path="Color"/>
			<meta><m n=":native"><e>"ORANGE"</e></m></meta>
		</ORANGE>
		<PINK public="1" static="1">
			<t path="Color"/>
			<meta><m n=":native"><e>"PINK"</e></m></meta>
		</PINK>
		<RED public="1" static="1">
			<t path="Color"/>
			<meta><m n=":native"><e>"RED"</e></m></meta>
		</RED>
		<MAROON public="1" static="1">
			<t path="Color"/>
			<meta><m n=":native"><e>"MAROON"</e></m></meta>
		</MAROON>
		<GREEN public="1" static="1">
			<t path="Color"/>
			<meta><m n=":native"><e>"GREEN"</e></m></meta>
		</GREEN>
		<LIME public="1" static="1">
			<t path="Color"/>
			<meta><m n=":native"><e>"LIME"</e></m></meta>
		</LIME>
		<DARKGREEN public="1" static="1">
			<t path="Color"/>
			<meta><m n=":native"><e>"DARKGREEN"</e></m></meta>
		</DARKGREEN>
		<SKYBLUE public="1" static="1">
			<t path="Color"/>
			<meta><m n=":native"><e>"SKYBLUE"</e></m></meta>
		</SKYBLUE>
		<BLUE public="1" static="1">
			<t path="Color"/>
			<meta><m n=":native"><e>"BLUE"</e></m></meta>
		</BLUE>
		<DARKBLUE public="1" static="1">
			<t path="Color"/>
			<meta><m n=":native"><e>"DARKBLUE"</e></m></meta>
		</DARKBLUE>
		<PURPLE public="1" static="1">
			<t path="Color"/>
			<meta><m n=":native"><e>"PURPLE"</e></m></meta>
		</PURPLE>
		<VIOLET public="1" static="1">
			<t path="Color"/>
			<meta><m n=":native"><e>"VIOLET"</e></m></meta>
		</VIOLET>
		<DARKPURPLE public="1" static="1">
			<t path="Color"/>
			<meta><m n=":native"><e>"DARKPURPLE"</e></m></meta>
		</DARKPURPLE>
		<BEIGE public="1" static="1">
			<t path="Color"/>
			<meta><m n=":native"><e>"BEIGE"</e></m></meta>
		</BEIGE>
		<BROWN public="1" static="1">
			<t path="Color"/>
			<meta><m n=":native"><e>"BROWN"</e></m></meta>
		</BROWN>
		<DARKBROWN public="1" static="1">
			<t path="Color"/>
			<meta><m n=":native"><e>"DARKBROWN"</e></m></meta>
		</DARKBROWN>
		<WHITE public="1" static="1">
			<t path="Color"/>
			<meta><m n=":native"><e>"WHITE"</e></m></meta>
		</WHITE>
		<BLACK public="1" static="1">
			<t path="Color"/>
			<meta><m n=":native"><e>"BLACK"</e></m></meta>
		</BLACK>
		<BLANK public="1" static="1">
			<t path="Color"/>
			<meta><m n=":native"><e>"BLANK"</e></m></meta>
		</BLANK>
		<MAGENTA public="1" static="1">
			<t path="Color"/>
			<meta><m n=":native"><e>"MAGENTA"</e></m></meta>
		</MAGENTA>
		<RAYWHITE public="1" static="1">
			<t path="Color"/>
			<meta><m n=":native"><e>"RAYWHITE"</e></m></meta>
		</RAYWHITE>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":include"><e>"raylib.h"</e></m>
		</meta>
	</class>
	<class path="RlVector2" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl" extern="1">
		<create public="1" get="inline" set="null" line="75" static="1">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<t path="Vector2"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</create>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<meta>
			<m n=":include"><e>"raylib.h"</e></m>
			<m n=":native"><e>"Vector2"</e></m>
			<m n=":structAccess"/>
		</meta>
	</class>
	<typedef path="Vector2" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl"><t path="cpp.Struct"><c path="RlVector2"/></t></typedef>
	<class path="RlVector3" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl" extern="1">
		<create public="1" get="inline" set="null" line="91" static="1">
			<f a="x:y:z">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<t path="Vector3"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</create>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<z public="1"><x path="Float"/></z>
		<meta>
			<m n=":include"><e>"raylib.h"</e></m>
			<m n=":native"><e>"Vector3"</e></m>
			<m n=":structAccess"/>
		</meta>
	</class>
	<typedef path="Vector3" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl"><t path="cpp.Struct"><c path="RlVector3"/></t></typedef>
	<class path="RlVector4" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl" extern="1">
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<z public="1"><x path="Float"/></z>
		<w public="1"><x path="Float"/></w>
		<meta>
			<m n=":include"><e>"raylib.h"</e></m>
			<m n=":native"><e>"Vector4"</e></m>
			<m n=":structAccess"/>
		</meta>
	</class>
	<typedef path="Vector4" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl"><t path="cpp.Struct"><c path="RlVector4"/></t></typedef>
	<typedef path="Quaternion" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl"><t path="Vector4"/></typedef>
	<class path="RlMatrix" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl" extern="1">
		<m0 public="1"><x path="Float"/></m0>
		<m4 public="1"><x path="Float"/></m4>
		<m8 public="1"><x path="Float"/></m8>
		<m12 public="1"><x path="Float"/></m12>
		<m1 public="1"><x path="Float"/></m1>
		<m5 public="1"><x path="Float"/></m5>
		<m9 public="1"><x path="Float"/></m9>
		<m13 public="1"><x path="Float"/></m13>
		<m2 public="1"><x path="Float"/></m2>
		<m6 public="1"><x path="Float"/></m6>
		<m10 public="1"><x path="Float"/></m10>
		<m14 public="1"><x path="Float"/></m14>
		<m3 public="1"><x path="Float"/></m3>
		<m7 public="1"><x path="Float"/></m7>
		<m11 public="1"><x path="Float"/></m11>
		<m15 public="1"><x path="Float"/></m15>
		<meta>
			<m n=":include"><e>"raylib.h"</e></m>
			<m n=":native"><e>"Matrix"</e></m>
			<m n=":structAccess"/>
		</meta>
	</class>
	<typedef path="Matrix" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl"><t path="cpp.Struct"><c path="RlMatrix"/></t></typedef>
	<class path="RlColor" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl" extern="1">
		<create public="1" get="inline" set="null" line="148" static="1">
			<f a="r:g:b:a">
				<x path="cpp.UInt8"/>
				<x path="cpp.UInt8"/>
				<x path="cpp.UInt8"/>
				<x path="cpp.UInt8"/>
				<t path="Color"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</create>
		<r public="1"><x path="cpp.UInt8"/></r>
		<g public="1"><x path="cpp.UInt8"/></g>
		<b public="1"><x path="cpp.UInt8"/></b>
		<a public="1"><x path="cpp.UInt8"/></a>
		<meta>
			<m n=":include"><e>"raylib.h"</e></m>
			<m n=":native"><e>"Color"</e></m>
			<m n=":structAccess"/>
		</meta>
	</class>
	<typedef path="Color" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl"><c path="RlColor"/></typedef>
	<class path="RlRectangle" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl" extern="1">
		<create public="1" get="inline" set="null" line="165" static="1">
			<f a="x:y:width:height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<t path="Rectangle"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</create>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<width public="1"><x path="Float"/></width>
		<height public="1"><x path="Float"/></height>
		<meta>
			<m n=":include"><e>"raylib.h"</e></m>
			<m n=":native"><e>"Rectangle"</e></m>
			<m n=":structAccess"/>
		</meta>
	</class>
	<typedef path="Rectangle" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl"><t path="cpp.Struct"><c path="RlRectangle"/></t></typedef>
	<class path="RlImage" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl" extern="1">
		<create public="1" get="inline" set="null" line="183" static="1">
			<f a="data:width:height:mipmaps:format">
				<c path="cpp.RawPointer"><c path="cpp.Void"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<t path="Image"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</create>
		<data public="1"><t path="cpp.Star"><c path="cpp.Void"/></t></data>
		<width public="1"><x path="Int"/></width>
		<height public="1"><x path="Int"/></height>
		<mipmaps public="1"><x path="Int"/></mipmaps>
		<format public="1"><x path="Int"/></format>
		<meta>
			<m n=":include"><e>"raylib.h"</e></m>
			<m n=":native"><e>"Image"</e></m>
			<m n=":structAccess"/>
		</meta>
	</class>
	<typedef path="Image" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl"><t path="cpp.Struct"><c path="RlImage"/></t></typedef>
	<class path="RlTexture" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl" extern="1">
		<id public="1"><x path="UInt"/></id>
		<width public="1"><x path="Int"/></width>
		<height public="1"><x path="Int"/></height>
		<mipmaps public="1"><x path="Int"/></mipmaps>
		<format public="1"><x path="Int"/></format>
		<meta>
			<m n=":include"><e>"raylib.h"</e></m>
			<m n=":native"><e>"Texture"</e></m>
			<m n=":structAccess"/>
			<m n=":unreflective"/>
		</meta>
	</class>
	<typedef path="Texture" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl"><t path="cpp.Struct"><c path="RlTexture"/></t></typedef>
	<typedef path="Texture2D" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl"><t path="Texture"/></typedef>
	<typedef path="TextureCubemap" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl"><t path="Texture"/></typedef>
	<class path="RlRenderTexture" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl" extern="1">
		<id public="1"><x path="UInt"/></id>
		<texture public="1"><t path="Texture"/></texture>
		<depth public="1"><t path="Texture"/></depth>
		<meta>
			<m n=":include"><e>"raylib.h"</e></m>
			<m n=":native"><e>"RenderTexture"</e></m>
			<m n=":structAccess"/>
		</meta>
	</class>
	<typedef path="RenderTexture" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl"><t path="cpp.Struct"><c path="RlRenderTexture"/></t></typedef>
	<typedef path="RenderTexture2D" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl"><t path="RenderTexture"/></typedef>
	<class path="NPatchInfo" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl" extern="1">
		<source public="1"><t path="Rectangle"/></source>
		<left public="1"><x path="Int"/></left>
		<top public="1"><x path="Int"/></top>
		<right public="1"><x path="Int"/></right>
		<bottom public="1"><x path="Int"/></bottom>
		<layout public="1"><x path="Int"/></layout>
		<meta>
			<m n=":include"><e>"raylib.h"</e></m>
			<m n=":native"><e>"NPatchInfo"</e></m>
			<m n=":structAccess"/>
		</meta>
	</class>
	<class path="GlyphInfo" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl" extern="1">
		<baseSize public="1"><x path="Int"/></baseSize>
		<glyphCount public="1"><x path="Int"/></glyphCount>
		<glyphPadding public="1"><x path="Int"/></glyphPadding>
		<texture public="1"><t path="Texture2D"/></texture>
		<recs public="1"><t path="cpp.Star"><t path="Rectangle"/></t></recs>
		<glyphs public="1"><t path="cpp.Star"><c path="GlyphInfo"/></t></glyphs>
		<meta>
			<m n=":include"><e>"raylib.h"</e></m>
			<m n=":native"><e>"GlyphInfo"</e></m>
			<m n=":structAccess"/>
		</meta>
	</class>
	<class path="CharInfo" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl" extern="1">
		<value public="1"><x path="Int"/></value>
		<offsetX public="1"><x path="Int"/></offsetX>
		<offsetY public="1"><x path="Int"/></offsetY>
		<advanceX public="1"><x path="Int"/></advanceX>
		<image public="1"><t path="Image"/></image>
		<meta>
			<m n=":include"><e>"raylib.h"</e></m>
			<m n=":native"><e>"CharInfo"</e></m>
			<m n=":structAccess"/>
		</meta>
	</class>
	<class path="Font" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl" extern="1">
		<baseSize public="1"><x path="Int"/></baseSize>
		<charsCount public="1"><x path="Int"/></charsCount>
		<charsPadding public="1"><x path="Int"/></charsPadding>
		<texture public="1"><t path="Texture2D"/></texture>
		<recs public="1"><t path="cpp.Star"><t path="Rectangle"/></t></recs>
		<chars public="1"><t path="cpp.Star"><c path="CharInfo"/></t></chars>
		<meta>
			<m n=":include"><e>"raylib.h"</e></m>
			<m n=":native"><e>"Font"</e></m>
			<m n=":structAccess"/>
		</meta>
	</class>
	<class path="RlCamera3D" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl" extern="1">
		<create public="1" get="inline" set="null" line="293" static="1">
			<f a=""><t path="Camera3D"/></f>
			<meta><m n=":has_untyped"/></meta>
		</create>
		<position public="1"><t path="Vector3"/></position>
		<target public="1"><t path="Vector3"/></target>
		<up public="1"><t path="Vector3"/></up>
		<fovy public="1"><x path="Float"/></fovy>
		<projection public="1"><x path="Int"/></projection>
		<meta>
			<m n=":include"><e>"raylib.h"</e></m>
			<m n=":native"><e>"Camera3D"</e></m>
			<m n=":structAccess"/>
		</meta>
	</class>
	<typedef path="Camera3D" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl"><t path="cpp.Struct"><c path="RlCamera3D"/></t></typedef>
	<typedef path="Camera" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl"><t path="Camera3D"/></typedef>
	<class path="RlCamera2D" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl" extern="1">
		<create public="1" get="inline" set="null" line="312" static="1">
			<f a=""><t path="Camera2D"/></f>
			<meta><m n=":has_untyped"/></meta>
		</create>
		<offset public="1"><t path="Vector2"/></offset>
		<target public="1"><t path="Vector2"/></target>
		<rotation public="1"><x path="Float"/></rotation>
		<zoom public="1"><x path="Float"/></zoom>
		<meta>
			<m n=":include"><e>"raylib.h"</e></m>
			<m n=":native"><e>"Camera2D"</e></m>
			<m n=":structAccess"/>
		</meta>
	</class>
	<typedef path="Camera2D" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl"><c path="RlCamera2D"/></typedef>
	<class path="Mesh" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl" extern="1">
		<VertexCount public="1"><x path="Int"/></VertexCount>
		<triangleCount public="1"><x path="Int"/></triangleCount>
		<Verticies public="1"><t path="cpp.Star"><x path="Float"/></t></Verticies>
		<textcoords public="1"><t path="cpp.Star"><x path="Float"/></t></textcoords>
		<texcoord2 public="1"><t path="cpp.Star"><x path="Float"/></t></texcoord2>
		<normals public="1"><t path="cpp.Star"><x path="Float"/></t></normals>
		<tangents public="1"><t path="cpp.Star"><x path="Float"/></t></tangents>
		<animVertices public="1"><t path="cpp.Star"><x path="Float"/></t></animVertices>
		<animNormals public="1"><t path="cpp.Star"><x path="Float"/></t></animNormals>
		<boneIds public="1"><t path="cpp.Star"><x path="Int"/></t></boneIds>
		<boneWeights public="1"><t path="cpp.Star"><x path="Float"/></t></boneWeights>
		<vaoId public="1"><x path="UInt"/></vaoId>
		<vboId public="1"><t path="cpp.Star"><x path="UInt"/></t></vboId>
		<meta>
			<m n=":include"><e>"raylib.h"</e></m>
			<m n=":native"><e>"Mesh"</e></m>
			<m n=":structAccess"/>
		</meta>
	</class>
	<class path="Shader" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl" extern="1">
		<id public="1"><x path="UInt"/></id>
		<locs public="1"><t path="cpp.Star"><x path="Int"/></t></locs>
		<meta>
			<m n=":include"><e>"raylib.h"</e></m>
			<m n=":native"><e>"Shader"</e></m>
			<m n=":structAccess"/>
		</meta>
	</class>
	<class path="MaterialMap" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl" extern="1">
		<texture public="1"><t path="Texture2D"/></texture>
		<color public="1"><t path="Color"/></color>
		<value public="1"><x path="Float"/></value>
		<meta>
			<m n=":include"><e>"raylib.h"</e></m>
			<m n=":native"><e>"MaterialMap"</e></m>
			<m n=":structAccess"/>
		</meta>
	</class>
	<class path="Material" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl" extern="1">
		<shader public="1"><c path="Shader"/></shader>
		<maps public="1"><t path="cpp.Star"><c path="MaterialMap"/></t></maps>
		<params public="1"><c path="Array"><x path="Float"/></c></params>
		<meta>
			<m n=":include"><e>"raylib.h"</e></m>
			<m n=":native"><e>"Material"</e></m>
			<m n=":structAccess"/>
		</meta>
	</class>
	<class path="Transform" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl" extern="1">
		<translation public="1"><t path="Vector3"/></translation>
		<rotation public="1"><t path="Quaternion"/></rotation>
		<scale public="1"><t path="Vector3"/></scale>
		<meta>
			<m n=":include"><e>"raylib.h"</e></m>
			<m n=":native"><e>"Transform"</e></m>
			<m n=":structAccess"/>
		</meta>
	</class>
	<class path="BoneInfo" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl" extern="1">
		<parent public="1"><x path="Int"/></parent>
		<meta>
			<m n=":include"><e>"raylib.h"</e></m>
			<m n=":native"><e>"BoneInfo"</e></m>
			<m n=":structAccess"/>
		</meta>
	</class>
	<class path="Model" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl" extern="1">
		<transform public="1"><t path="Matrix"/></transform>
		<meshCount public="1"><x path="Int"/></meshCount>
		<materialCount public="1"><x path="Int"/></materialCount>
		<meshes public="1"><t path="cpp.Star"><c path="Mesh"/></t></meshes>
		<materials public="1"><t path="cpp.Star"><c path="Material"/></t></materials>
		<meshMaterials public="1"><t path="cpp.Star"><x path="Int"/></t></meshMaterials>
		<boneCount public="1"><x path="Int"/></boneCount>
		<bones public="1"><t path="cpp.Star"><c path="BoneInfo"/></t></bones>
		<bindPose public="1"><t path="cpp.Star"><c path="Transform"/></t></bindPose>
		<meta>
			<m n=":include"><e>"raylib.h"</e></m>
			<m n=":native"><e>"Model"</e></m>
			<m n=":structAccess"/>
		</meta>
	</class>
	<class path="ModelAnimation" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl" extern="1">
		<boneCount public="1"><x path="Int"/></boneCount>
		<frameCount public="1"><x path="Int"/></frameCount>
		<bones public="1"><t path="cpp.Star"><c path="BoneInfo"/></t></bones>
		<framePoses public="1"><t path="cpp.Star"><t path="cpp.Star"><c path="Transform"/></t></t></framePoses>
		<meta>
			<m n=":include"><e>"raylib.h"</e></m>
			<m n=":native"><e>"ModelAnimation"</e></m>
			<m n=":structAccess"/>
		</meta>
	</class>
	<class path="Ray" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl" extern="1">
		<create public="1" get="inline" set="null" line="419" static="1">
			<f a=""><c path="Ray"/></f>
			<meta><m n=":has_untyped"/></meta>
		</create>
		<position public="1"><t path="Vector3"/></position>
		<direction public="1"><t path="Vector3"/></direction>
		<meta>
			<m n=":include"><e>"raylib.h"</e></m>
			<m n=":native"><e>"Ray"</e></m>
			<m n=":structAccess"/>
		</meta>
	</class>
	<class path="RayCollision" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl" extern="1">
		<create public="1" get="inline" set="null" line="433" static="1">
			<f a=""><c path="RayCollision"/></f>
			<meta><m n=":has_untyped"/></meta>
		</create>
		<hit public="1"><x path="Bool"/></hit>
		<distance public="1"><x path="Float"/></distance>
		<point public="1"><t path="Vector3"/></point>
		<normal public="1"><t path="Vector3"/></normal>
		<meta>
			<m n=":include"><e>"raylib.h"</e></m>
			<m n=":native"><e>"RayCollision"</e></m>
			<m n=":structAccess"/>
		</meta>
	</class>
	<class path="BoundingBox" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl" extern="1">
		<create public="1" get="inline" set="null" line="445" static="1">
			<f a="min:max">
				<t path="Vector3"/>
				<t path="Vector3"/>
				<c path="BoundingBox"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</create>
		<min public="1"><t path="Vector3"/></min>
		<max public="1"><t path="Vector3"/></max>
		<meta>
			<m n=":include"><e>"raylib.h"</e></m>
			<m n=":native"><e>"BoundingBox"</e></m>
			<m n=":structAccess"/>
		</meta>
	</class>
	<class path="Wave" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl" extern="1">
		<sampleCount public="1"><x path="UInt"/></sampleCount>
		<sampleRate public="1"><x path="UInt"/></sampleRate>
		<sampleSize public="1"><x path="UInt"/></sampleSize>
		<channels public="1"><x path="UInt"/></channels>
		<data public="1"><t path="cpp.Star"><c path="cpp.Void"/></t></data>
		<meta>
			<m n=":include"><e>"raylib.h"</e></m>
			<m n=":native"><e>"Wave"</e></m>
			<m n=":structAccess"/>
		</meta>
	</class>
	<class path="AudioBuffer" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl" extern="1"><meta>
	<m n=":include"><e>"raylib.h"</e></m>
	<m n=":native"><e>"rAudioBuffer"</e></m>
	<m n=":structAccess"/>
</meta></class>
	<class path="AudioStream" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl" extern="1">
		<buffer public="1"><t path="cpp.Star"><c path="AudioBuffer"/></t></buffer>
		<sampleRate public="1"><x path="UInt"/></sampleRate>
		<sampleSize public="1"><x path="UInt"/></sampleSize>
		<channels public="1"><x path="UInt"/></channels>
		<meta>
			<m n=":include"><e>"raylib.h"</e></m>
			<m n=":native"><e>"AudioStream"</e></m>
			<m n=":structAccess"/>
		</meta>
	</class>
	<class path="Sound" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl" extern="1">
		<stream public="1"><c path="AudioStream"/></stream>
		<sampleCount public="1"><x path="UInt"/></sampleCount>
		<meta>
			<m n=":include"><e>"raylib.h"</e></m>
			<m n=":native"><e>"Sound"</e></m>
			<m n=":structAccess"/>
		</meta>
	</class>
	<class path="Music" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl" extern="1">
		<stream public="1"><c path="AudioStream"/></stream>
		<sampleCount public="1"><x path="UInt"/></sampleCount>
		<looping public="1"><x path="Bool"/></looping>
		<ctxType public="1"><x path="Int"/></ctxType>
		<ctxData public="1"><t path="cpp.ConstStar"><c path="cpp.Void"/></t></ctxData>
		<meta>
			<m n=":include"><e>"raylib.h"</e></m>
			<m n=":native"><e>"Music"</e></m>
			<m n=":structAccess"/>
		</meta>
	</class>
	<class path="VrDeviceInfo" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl" extern="1">
		<hResolution public="1"><x path="Int"/></hResolution>
		<vResolution public="1"><x path="Int"/></vResolution>
		<hScreenSize public="1"><x path="Float"/></hScreenSize>
		<vScreenSize public="1"><x path="Float"/></vScreenSize>
		<vScreenCenter public="1"><x path="Float"/></vScreenCenter>
		<eyeToScreenDistance public="1"><x path="Float"/></eyeToScreenDistance>
		<lensSeparationDistance public="1"><x path="Float"/></lensSeparationDistance>
		<interpupillaryDistance public="1"><x path="Float"/></interpupillaryDistance>
		<lensDistortionValues public="1"><x path="Float"/></lensDistortionValues>
		<chromaAbCorrection public="1"><x path="Float"/></chromaAbCorrection>
		<meta>
			<m n=":include"><e>"raylib.h"</e></m>
			<m n=":native"><e>"VrDeviceInfo"</e></m>
			<m n=":structAccess"/>
		</meta>
	</class>
	<class path="VrStereoConfig" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl" extern="1">
		<projection public="1"><t path="Matrix"/></projection>
		<viewoffset public="1"><t path="Matrix"/></viewoffset>
		<leftLensCenter public="1"><x path="Float"/></leftLensCenter>
		<rightLensCenter public="1"><x path="Float"/></rightLensCenter>
		<leftScreenCenter public="1"><x path="Float"/></leftScreenCenter>
		<rightScreenCenter public="1"><x path="Float"/></rightScreenCenter>
		<scale public="1"><x path="Float"/></scale>
		<scaleIn public="1"><x path="Float"/></scaleIn>
		<meta>
			<m n=":include"><e>"raylib.h"</e></m>
			<m n=":native"><e>"VrStereoConfig"</e></m>
			<m n=":structAccess"/>
		</meta>
	</class>
	<abstract path="ConfigFlags" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl">
		<this><x path="UInt"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":include"><e>"raylib.h"</e></m>
		</meta>
		<impl><class path="_Rl.ConfigFlags_Impl_" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" private="1" module="Rl" extern="1" final="1">
	<FLAG_VSYNC_HINT public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"FLAG_VSYNC_HINT"</e></m>
		</meta>
	</FLAG_VSYNC_HINT>
	<FLAG_FULLSCREEN_MODE public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"FLAG_FULLSCREEN_MODE"</e></m>
		</meta>
	</FLAG_FULLSCREEN_MODE>
	<FLAG_WINDOW_RESIZABLE public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"FLAG_WINDOW_RESIZABLE"</e></m>
		</meta>
	</FLAG_WINDOW_RESIZABLE>
	<FLAG_WINDOW_UNDECORATED public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"FLAG_WINDOW_UNDECORATED"</e></m>
		</meta>
	</FLAG_WINDOW_UNDECORATED>
	<FLAG_WINDOW_HIDDEN public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"FLAG_WINDOW_HIDDEN"</e></m>
		</meta>
	</FLAG_WINDOW_HIDDEN>
	<FLAG_WINDOW_MINIMIZED public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"FLAG_WINDOW_MINIMIZED"</e></m>
		</meta>
	</FLAG_WINDOW_MINIMIZED>
	<FLAG_WINDOW_MAXIMIZED public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"FLAG_WINDOW_MAXIMIZED"</e></m>
		</meta>
	</FLAG_WINDOW_MAXIMIZED>
	<FLAG_WINDOW_UNFOCUSED public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"FLAG_WINDOW_UNFOCUSED"</e></m>
		</meta>
	</FLAG_WINDOW_UNFOCUSED>
	<FLAG_WINDOW_TOPMOST public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"FLAG_WINDOW_TOPMOST"</e></m>
		</meta>
	</FLAG_WINDOW_TOPMOST>
	<FLAG_WINDOW_ALWAYS_RUN public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"FLAG_WINDOW_ALWAYS_RUN"</e></m>
		</meta>
	</FLAG_WINDOW_ALWAYS_RUN>
	<FLAG_WINDOW_TRANSPARENT public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"FLAG_WINDOW_TRANSPARENT"</e></m>
		</meta>
	</FLAG_WINDOW_TRANSPARENT>
	<FLAG_WINDOW_HIGHDPI public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"FLAG_WINDOW_HIGHDPI"</e></m>
		</meta>
	</FLAG_WINDOW_HIGHDPI>
	<FLAG_MSAA_4X_HINT public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"FLAG_MSAA_4X_HINT"</e></m>
		</meta>
	</FLAG_MSAA_4X_HINT>
	<FLAG_INTERLACED_HINT public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"FLAG_INTERLACED_HINT"</e></m>
		</meta>
	</FLAG_INTERLACED_HINT>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="_Rl.ConfigFlags_Impl_" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" private="1" module="Rl" extern="1" final="1">
		<FLAG_VSYNC_HINT public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"FLAG_VSYNC_HINT"</e></m>
			</meta>
		</FLAG_VSYNC_HINT>
		<FLAG_FULLSCREEN_MODE public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"FLAG_FULLSCREEN_MODE"</e></m>
			</meta>
		</FLAG_FULLSCREEN_MODE>
		<FLAG_WINDOW_RESIZABLE public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"FLAG_WINDOW_RESIZABLE"</e></m>
			</meta>
		</FLAG_WINDOW_RESIZABLE>
		<FLAG_WINDOW_UNDECORATED public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"FLAG_WINDOW_UNDECORATED"</e></m>
			</meta>
		</FLAG_WINDOW_UNDECORATED>
		<FLAG_WINDOW_HIDDEN public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"FLAG_WINDOW_HIDDEN"</e></m>
			</meta>
		</FLAG_WINDOW_HIDDEN>
		<FLAG_WINDOW_MINIMIZED public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"FLAG_WINDOW_MINIMIZED"</e></m>
			</meta>
		</FLAG_WINDOW_MINIMIZED>
		<FLAG_WINDOW_MAXIMIZED public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"FLAG_WINDOW_MAXIMIZED"</e></m>
			</meta>
		</FLAG_WINDOW_MAXIMIZED>
		<FLAG_WINDOW_UNFOCUSED public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"FLAG_WINDOW_UNFOCUSED"</e></m>
			</meta>
		</FLAG_WINDOW_UNFOCUSED>
		<FLAG_WINDOW_TOPMOST public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"FLAG_WINDOW_TOPMOST"</e></m>
			</meta>
		</FLAG_WINDOW_TOPMOST>
		<FLAG_WINDOW_ALWAYS_RUN public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"FLAG_WINDOW_ALWAYS_RUN"</e></m>
			</meta>
		</FLAG_WINDOW_ALWAYS_RUN>
		<FLAG_WINDOW_TRANSPARENT public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"FLAG_WINDOW_TRANSPARENT"</e></m>
			</meta>
		</FLAG_WINDOW_TRANSPARENT>
		<FLAG_WINDOW_HIGHDPI public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"FLAG_WINDOW_HIGHDPI"</e></m>
			</meta>
		</FLAG_WINDOW_HIGHDPI>
		<FLAG_MSAA_4X_HINT public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"FLAG_MSAA_4X_HINT"</e></m>
			</meta>
		</FLAG_MSAA_4X_HINT>
		<FLAG_INTERLACED_HINT public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"FLAG_INTERLACED_HINT"</e></m>
			</meta>
		</FLAG_INTERLACED_HINT>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="TraceLogLevel" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl">
		<this><x path="Int"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":include"><e>"raylib.h"</e></m>
		</meta>
		<impl><class path="_Rl.TraceLogLevel_Impl_" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" private="1" module="Rl" extern="1" final="1">
	<ALL public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"LOG_ALL"</e></m></meta>
	</ALL>
	<TRACE public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"LOG_TRACE"</e></m></meta>
	</TRACE>
	<DEBUG public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"LOG_DEBUG"</e></m></meta>
	</DEBUG>
	<INFO public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"LOG_INFO"</e></m></meta>
	</INFO>
	<WARNING public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"LOG_WARNING"</e></m></meta>
	</WARNING>
	<ERROR public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"LOG_ERROR"</e></m></meta>
	</ERROR>
	<FATAL public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"LOG_FATAL"</e></m></meta>
	</FATAL>
	<NONE public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"LOG_NONE"</e></m></meta>
	</NONE>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="_Rl.TraceLogLevel_Impl_" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" private="1" module="Rl" extern="1" final="1">
		<ALL public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"LOG_ALL"</e></m></meta>
		</ALL>
		<TRACE public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"LOG_TRACE"</e></m></meta>
		</TRACE>
		<DEBUG public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"LOG_DEBUG"</e></m></meta>
		</DEBUG>
		<INFO public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"LOG_INFO"</e></m></meta>
		</INFO>
		<WARNING public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"LOG_WARNING"</e></m></meta>
		</WARNING>
		<ERROR public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"LOG_ERROR"</e></m></meta>
		</ERROR>
		<FATAL public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"LOG_FATAL"</e></m></meta>
		</FATAL>
		<NONE public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"LOG_NONE"</e></m></meta>
		</NONE>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="CameraProjection" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl">
		<this><x path="Int"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":include"><e>"raylib.h"</e></m>
		</meta>
		<impl><class path="_Rl.CameraProjection_Impl_" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" private="1" module="Rl" extern="1" final="1">
	<CAMERA_PERSPECTIVE public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"CAMERA_PERSPECTIVE"</e></m></meta>
	</CAMERA_PERSPECTIVE>
	<CAMERA_ORTHOGRAPHIC public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"CAMERA_ORTHOGRAPHIC"</e></m></meta>
	</CAMERA_ORTHOGRAPHIC>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="_Rl.CameraProjection_Impl_" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" private="1" module="Rl" extern="1" final="1">
		<CAMERA_PERSPECTIVE public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"CAMERA_PERSPECTIVE"</e></m></meta>
		</CAMERA_PERSPECTIVE>
		<CAMERA_ORTHOGRAPHIC public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"CAMERA_ORTHOGRAPHIC"</e></m></meta>
		</CAMERA_ORTHOGRAPHIC>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="CameraMode" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl">
		<this><x path="Int"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":include"><e>"raylib.h"</e></m>
		</meta>
		<impl><class path="_Rl.CameraMode_Impl_" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" private="1" module="Rl" extern="1" final="1">
	<CUSTOM public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"CAMERA_CUSTOM"</e></m></meta>
	</CUSTOM>
	<FREE public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"CAMERA_FREE"</e></m></meta>
	</FREE>
	<ORBITAL public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"CAMERA_ORBITAL"</e></m></meta>
	</ORBITAL>
	<FIRST_PERSON public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"CAMERA_FIRST_PERSON"</e></m></meta>
	</FIRST_PERSON>
	<THIRD_PERSON public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"CAMERA_THIRD_PERSON"</e></m></meta>
	</THIRD_PERSON>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="_Rl.CameraMode_Impl_" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" private="1" module="Rl" extern="1" final="1">
		<CUSTOM public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"CAMERA_CUSTOM"</e></m></meta>
		</CUSTOM>
		<FREE public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"CAMERA_FREE"</e></m></meta>
		</FREE>
		<ORBITAL public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"CAMERA_ORBITAL"</e></m></meta>
		</ORBITAL>
		<FIRST_PERSON public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"CAMERA_FIRST_PERSON"</e></m></meta>
		</FIRST_PERSON>
		<THIRD_PERSON public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"CAMERA_THIRD_PERSON"</e></m></meta>
		</THIRD_PERSON>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="Config" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl">
		<this><x path="UInt"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":include"><e>"raylib.h"</e></m>
		</meta>
		<impl><class path="_Rl.Config_Impl_" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" private="1" module="Rl" extern="1" final="1"><meta><m n=":enum"/></meta></class></impl>
	</abstract>
	<class path="_Rl.Config_Impl_" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" private="1" module="Rl" extern="1" final="1"><meta><m n=":enum"/></meta></class>
	<abstract path="Keys" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl">
		<this><x path="Int"/></this>
		<haxe_doc>Keyboard keys (US keyboard layout)</haxe_doc>
		<meta>
			<m n=":enum"/>
			<m n=":include"><e>"raylib.h"</e></m>
		</meta>
		<impl><class path="_Rl.Keys_Impl_" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" private="1" module="Rl" extern="1" final="1">
	<NULL public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_NULL"</e></m></meta>
	</NULL>
	<APOSTROPHE public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_APOSTROPHE"</e></m></meta>
	</APOSTROPHE>
	<COMMA public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_COMMA"</e></m></meta>
	</COMMA>
	<MINUS public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_MINUS"</e></m></meta>
	</MINUS>
	<PERIOD public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_PERIOD"</e></m></meta>
	</PERIOD>
	<SLASH public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_SLASH"</e></m></meta>
	</SLASH>
	<ZERO public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_ZERO"</e></m></meta>
	</ZERO>
	<ONE public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_ONE"</e></m></meta>
	</ONE>
	<TWO public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_TWO"</e></m></meta>
	</TWO>
	<THREE public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_THREE"</e></m></meta>
	</THREE>
	<FOUR public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_FOUR"</e></m></meta>
	</FOUR>
	<FIVE public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_FIVE"</e></m></meta>
	</FIVE>
	<SIX public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_SIX"</e></m></meta>
	</SIX>
	<SEVEN public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_SEVEN"</e></m></meta>
	</SEVEN>
	<EIGHT public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_EIGHT"</e></m></meta>
	</EIGHT>
	<NINE public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_NINE"</e></m></meta>
	</NINE>
	<SEMICOLON public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_SEMICOLON"</e></m></meta>
	</SEMICOLON>
	<EQUAL public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_EQUAL"</e></m></meta>
	</EQUAL>
	<A public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_A"</e></m></meta>
	</A>
	<B public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_B"</e></m></meta>
	</B>
	<C public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_C"</e></m></meta>
	</C>
	<D public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_D"</e></m></meta>
	</D>
	<E public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_E"</e></m></meta>
	</E>
	<F public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_F"</e></m></meta>
	</F>
	<G public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_G"</e></m></meta>
	</G>
	<H public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_H"</e></m></meta>
	</H>
	<I public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_I"</e></m></meta>
	</I>
	<J public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_J"</e></m></meta>
	</J>
	<K public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_K"</e></m></meta>
	</K>
	<L public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_L"</e></m></meta>
	</L>
	<M public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_M"</e></m></meta>
	</M>
	<N public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_N"</e></m></meta>
	</N>
	<O public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_O"</e></m></meta>
	</O>
	<P public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_P"</e></m></meta>
	</P>
	<Q public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_Q"</e></m></meta>
	</Q>
	<R public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_R"</e></m></meta>
	</R>
	<S public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_S"</e></m></meta>
	</S>
	<T public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_T"</e></m></meta>
	</T>
	<U public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_U"</e></m></meta>
	</U>
	<V public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_V"</e></m></meta>
	</V>
	<W public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_W"</e></m></meta>
	</W>
	<X public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_X"</e></m></meta>
	</X>
	<Y public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_Y"</e></m></meta>
	</Y>
	<Z public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_Z"</e></m></meta>
	</Z>
	<SPACE public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_SPACE"</e></m></meta>
	</SPACE>
	<ESCAPE public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_ESCAPE"</e></m></meta>
	</ESCAPE>
	<ENTER public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_ENTER"</e></m></meta>
	</ENTER>
	<TAB public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_TAB"</e></m></meta>
	</TAB>
	<BACKSPACE public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_BACKSPACE"</e></m></meta>
	</BACKSPACE>
	<INSERT public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_INSERT"</e></m></meta>
	</INSERT>
	<DELETE public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_DELETE"</e></m></meta>
	</DELETE>
	<RIGHT public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_RIGHT"</e></m></meta>
	</RIGHT>
	<LEFT public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_LEFT"</e></m></meta>
	</LEFT>
	<DOWN public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_DOWN"</e></m></meta>
	</DOWN>
	<UP public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_UP"</e></m></meta>
	</UP>
	<PAGE_UP public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_PAGE_UP"</e></m></meta>
	</PAGE_UP>
	<PAGE_DOWN public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_PAGE_DOWN"</e></m></meta>
	</PAGE_DOWN>
	<HOME public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_HOME"</e></m></meta>
	</HOME>
	<END public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_END"</e></m></meta>
	</END>
	<CAPS_LOCK public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_CAPS_LOCK"</e></m></meta>
	</CAPS_LOCK>
	<SCROLL_LOCK public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_SCROLL_LOCK"</e></m></meta>
	</SCROLL_LOCK>
	<NUM_LOCK public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_NUM_LOCK"</e></m></meta>
	</NUM_LOCK>
	<PRINT_SCREEN public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_PRINT_SCREEN"</e></m></meta>
	</PRINT_SCREEN>
	<PAUSE public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_PAUSE"</e></m></meta>
	</PAUSE>
	<F1 public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_F1"</e></m></meta>
	</F1>
	<F2 public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_F2"</e></m></meta>
	</F2>
	<F3 public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_F3"</e></m></meta>
	</F3>
	<F4 public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_F4"</e></m></meta>
	</F4>
	<F5 public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_F5"</e></m></meta>
	</F5>
	<F6 public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_F6"</e></m></meta>
	</F6>
	<F7 public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_F7"</e></m></meta>
	</F7>
	<F8 public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_F8"</e></m></meta>
	</F8>
	<F9 public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_F9"</e></m></meta>
	</F9>
	<F10 public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_F10"</e></m></meta>
	</F10>
	<F11 public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_F11"</e></m></meta>
	</F11>
	<F12 public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_F12"</e></m></meta>
	</F12>
	<LEFT_SHIFT public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_LEFT_SHIFT"</e></m></meta>
	</LEFT_SHIFT>
	<LEFT_CONTROL public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_LEFT_CONTROL"</e></m></meta>
	</LEFT_CONTROL>
	<LEFT_ALT public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_LEFT_ALT"</e></m></meta>
	</LEFT_ALT>
	<LEFT_SUPER public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_LEFT_SUPER"</e></m></meta>
	</LEFT_SUPER>
	<RIGHT_SHIFT public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_RIGHT_SHIFT"</e></m></meta>
	</RIGHT_SHIFT>
	<RIGHT_CONTROL public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_RIGHT_CONTROL"</e></m></meta>
	</RIGHT_CONTROL>
	<RIGHT_ALT public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_RIGHT_ALT"</e></m></meta>
	</RIGHT_ALT>
	<RIGHT_SUPER public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_RIGHT_SUPER"</e></m></meta>
	</RIGHT_SUPER>
	<KB_MENU public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_KB_MENU"</e></m></meta>
	</KB_MENU>
	<LEFT_BRACKET public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_LEFT_BRACKET"</e></m></meta>
	</LEFT_BRACKET>
	<BACKSLASH public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_BACKSLASH"</e></m></meta>
	</BACKSLASH>
	<RIGHT_BRACKET public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_RIGHT_BRACKET"</e></m></meta>
	</RIGHT_BRACKET>
	<GRAVE public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_GRAVE"</e></m></meta>
	</GRAVE>
	<KP_0 public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_KP_0"</e></m></meta>
	</KP_0>
	<KP_1 public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_KP_1"</e></m></meta>
	</KP_1>
	<KP_2 public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_KP_2"</e></m></meta>
	</KP_2>
	<KP_3 public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_KP_3"</e></m></meta>
	</KP_3>
	<KP_4 public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_KP_4"</e></m></meta>
	</KP_4>
	<KP_5 public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_KP_5"</e></m></meta>
	</KP_5>
	<KP_6 public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_KP_6"</e></m></meta>
	</KP_6>
	<KP_7 public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_KP_7"</e></m></meta>
	</KP_7>
	<KP_8 public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_KP_8"</e></m></meta>
	</KP_8>
	<KP_9 public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_KP_9"</e></m></meta>
	</KP_9>
	<KP_DECIMAL public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_KP_DECIMAL"</e></m></meta>
	</KP_DECIMAL>
	<KP_DIVIDE public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_KP_DIVIDE"</e></m></meta>
	</KP_DIVIDE>
	<KP_MULTIPLY public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_KP_MULTIPLY"</e></m></meta>
	</KP_MULTIPLY>
	<KP_SUBTRACT public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_KP_SUBTRACT"</e></m></meta>
	</KP_SUBTRACT>
	<KP_ADD public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_KP_ADD"</e></m></meta>
	</KP_ADD>
	<KP_ENTER public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_KP_ENTER"</e></m></meta>
	</KP_ENTER>
	<KP_EQUAL public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"KEY_KP_EQUAL"</e></m></meta>
	</KP_EQUAL>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="_Rl.Keys_Impl_" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" private="1" module="Rl" extern="1" final="1">
		<NULL public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_NULL"</e></m></meta>
		</NULL>
		<APOSTROPHE public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_APOSTROPHE"</e></m></meta>
		</APOSTROPHE>
		<COMMA public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_COMMA"</e></m></meta>
		</COMMA>
		<MINUS public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_MINUS"</e></m></meta>
		</MINUS>
		<PERIOD public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_PERIOD"</e></m></meta>
		</PERIOD>
		<SLASH public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_SLASH"</e></m></meta>
		</SLASH>
		<ZERO public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_ZERO"</e></m></meta>
		</ZERO>
		<ONE public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_ONE"</e></m></meta>
		</ONE>
		<TWO public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_TWO"</e></m></meta>
		</TWO>
		<THREE public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_THREE"</e></m></meta>
		</THREE>
		<FOUR public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_FOUR"</e></m></meta>
		</FOUR>
		<FIVE public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_FIVE"</e></m></meta>
		</FIVE>
		<SIX public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_SIX"</e></m></meta>
		</SIX>
		<SEVEN public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_SEVEN"</e></m></meta>
		</SEVEN>
		<EIGHT public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_EIGHT"</e></m></meta>
		</EIGHT>
		<NINE public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_NINE"</e></m></meta>
		</NINE>
		<SEMICOLON public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_SEMICOLON"</e></m></meta>
		</SEMICOLON>
		<EQUAL public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_EQUAL"</e></m></meta>
		</EQUAL>
		<A public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_A"</e></m></meta>
		</A>
		<B public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_B"</e></m></meta>
		</B>
		<C public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_C"</e></m></meta>
		</C>
		<D public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_D"</e></m></meta>
		</D>
		<E public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_E"</e></m></meta>
		</E>
		<F public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_F"</e></m></meta>
		</F>
		<G public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_G"</e></m></meta>
		</G>
		<H public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_H"</e></m></meta>
		</H>
		<I public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_I"</e></m></meta>
		</I>
		<J public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_J"</e></m></meta>
		</J>
		<K public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_K"</e></m></meta>
		</K>
		<L public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_L"</e></m></meta>
		</L>
		<M public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_M"</e></m></meta>
		</M>
		<N public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_N"</e></m></meta>
		</N>
		<O public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_O"</e></m></meta>
		</O>
		<P public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_P"</e></m></meta>
		</P>
		<Q public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_Q"</e></m></meta>
		</Q>
		<R public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_R"</e></m></meta>
		</R>
		<S public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_S"</e></m></meta>
		</S>
		<T public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_T"</e></m></meta>
		</T>
		<U public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_U"</e></m></meta>
		</U>
		<V public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_V"</e></m></meta>
		</V>
		<W public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_W"</e></m></meta>
		</W>
		<X public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_X"</e></m></meta>
		</X>
		<Y public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_Y"</e></m></meta>
		</Y>
		<Z public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_Z"</e></m></meta>
		</Z>
		<SPACE public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_SPACE"</e></m></meta>
		</SPACE>
		<ESCAPE public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_ESCAPE"</e></m></meta>
		</ESCAPE>
		<ENTER public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_ENTER"</e></m></meta>
		</ENTER>
		<TAB public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_TAB"</e></m></meta>
		</TAB>
		<BACKSPACE public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_BACKSPACE"</e></m></meta>
		</BACKSPACE>
		<INSERT public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_INSERT"</e></m></meta>
		</INSERT>
		<DELETE public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_DELETE"</e></m></meta>
		</DELETE>
		<RIGHT public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_RIGHT"</e></m></meta>
		</RIGHT>
		<LEFT public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_LEFT"</e></m></meta>
		</LEFT>
		<DOWN public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_DOWN"</e></m></meta>
		</DOWN>
		<UP public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_UP"</e></m></meta>
		</UP>
		<PAGE_UP public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_PAGE_UP"</e></m></meta>
		</PAGE_UP>
		<PAGE_DOWN public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_PAGE_DOWN"</e></m></meta>
		</PAGE_DOWN>
		<HOME public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_HOME"</e></m></meta>
		</HOME>
		<END public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_END"</e></m></meta>
		</END>
		<CAPS_LOCK public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_CAPS_LOCK"</e></m></meta>
		</CAPS_LOCK>
		<SCROLL_LOCK public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_SCROLL_LOCK"</e></m></meta>
		</SCROLL_LOCK>
		<NUM_LOCK public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_NUM_LOCK"</e></m></meta>
		</NUM_LOCK>
		<PRINT_SCREEN public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_PRINT_SCREEN"</e></m></meta>
		</PRINT_SCREEN>
		<PAUSE public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_PAUSE"</e></m></meta>
		</PAUSE>
		<F1 public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_F1"</e></m></meta>
		</F1>
		<F2 public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_F2"</e></m></meta>
		</F2>
		<F3 public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_F3"</e></m></meta>
		</F3>
		<F4 public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_F4"</e></m></meta>
		</F4>
		<F5 public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_F5"</e></m></meta>
		</F5>
		<F6 public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_F6"</e></m></meta>
		</F6>
		<F7 public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_F7"</e></m></meta>
		</F7>
		<F8 public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_F8"</e></m></meta>
		</F8>
		<F9 public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_F9"</e></m></meta>
		</F9>
		<F10 public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_F10"</e></m></meta>
		</F10>
		<F11 public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_F11"</e></m></meta>
		</F11>
		<F12 public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_F12"</e></m></meta>
		</F12>
		<LEFT_SHIFT public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_LEFT_SHIFT"</e></m></meta>
		</LEFT_SHIFT>
		<LEFT_CONTROL public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_LEFT_CONTROL"</e></m></meta>
		</LEFT_CONTROL>
		<LEFT_ALT public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_LEFT_ALT"</e></m></meta>
		</LEFT_ALT>
		<LEFT_SUPER public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_LEFT_SUPER"</e></m></meta>
		</LEFT_SUPER>
		<RIGHT_SHIFT public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_RIGHT_SHIFT"</e></m></meta>
		</RIGHT_SHIFT>
		<RIGHT_CONTROL public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_RIGHT_CONTROL"</e></m></meta>
		</RIGHT_CONTROL>
		<RIGHT_ALT public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_RIGHT_ALT"</e></m></meta>
		</RIGHT_ALT>
		<RIGHT_SUPER public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_RIGHT_SUPER"</e></m></meta>
		</RIGHT_SUPER>
		<KB_MENU public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_KB_MENU"</e></m></meta>
		</KB_MENU>
		<LEFT_BRACKET public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_LEFT_BRACKET"</e></m></meta>
		</LEFT_BRACKET>
		<BACKSLASH public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_BACKSLASH"</e></m></meta>
		</BACKSLASH>
		<RIGHT_BRACKET public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_RIGHT_BRACKET"</e></m></meta>
		</RIGHT_BRACKET>
		<GRAVE public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_GRAVE"</e></m></meta>
		</GRAVE>
		<KP_0 public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_KP_0"</e></m></meta>
		</KP_0>
		<KP_1 public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_KP_1"</e></m></meta>
		</KP_1>
		<KP_2 public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_KP_2"</e></m></meta>
		</KP_2>
		<KP_3 public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_KP_3"</e></m></meta>
		</KP_3>
		<KP_4 public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_KP_4"</e></m></meta>
		</KP_4>
		<KP_5 public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_KP_5"</e></m></meta>
		</KP_5>
		<KP_6 public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_KP_6"</e></m></meta>
		</KP_6>
		<KP_7 public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_KP_7"</e></m></meta>
		</KP_7>
		<KP_8 public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_KP_8"</e></m></meta>
		</KP_8>
		<KP_9 public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_KP_9"</e></m></meta>
		</KP_9>
		<KP_DECIMAL public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_KP_DECIMAL"</e></m></meta>
		</KP_DECIMAL>
		<KP_DIVIDE public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_KP_DIVIDE"</e></m></meta>
		</KP_DIVIDE>
		<KP_MULTIPLY public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_KP_MULTIPLY"</e></m></meta>
		</KP_MULTIPLY>
		<KP_SUBTRACT public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_KP_SUBTRACT"</e></m></meta>
		</KP_SUBTRACT>
		<KP_ADD public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_KP_ADD"</e></m></meta>
		</KP_ADD>
		<KP_ENTER public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_KP_ENTER"</e></m></meta>
		</KP_ENTER>
		<KP_EQUAL public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"KEY_KP_EQUAL"</e></m></meta>
		</KP_EQUAL>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="MouseButton" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl">
		<this><x path="Int"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":include"><e>"raylib.h"</e></m>
		</meta>
		<impl><class path="_Rl.MouseButton_Impl_" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" private="1" module="Rl" extern="1" final="1">
	<LEFT public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"MOUSE_BUTTON_LEFT"</e></m></meta>
	</LEFT>
	<RIGHT public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"MOUSE_BUTTON_RIGHT"</e></m></meta>
	</RIGHT>
	<MIDDLE public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"MOUSE_BUTTON_MIDDLE"</e></m></meta>
	</MIDDLE>
	<SIDE public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"MOUSE_BUTTON_SIDE"</e></m></meta>
	</SIDE>
	<EXTRA public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"MOUSE_BUTTON_EXTRA"</e></m></meta>
	</EXTRA>
	<FORWARD public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"MOUSE_BUTTON_FORWARD"</e></m></meta>
	</FORWARD>
	<BACK public="1" static="1">
		<x path="Int"/>
		<meta><m n=":native"><e>"MOUSE_BUTTON_BACK"</e></m></meta>
	</BACK>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="_Rl.MouseButton_Impl_" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" private="1" module="Rl" extern="1" final="1">
		<LEFT public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"MOUSE_BUTTON_LEFT"</e></m></meta>
		</LEFT>
		<RIGHT public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"MOUSE_BUTTON_RIGHT"</e></m></meta>
		</RIGHT>
		<MIDDLE public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"MOUSE_BUTTON_MIDDLE"</e></m></meta>
		</MIDDLE>
		<SIDE public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"MOUSE_BUTTON_SIDE"</e></m></meta>
		</SIDE>
		<EXTRA public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"MOUSE_BUTTON_EXTRA"</e></m></meta>
		</EXTRA>
		<FORWARD public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"MOUSE_BUTTON_FORWARD"</e></m></meta>
		</FORWARD>
		<BACK public="1" static="1">
			<x path="Int"/>
			<meta><m n=":native"><e>"MOUSE_BUTTON_BACK"</e></m></meta>
		</BACK>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="MouseCursor" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl">
		<this><x path="Int"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":include"><e>"raylib.h"</e></m>
		</meta>
		<impl><class path="_Rl.MouseCursor_Impl_" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" private="1" module="Rl" extern="1" final="1">
	<MOUSE_CURSOR_DEFAULT public="1" set="null" static="1">
		<x path="Int"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"MOUSE_CURSOR_DEFAULT"</e></m>
		</meta>
	</MOUSE_CURSOR_DEFAULT>
	<MOUSE_CURSOR_ARROW public="1" set="null" static="1">
		<x path="Int"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"MOUSE_CURSOR_ARROW"</e></m>
		</meta>
	</MOUSE_CURSOR_ARROW>
	<MOUSE_CURSOR_IBEAM public="1" set="null" static="1">
		<x path="Int"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"MOUSE_CURSOR_IBEAM"</e></m>
		</meta>
	</MOUSE_CURSOR_IBEAM>
	<MOUSE_CURSOR_CROSSHAIR public="1" set="null" static="1">
		<x path="Int"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"MOUSE_CURSOR_CROSSHAIR"</e></m>
		</meta>
	</MOUSE_CURSOR_CROSSHAIR>
	<MOUSE_CURSOR_POINTING_HAND public="1" set="null" static="1">
		<x path="Int"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"MOUSE_CURSOR_POINTING_HAND"</e></m>
		</meta>
	</MOUSE_CURSOR_POINTING_HAND>
	<MOUSE_CURSOR_RESIZE_EW public="1" set="null" static="1">
		<x path="Int"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"MOUSE_CURSOR_RESIZE_EW"</e></m>
		</meta>
	</MOUSE_CURSOR_RESIZE_EW>
	<MOUSE_CURSOR_RESIZE_NS public="1" set="null" static="1">
		<x path="Int"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"MOUSE_CURSOR_RESIZE_NS"</e></m>
		</meta>
	</MOUSE_CURSOR_RESIZE_NS>
	<MOUSE_CURSOR_RESIZE_NWSE public="1" set="null" static="1">
		<x path="Int"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"MOUSE_CURSOR_RESIZE_NWSE"</e></m>
		</meta>
	</MOUSE_CURSOR_RESIZE_NWSE>
	<MOUSE_CURSOR_RESIZE_NESW public="1" set="null" static="1">
		<x path="Int"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"MOUSE_CURSOR_RESIZE_NESW"</e></m>
		</meta>
	</MOUSE_CURSOR_RESIZE_NESW>
	<MOUSE_CURSOR_RESIZE_ALL public="1" set="null" static="1">
		<x path="Int"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"MOUSE_CURSOR_RESIZE_ALL"</e></m>
		</meta>
	</MOUSE_CURSOR_RESIZE_ALL>
	<MOUSE_CURSOR_NOT_ALLOWED public="1" set="null" static="1">
		<x path="Int"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"MOUSE_CURSOR_NOT_ALLOWED"</e></m>
		</meta>
	</MOUSE_CURSOR_NOT_ALLOWED>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="_Rl.MouseCursor_Impl_" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" private="1" module="Rl" extern="1" final="1">
		<MOUSE_CURSOR_DEFAULT public="1" set="null" static="1">
			<x path="Int"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"MOUSE_CURSOR_DEFAULT"</e></m>
			</meta>
		</MOUSE_CURSOR_DEFAULT>
		<MOUSE_CURSOR_ARROW public="1" set="null" static="1">
			<x path="Int"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"MOUSE_CURSOR_ARROW"</e></m>
			</meta>
		</MOUSE_CURSOR_ARROW>
		<MOUSE_CURSOR_IBEAM public="1" set="null" static="1">
			<x path="Int"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"MOUSE_CURSOR_IBEAM"</e></m>
			</meta>
		</MOUSE_CURSOR_IBEAM>
		<MOUSE_CURSOR_CROSSHAIR public="1" set="null" static="1">
			<x path="Int"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"MOUSE_CURSOR_CROSSHAIR"</e></m>
			</meta>
		</MOUSE_CURSOR_CROSSHAIR>
		<MOUSE_CURSOR_POINTING_HAND public="1" set="null" static="1">
			<x path="Int"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"MOUSE_CURSOR_POINTING_HAND"</e></m>
			</meta>
		</MOUSE_CURSOR_POINTING_HAND>
		<MOUSE_CURSOR_RESIZE_EW public="1" set="null" static="1">
			<x path="Int"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"MOUSE_CURSOR_RESIZE_EW"</e></m>
			</meta>
		</MOUSE_CURSOR_RESIZE_EW>
		<MOUSE_CURSOR_RESIZE_NS public="1" set="null" static="1">
			<x path="Int"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"MOUSE_CURSOR_RESIZE_NS"</e></m>
			</meta>
		</MOUSE_CURSOR_RESIZE_NS>
		<MOUSE_CURSOR_RESIZE_NWSE public="1" set="null" static="1">
			<x path="Int"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"MOUSE_CURSOR_RESIZE_NWSE"</e></m>
			</meta>
		</MOUSE_CURSOR_RESIZE_NWSE>
		<MOUSE_CURSOR_RESIZE_NESW public="1" set="null" static="1">
			<x path="Int"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"MOUSE_CURSOR_RESIZE_NESW"</e></m>
			</meta>
		</MOUSE_CURSOR_RESIZE_NESW>
		<MOUSE_CURSOR_RESIZE_ALL public="1" set="null" static="1">
			<x path="Int"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"MOUSE_CURSOR_RESIZE_ALL"</e></m>
			</meta>
		</MOUSE_CURSOR_RESIZE_ALL>
		<MOUSE_CURSOR_NOT_ALLOWED public="1" set="null" static="1">
			<x path="Int"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"MOUSE_CURSOR_NOT_ALLOWED"</e></m>
			</meta>
		</MOUSE_CURSOR_NOT_ALLOWED>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="GamepadButton" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl">
		<this><x path="UInt"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":include"><e>"raylib.h"</e></m>
		</meta>
		<impl><class path="_Rl.GamepadButton_Impl_" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" private="1" module="Rl" extern="1" final="1">
	<GAMEPAD_BUTTON_UNKNOWN public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"GAMEPAD_BUTTON_UNKNOWN"</e></m>
		</meta>
	</GAMEPAD_BUTTON_UNKNOWN>
	<GAMEPAD_BUTTON_LEFT_FACE_UP public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"GAMEPAD_BUTTON_LEFT_FACE_UP"</e></m>
		</meta>
	</GAMEPAD_BUTTON_LEFT_FACE_UP>
	<GAMEPAD_BUTTON_LEFT_FACE_RIGHT public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"GAMEPAD_BUTTON_LEFT_FACE_RIGHT"</e></m>
		</meta>
	</GAMEPAD_BUTTON_LEFT_FACE_RIGHT>
	<GAMEPAD_BUTTON_LEFT_FACE_DOWN public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"GAMEPAD_BUTTON_LEFT_FACE_DOWN"</e></m>
		</meta>
	</GAMEPAD_BUTTON_LEFT_FACE_DOWN>
	<GAMEPAD_BUTTON_LEFT_FACE_LEFT public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"GAMEPAD_BUTTON_LEFT_FACE_LEFT"</e></m>
		</meta>
	</GAMEPAD_BUTTON_LEFT_FACE_LEFT>
	<GAMEPAD_BUTTON_RIGHT_FACE_UP public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"GAMEPAD_BUTTON_RIGHT_FACE_UP"</e></m>
		</meta>
	</GAMEPAD_BUTTON_RIGHT_FACE_UP>
	<GAMEPAD_BUTTON_RIGHT_FACE_RIGHT public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"GAMEPAD_BUTTON_RIGHT_FACE_RIGHT"</e></m>
		</meta>
	</GAMEPAD_BUTTON_RIGHT_FACE_RIGHT>
	<GAMEPAD_BUTTON_RIGHT_FACE_DOWN public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"GAMEPAD_BUTTON_RIGHT_FACE_DOWN"</e></m>
		</meta>
	</GAMEPAD_BUTTON_RIGHT_FACE_DOWN>
	<GAMEPAD_BUTTON_RIGHT_FACE_LEFT public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"GAMEPAD_BUTTON_RIGHT_FACE_LEFT"</e></m>
		</meta>
	</GAMEPAD_BUTTON_RIGHT_FACE_LEFT>
	<GAMEPAD_BUTTON_LEFT_TRIGGER_1 public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"GAMEPAD_BUTTON_LEFT_TRIGGER_1"</e></m>
		</meta>
	</GAMEPAD_BUTTON_LEFT_TRIGGER_1>
	<GAMEPAD_BUTTON_LEFT_TRIGGER_2 public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"GAMEPAD_BUTTON_LEFT_TRIGGER_2"</e></m>
		</meta>
	</GAMEPAD_BUTTON_LEFT_TRIGGER_2>
	<GAMEPAD_BUTTON_RIGHT_TRIGGER_1 public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"GAMEPAD_BUTTON_RIGHT_TRIGGER_1"</e></m>
		</meta>
	</GAMEPAD_BUTTON_RIGHT_TRIGGER_1>
	<GAMEPAD_BUTTON_RIGHT_TRIGGER_2 public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"GAMEPAD_BUTTON_RIGHT_TRIGGER_2"</e></m>
		</meta>
	</GAMEPAD_BUTTON_RIGHT_TRIGGER_2>
	<GAMEPAD_BUTTON_MIDDLE_LEFT public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"GAMEPAD_BUTTON_MIDDLE_LEFT"</e></m>
		</meta>
	</GAMEPAD_BUTTON_MIDDLE_LEFT>
	<GAMEPAD_BUTTON_MIDDLE public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"GAMEPAD_BUTTON_MIDDLE"</e></m>
		</meta>
	</GAMEPAD_BUTTON_MIDDLE>
	<GAMEPAD_BUTTON_MIDDLE_RIGHT public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"GAMEPAD_BUTTON_MIDDLE_RIGHT"</e></m>
		</meta>
	</GAMEPAD_BUTTON_MIDDLE_RIGHT>
	<GAMEPAD_BUTTON_LEFT_THUMB public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"GAMEPAD_BUTTON_LEFT_THUMB"</e></m>
		</meta>
	</GAMEPAD_BUTTON_LEFT_THUMB>
	<GAMEPAD_BUTTON_RIGHT_THUMB public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"GAMEPAD_BUTTON_RIGHT_THUMB"</e></m>
		</meta>
	</GAMEPAD_BUTTON_RIGHT_THUMB>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="_Rl.GamepadButton_Impl_" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" private="1" module="Rl" extern="1" final="1">
		<GAMEPAD_BUTTON_UNKNOWN public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"GAMEPAD_BUTTON_UNKNOWN"</e></m>
			</meta>
		</GAMEPAD_BUTTON_UNKNOWN>
		<GAMEPAD_BUTTON_LEFT_FACE_UP public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"GAMEPAD_BUTTON_LEFT_FACE_UP"</e></m>
			</meta>
		</GAMEPAD_BUTTON_LEFT_FACE_UP>
		<GAMEPAD_BUTTON_LEFT_FACE_RIGHT public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"GAMEPAD_BUTTON_LEFT_FACE_RIGHT"</e></m>
			</meta>
		</GAMEPAD_BUTTON_LEFT_FACE_RIGHT>
		<GAMEPAD_BUTTON_LEFT_FACE_DOWN public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"GAMEPAD_BUTTON_LEFT_FACE_DOWN"</e></m>
			</meta>
		</GAMEPAD_BUTTON_LEFT_FACE_DOWN>
		<GAMEPAD_BUTTON_LEFT_FACE_LEFT public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"GAMEPAD_BUTTON_LEFT_FACE_LEFT"</e></m>
			</meta>
		</GAMEPAD_BUTTON_LEFT_FACE_LEFT>
		<GAMEPAD_BUTTON_RIGHT_FACE_UP public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"GAMEPAD_BUTTON_RIGHT_FACE_UP"</e></m>
			</meta>
		</GAMEPAD_BUTTON_RIGHT_FACE_UP>
		<GAMEPAD_BUTTON_RIGHT_FACE_RIGHT public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"GAMEPAD_BUTTON_RIGHT_FACE_RIGHT"</e></m>
			</meta>
		</GAMEPAD_BUTTON_RIGHT_FACE_RIGHT>
		<GAMEPAD_BUTTON_RIGHT_FACE_DOWN public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"GAMEPAD_BUTTON_RIGHT_FACE_DOWN"</e></m>
			</meta>
		</GAMEPAD_BUTTON_RIGHT_FACE_DOWN>
		<GAMEPAD_BUTTON_RIGHT_FACE_LEFT public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"GAMEPAD_BUTTON_RIGHT_FACE_LEFT"</e></m>
			</meta>
		</GAMEPAD_BUTTON_RIGHT_FACE_LEFT>
		<GAMEPAD_BUTTON_LEFT_TRIGGER_1 public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"GAMEPAD_BUTTON_LEFT_TRIGGER_1"</e></m>
			</meta>
		</GAMEPAD_BUTTON_LEFT_TRIGGER_1>
		<GAMEPAD_BUTTON_LEFT_TRIGGER_2 public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"GAMEPAD_BUTTON_LEFT_TRIGGER_2"</e></m>
			</meta>
		</GAMEPAD_BUTTON_LEFT_TRIGGER_2>
		<GAMEPAD_BUTTON_RIGHT_TRIGGER_1 public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"GAMEPAD_BUTTON_RIGHT_TRIGGER_1"</e></m>
			</meta>
		</GAMEPAD_BUTTON_RIGHT_TRIGGER_1>
		<GAMEPAD_BUTTON_RIGHT_TRIGGER_2 public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"GAMEPAD_BUTTON_RIGHT_TRIGGER_2"</e></m>
			</meta>
		</GAMEPAD_BUTTON_RIGHT_TRIGGER_2>
		<GAMEPAD_BUTTON_MIDDLE_LEFT public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"GAMEPAD_BUTTON_MIDDLE_LEFT"</e></m>
			</meta>
		</GAMEPAD_BUTTON_MIDDLE_LEFT>
		<GAMEPAD_BUTTON_MIDDLE public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"GAMEPAD_BUTTON_MIDDLE"</e></m>
			</meta>
		</GAMEPAD_BUTTON_MIDDLE>
		<GAMEPAD_BUTTON_MIDDLE_RIGHT public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"GAMEPAD_BUTTON_MIDDLE_RIGHT"</e></m>
			</meta>
		</GAMEPAD_BUTTON_MIDDLE_RIGHT>
		<GAMEPAD_BUTTON_LEFT_THUMB public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"GAMEPAD_BUTTON_LEFT_THUMB"</e></m>
			</meta>
		</GAMEPAD_BUTTON_LEFT_THUMB>
		<GAMEPAD_BUTTON_RIGHT_THUMB public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"GAMEPAD_BUTTON_RIGHT_THUMB"</e></m>
			</meta>
		</GAMEPAD_BUTTON_RIGHT_THUMB>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="GamepadAxis" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl">
		<this><x path="UInt"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":include"><e>"raylib.h"</e></m>
		</meta>
		<impl><class path="_Rl.GamepadAxis_Impl_" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" private="1" module="Rl" extern="1" final="1">
	<GAMEPAD_AXIS_LEFT_X public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"GAMEPAD_AXIS_LEFT_X"</e></m>
		</meta>
	</GAMEPAD_AXIS_LEFT_X>
	<GAMEPAD_AXIS_LEFT_Y public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"GAMEPAD_AXIS_LEFT_Y"</e></m>
		</meta>
	</GAMEPAD_AXIS_LEFT_Y>
	<GAMEPAD_AXIS_RIGHT_X public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"GAMEPAD_AXIS_RIGHT_X"</e></m>
		</meta>
	</GAMEPAD_AXIS_RIGHT_X>
	<GAMEPAD_AXIS_RIGHT_Y public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"GAMEPAD_AXIS_RIGHT_Y"</e></m>
		</meta>
	</GAMEPAD_AXIS_RIGHT_Y>
	<GAMEPAD_AXIS_LEFT_TRIGGER public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"GAMEPAD_AXIS_LEFT_TRIGGER"</e></m>
		</meta>
	</GAMEPAD_AXIS_LEFT_TRIGGER>
	<GAMEPAD_AXIS_RIGHT_TRIGGER public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"GAMEPAD_AXIS_RIGHT_TRIGGER"</e></m>
		</meta>
	</GAMEPAD_AXIS_RIGHT_TRIGGER>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="_Rl.GamepadAxis_Impl_" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" private="1" module="Rl" extern="1" final="1">
		<GAMEPAD_AXIS_LEFT_X public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"GAMEPAD_AXIS_LEFT_X"</e></m>
			</meta>
		</GAMEPAD_AXIS_LEFT_X>
		<GAMEPAD_AXIS_LEFT_Y public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"GAMEPAD_AXIS_LEFT_Y"</e></m>
			</meta>
		</GAMEPAD_AXIS_LEFT_Y>
		<GAMEPAD_AXIS_RIGHT_X public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"GAMEPAD_AXIS_RIGHT_X"</e></m>
			</meta>
		</GAMEPAD_AXIS_RIGHT_X>
		<GAMEPAD_AXIS_RIGHT_Y public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"GAMEPAD_AXIS_RIGHT_Y"</e></m>
			</meta>
		</GAMEPAD_AXIS_RIGHT_Y>
		<GAMEPAD_AXIS_LEFT_TRIGGER public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"GAMEPAD_AXIS_LEFT_TRIGGER"</e></m>
			</meta>
		</GAMEPAD_AXIS_LEFT_TRIGGER>
		<GAMEPAD_AXIS_RIGHT_TRIGGER public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"GAMEPAD_AXIS_RIGHT_TRIGGER"</e></m>
			</meta>
		</GAMEPAD_AXIS_RIGHT_TRIGGER>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="MaterialMapIndex" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl">
		<this><x path="UInt"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":include"><e>"raylib.h"</e></m>
		</meta>
		<impl><class path="_Rl.MaterialMapIndex_Impl_" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" private="1" module="Rl" extern="1" final="1">
	<MATERIAL_MAP_ALBEDO public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"MATERIAL_MAP_ALBEDO"</e></m>
		</meta>
	</MATERIAL_MAP_ALBEDO>
	<MATERIAL_MAP_METALNESS public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"MATERIAL_MAP_METALNESS"</e></m>
		</meta>
	</MATERIAL_MAP_METALNESS>
	<MATERIAL_MAP_NORMAL public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"MATERIAL_MAP_NORMAL"</e></m>
		</meta>
	</MATERIAL_MAP_NORMAL>
	<MATERIAL_MAP_ROUGHNESS public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"MATERIAL_MAP_ROUGHNESS"</e></m>
		</meta>
	</MATERIAL_MAP_ROUGHNESS>
	<MATERIAL_MAP_OCCLUSION public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"MATERIAL_MAP_OCCLUSION"</e></m>
		</meta>
	</MATERIAL_MAP_OCCLUSION>
	<MATERIAL_MAP_EMISSION public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"MATERIAL_MAP_EMISSION"</e></m>
		</meta>
	</MATERIAL_MAP_EMISSION>
	<MATERIAL_MAP_HEIGHT public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"MATERIAL_MAP_HEIGHT"</e></m>
		</meta>
	</MATERIAL_MAP_HEIGHT>
	<MATERIAL_MAP_CUBEMAP public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"MATERIAL_MAP_CUBEMAP"</e></m>
		</meta>
	</MATERIAL_MAP_CUBEMAP>
	<MATERIAL_MAP_IRRADIANCE public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"MATERIAL_MAP_IRRADIANCE"</e></m>
		</meta>
	</MATERIAL_MAP_IRRADIANCE>
	<MATERIAL_MAP_PREFILTER public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"MATERIAL_MAP_PREFILTER"</e></m>
		</meta>
	</MATERIAL_MAP_PREFILTER>
	<MATERIAL_MAP_BRDF public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"MATERIAL_MAP_BRDF"</e></m>
		</meta>
	</MATERIAL_MAP_BRDF>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="_Rl.MaterialMapIndex_Impl_" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" private="1" module="Rl" extern="1" final="1">
		<MATERIAL_MAP_ALBEDO public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"MATERIAL_MAP_ALBEDO"</e></m>
			</meta>
		</MATERIAL_MAP_ALBEDO>
		<MATERIAL_MAP_METALNESS public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"MATERIAL_MAP_METALNESS"</e></m>
			</meta>
		</MATERIAL_MAP_METALNESS>
		<MATERIAL_MAP_NORMAL public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"MATERIAL_MAP_NORMAL"</e></m>
			</meta>
		</MATERIAL_MAP_NORMAL>
		<MATERIAL_MAP_ROUGHNESS public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"MATERIAL_MAP_ROUGHNESS"</e></m>
			</meta>
		</MATERIAL_MAP_ROUGHNESS>
		<MATERIAL_MAP_OCCLUSION public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"MATERIAL_MAP_OCCLUSION"</e></m>
			</meta>
		</MATERIAL_MAP_OCCLUSION>
		<MATERIAL_MAP_EMISSION public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"MATERIAL_MAP_EMISSION"</e></m>
			</meta>
		</MATERIAL_MAP_EMISSION>
		<MATERIAL_MAP_HEIGHT public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"MATERIAL_MAP_HEIGHT"</e></m>
			</meta>
		</MATERIAL_MAP_HEIGHT>
		<MATERIAL_MAP_CUBEMAP public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"MATERIAL_MAP_CUBEMAP"</e></m>
			</meta>
		</MATERIAL_MAP_CUBEMAP>
		<MATERIAL_MAP_IRRADIANCE public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"MATERIAL_MAP_IRRADIANCE"</e></m>
			</meta>
		</MATERIAL_MAP_IRRADIANCE>
		<MATERIAL_MAP_PREFILTER public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"MATERIAL_MAP_PREFILTER"</e></m>
			</meta>
		</MATERIAL_MAP_PREFILTER>
		<MATERIAL_MAP_BRDF public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"MATERIAL_MAP_BRDF"</e></m>
			</meta>
		</MATERIAL_MAP_BRDF>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="ShaderLocationIndex" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl">
		<this><x path="UInt"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":include"><e>"raylib.h"</e></m>
		</meta>
		<impl><class path="_Rl.ShaderLocationIndex_Impl_" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" private="1" module="Rl" extern="1" final="1">
	<SHADER_LOC_VERTEX_POSITION public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"SHADER_LOC_VERTEX_POSITION"</e></m>
		</meta>
	</SHADER_LOC_VERTEX_POSITION>
	<SHADER_LOC_VERTEX_TEXCOORD01 public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"SHADER_LOC_VERTEX_TEXCOORD01"</e></m>
		</meta>
	</SHADER_LOC_VERTEX_TEXCOORD01>
	<SHADER_LOC_VERTEX_TEXCOORD02 public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"SHADER_LOC_VERTEX_TEXCOORD02"</e></m>
		</meta>
	</SHADER_LOC_VERTEX_TEXCOORD02>
	<SHADER_LOC_VERTEX_NORMAL public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"SHADER_LOC_VERTEX_NORMAL"</e></m>
		</meta>
	</SHADER_LOC_VERTEX_NORMAL>
	<SHADER_LOC_VERTEX_TANGENT public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"SHADER_LOC_VERTEX_TANGENT"</e></m>
		</meta>
	</SHADER_LOC_VERTEX_TANGENT>
	<SHADER_LOC_VERTEX_COLOR public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"SHADER_LOC_VERTEX_COLOR"</e></m>
		</meta>
	</SHADER_LOC_VERTEX_COLOR>
	<SHADER_LOC_MATRIX_MVP public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"SHADER_LOC_MATRIX_MVP"</e></m>
		</meta>
	</SHADER_LOC_MATRIX_MVP>
	<SHADER_LOC_MATRIX_VIEW public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"SHADER_LOC_MATRIX_VIEW"</e></m>
		</meta>
	</SHADER_LOC_MATRIX_VIEW>
	<SHADER_LOC_MATRIX_PROJECTION public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"SHADER_LOC_MATRIX_PROJECTION"</e></m>
		</meta>
	</SHADER_LOC_MATRIX_PROJECTION>
	<SHADER_LOC_MATRIX_MODEL public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"SHADER_LOC_MATRIX_MODEL"</e></m>
		</meta>
	</SHADER_LOC_MATRIX_MODEL>
	<SHADER_LOC_MATRIX_NORMAL public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"SHADER_LOC_MATRIX_NORMAL"</e></m>
		</meta>
	</SHADER_LOC_MATRIX_NORMAL>
	<SHADER_LOC_VECTOR_VIEW public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"SHADER_LOC_VECTOR_VIEW"</e></m>
		</meta>
	</SHADER_LOC_VECTOR_VIEW>
	<SHADER_LOC_COLOR_DIFFUSE public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"SHADER_LOC_COLOR_DIFFUSE"</e></m>
		</meta>
	</SHADER_LOC_COLOR_DIFFUSE>
	<SHADER_LOC_COLOR_SPECULAR public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"SHADER_LOC_COLOR_SPECULAR"</e></m>
		</meta>
	</SHADER_LOC_COLOR_SPECULAR>
	<SHADER_LOC_COLOR_AMBIENT public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"SHADER_LOC_COLOR_AMBIENT"</e></m>
		</meta>
	</SHADER_LOC_COLOR_AMBIENT>
	<SHADER_LOC_MAP_ALBEDO public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"SHADER_LOC_MAP_ALBEDO"</e></m>
		</meta>
	</SHADER_LOC_MAP_ALBEDO>
	<SHADER_LOC_MAP_METALNESS public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"SHADER_LOC_MAP_METALNESS"</e></m>
		</meta>
	</SHADER_LOC_MAP_METALNESS>
	<SHADER_LOC_MAP_NORMAL public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"SHADER_LOC_MAP_NORMAL"</e></m>
		</meta>
	</SHADER_LOC_MAP_NORMAL>
	<SHADER_LOC_MAP_ROUGHNESS public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"SHADER_LOC_MAP_ROUGHNESS"</e></m>
		</meta>
	</SHADER_LOC_MAP_ROUGHNESS>
	<SHADER_LOC_MAP_OCCLUSION public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"SHADER_LOC_MAP_OCCLUSION"</e></m>
		</meta>
	</SHADER_LOC_MAP_OCCLUSION>
	<SHADER_LOC_MAP_EMISSION public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"SHADER_LOC_MAP_EMISSION"</e></m>
		</meta>
	</SHADER_LOC_MAP_EMISSION>
	<SHADER_LOC_MAP_HEIGHT public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"SHADER_LOC_MAP_HEIGHT"</e></m>
		</meta>
	</SHADER_LOC_MAP_HEIGHT>
	<SHADER_LOC_MAP_CUBEMAP public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"SHADER_LOC_MAP_CUBEMAP"</e></m>
		</meta>
	</SHADER_LOC_MAP_CUBEMAP>
	<SHADER_LOC_MAP_IRRADIANCE public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"SHADER_LOC_MAP_IRRADIANCE"</e></m>
		</meta>
	</SHADER_LOC_MAP_IRRADIANCE>
	<SHADER_LOC_MAP_PREFILTER public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"SHADER_LOC_MAP_PREFILTER"</e></m>
		</meta>
	</SHADER_LOC_MAP_PREFILTER>
	<SHADER_LOC_MAP_BRDF public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"SHADER_LOC_MAP_BRDF"</e></m>
		</meta>
	</SHADER_LOC_MAP_BRDF>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="_Rl.ShaderLocationIndex_Impl_" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" private="1" module="Rl" extern="1" final="1">
		<SHADER_LOC_VERTEX_POSITION public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"SHADER_LOC_VERTEX_POSITION"</e></m>
			</meta>
		</SHADER_LOC_VERTEX_POSITION>
		<SHADER_LOC_VERTEX_TEXCOORD01 public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"SHADER_LOC_VERTEX_TEXCOORD01"</e></m>
			</meta>
		</SHADER_LOC_VERTEX_TEXCOORD01>
		<SHADER_LOC_VERTEX_TEXCOORD02 public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"SHADER_LOC_VERTEX_TEXCOORD02"</e></m>
			</meta>
		</SHADER_LOC_VERTEX_TEXCOORD02>
		<SHADER_LOC_VERTEX_NORMAL public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"SHADER_LOC_VERTEX_NORMAL"</e></m>
			</meta>
		</SHADER_LOC_VERTEX_NORMAL>
		<SHADER_LOC_VERTEX_TANGENT public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"SHADER_LOC_VERTEX_TANGENT"</e></m>
			</meta>
		</SHADER_LOC_VERTEX_TANGENT>
		<SHADER_LOC_VERTEX_COLOR public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"SHADER_LOC_VERTEX_COLOR"</e></m>
			</meta>
		</SHADER_LOC_VERTEX_COLOR>
		<SHADER_LOC_MATRIX_MVP public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"SHADER_LOC_MATRIX_MVP"</e></m>
			</meta>
		</SHADER_LOC_MATRIX_MVP>
		<SHADER_LOC_MATRIX_VIEW public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"SHADER_LOC_MATRIX_VIEW"</e></m>
			</meta>
		</SHADER_LOC_MATRIX_VIEW>
		<SHADER_LOC_MATRIX_PROJECTION public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"SHADER_LOC_MATRIX_PROJECTION"</e></m>
			</meta>
		</SHADER_LOC_MATRIX_PROJECTION>
		<SHADER_LOC_MATRIX_MODEL public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"SHADER_LOC_MATRIX_MODEL"</e></m>
			</meta>
		</SHADER_LOC_MATRIX_MODEL>
		<SHADER_LOC_MATRIX_NORMAL public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"SHADER_LOC_MATRIX_NORMAL"</e></m>
			</meta>
		</SHADER_LOC_MATRIX_NORMAL>
		<SHADER_LOC_VECTOR_VIEW public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"SHADER_LOC_VECTOR_VIEW"</e></m>
			</meta>
		</SHADER_LOC_VECTOR_VIEW>
		<SHADER_LOC_COLOR_DIFFUSE public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"SHADER_LOC_COLOR_DIFFUSE"</e></m>
			</meta>
		</SHADER_LOC_COLOR_DIFFUSE>
		<SHADER_LOC_COLOR_SPECULAR public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"SHADER_LOC_COLOR_SPECULAR"</e></m>
			</meta>
		</SHADER_LOC_COLOR_SPECULAR>
		<SHADER_LOC_COLOR_AMBIENT public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"SHADER_LOC_COLOR_AMBIENT"</e></m>
			</meta>
		</SHADER_LOC_COLOR_AMBIENT>
		<SHADER_LOC_MAP_ALBEDO public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"SHADER_LOC_MAP_ALBEDO"</e></m>
			</meta>
		</SHADER_LOC_MAP_ALBEDO>
		<SHADER_LOC_MAP_METALNESS public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"SHADER_LOC_MAP_METALNESS"</e></m>
			</meta>
		</SHADER_LOC_MAP_METALNESS>
		<SHADER_LOC_MAP_NORMAL public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"SHADER_LOC_MAP_NORMAL"</e></m>
			</meta>
		</SHADER_LOC_MAP_NORMAL>
		<SHADER_LOC_MAP_ROUGHNESS public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"SHADER_LOC_MAP_ROUGHNESS"</e></m>
			</meta>
		</SHADER_LOC_MAP_ROUGHNESS>
		<SHADER_LOC_MAP_OCCLUSION public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"SHADER_LOC_MAP_OCCLUSION"</e></m>
			</meta>
		</SHADER_LOC_MAP_OCCLUSION>
		<SHADER_LOC_MAP_EMISSION public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"SHADER_LOC_MAP_EMISSION"</e></m>
			</meta>
		</SHADER_LOC_MAP_EMISSION>
		<SHADER_LOC_MAP_HEIGHT public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"SHADER_LOC_MAP_HEIGHT"</e></m>
			</meta>
		</SHADER_LOC_MAP_HEIGHT>
		<SHADER_LOC_MAP_CUBEMAP public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"SHADER_LOC_MAP_CUBEMAP"</e></m>
			</meta>
		</SHADER_LOC_MAP_CUBEMAP>
		<SHADER_LOC_MAP_IRRADIANCE public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"SHADER_LOC_MAP_IRRADIANCE"</e></m>
			</meta>
		</SHADER_LOC_MAP_IRRADIANCE>
		<SHADER_LOC_MAP_PREFILTER public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"SHADER_LOC_MAP_PREFILTER"</e></m>
			</meta>
		</SHADER_LOC_MAP_PREFILTER>
		<SHADER_LOC_MAP_BRDF public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"SHADER_LOC_MAP_BRDF"</e></m>
			</meta>
		</SHADER_LOC_MAP_BRDF>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="ShaderUniformDataType" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl">
		<this><x path="UInt"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":include"><e>"raylib.h"</e></m>
		</meta>
		<impl><class path="_Rl.ShaderUniformDataType_Impl_" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" private="1" module="Rl" extern="1" final="1">
	<SHADER_UNIFORM_FLOAT public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"SHADER_UNIFORM_FLOAT"</e></m>
		</meta>
	</SHADER_UNIFORM_FLOAT>
	<SHADER_UNIFORM_VEC2 public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"SHADER_UNIFORM_VEC2"</e></m>
		</meta>
	</SHADER_UNIFORM_VEC2>
	<SHADER_UNIFORM_VEC3 public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"SHADER_UNIFORM_VEC3"</e></m>
		</meta>
	</SHADER_UNIFORM_VEC3>
	<SHADER_UNIFORM_VEC4 public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"SHADER_UNIFORM_VEC4"</e></m>
		</meta>
	</SHADER_UNIFORM_VEC4>
	<SHADER_UNIFORM_INT public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"SHADER_UNIFORM_INT"</e></m>
		</meta>
	</SHADER_UNIFORM_INT>
	<SHADER_UNIFORM_IVEC2 public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"SHADER_UNIFORM_IVEC2"</e></m>
		</meta>
	</SHADER_UNIFORM_IVEC2>
	<SHADER_UNIFORM_IVEC3 public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"SHADER_UNIFORM_IVEC3"</e></m>
		</meta>
	</SHADER_UNIFORM_IVEC3>
	<SHADER_UNIFORM_IVEC4 public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"SHADER_UNIFORM_IVEC4"</e></m>
		</meta>
	</SHADER_UNIFORM_IVEC4>
	<SHADER_UNIFORM_SAMPLER2D public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"SHADER_UNIFORM_SAMPLER2D"</e></m>
		</meta>
	</SHADER_UNIFORM_SAMPLER2D>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="_Rl.ShaderUniformDataType_Impl_" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" private="1" module="Rl" extern="1" final="1">
		<SHADER_UNIFORM_FLOAT public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"SHADER_UNIFORM_FLOAT"</e></m>
			</meta>
		</SHADER_UNIFORM_FLOAT>
		<SHADER_UNIFORM_VEC2 public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"SHADER_UNIFORM_VEC2"</e></m>
			</meta>
		</SHADER_UNIFORM_VEC2>
		<SHADER_UNIFORM_VEC3 public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"SHADER_UNIFORM_VEC3"</e></m>
			</meta>
		</SHADER_UNIFORM_VEC3>
		<SHADER_UNIFORM_VEC4 public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"SHADER_UNIFORM_VEC4"</e></m>
			</meta>
		</SHADER_UNIFORM_VEC4>
		<SHADER_UNIFORM_INT public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"SHADER_UNIFORM_INT"</e></m>
			</meta>
		</SHADER_UNIFORM_INT>
		<SHADER_UNIFORM_IVEC2 public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"SHADER_UNIFORM_IVEC2"</e></m>
			</meta>
		</SHADER_UNIFORM_IVEC2>
		<SHADER_UNIFORM_IVEC3 public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"SHADER_UNIFORM_IVEC3"</e></m>
			</meta>
		</SHADER_UNIFORM_IVEC3>
		<SHADER_UNIFORM_IVEC4 public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"SHADER_UNIFORM_IVEC4"</e></m>
			</meta>
		</SHADER_UNIFORM_IVEC4>
		<SHADER_UNIFORM_SAMPLER2D public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"SHADER_UNIFORM_SAMPLER2D"</e></m>
			</meta>
		</SHADER_UNIFORM_SAMPLER2D>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="ShaderAttributeDataType" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl">
		<this><x path="UInt"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":include"><e>"raylib.h"</e></m>
		</meta>
		<impl><class path="_Rl.ShaderAttributeDataType_Impl_" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" private="1" module="Rl" extern="1" final="1">
	<SHADER_ATTRIB_FLOAT public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"SHADER_ATTRIB_FLOAT"</e></m>
		</meta>
	</SHADER_ATTRIB_FLOAT>
	<SHADER_ATTRIB_VEC2 public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"SHADER_ATTRIB_VEC2"</e></m>
		</meta>
	</SHADER_ATTRIB_VEC2>
	<SHADER_ATTRIB_VEC3 public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"SHADER_ATTRIB_VEC3"</e></m>
		</meta>
	</SHADER_ATTRIB_VEC3>
	<SHADER_ATTRIB_VEC4 public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"SHADER_ATTRIB_VEC4"</e></m>
		</meta>
	</SHADER_ATTRIB_VEC4>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="_Rl.ShaderAttributeDataType_Impl_" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" private="1" module="Rl" extern="1" final="1">
		<SHADER_ATTRIB_FLOAT public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"SHADER_ATTRIB_FLOAT"</e></m>
			</meta>
		</SHADER_ATTRIB_FLOAT>
		<SHADER_ATTRIB_VEC2 public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"SHADER_ATTRIB_VEC2"</e></m>
			</meta>
		</SHADER_ATTRIB_VEC2>
		<SHADER_ATTRIB_VEC3 public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"SHADER_ATTRIB_VEC3"</e></m>
			</meta>
		</SHADER_ATTRIB_VEC3>
		<SHADER_ATTRIB_VEC4 public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"SHADER_ATTRIB_VEC4"</e></m>
			</meta>
		</SHADER_ATTRIB_VEC4>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="PixelFormat" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl">
		<this><x path="UInt"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":include"><e>"raylib.h"</e></m>
		</meta>
		<impl><class path="_Rl.PixelFormat_Impl_" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" private="1" module="Rl" extern="1" final="1">
	<UNCOMPRESSED_GRAYSCALE public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"PIXELFORMAT_UNCOMPRESSED_GRAYSCALE"</e></m>
		</meta>
	</UNCOMPRESSED_GRAYSCALE>
	<UNCOMPRESSED_GRAY_ALPHA public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA"</e></m>
		</meta>
	</UNCOMPRESSED_GRAY_ALPHA>
	<UNCOMPRESSED_R5G6B5 public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"PIXELFORMAT_UNCOMPRESSED_R5G6B5"</e></m>
		</meta>
	</UNCOMPRESSED_R5G6B5>
	<UNCOMPRESSED_R8G8B8 public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"PIXELFORMAT_UNCOMPRESSED_R8G8B8"</e></m>
		</meta>
	</UNCOMPRESSED_R8G8B8>
	<UNCOMPRESSED_R5G5B5A1 public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"PIXELFORMAT_UNCOMPRESSED_R5G5B5A1"</e></m>
		</meta>
	</UNCOMPRESSED_R5G5B5A1>
	<UNCOMPRESSED_R4G4B4A4 public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"PIXELFORMAT_UNCOMPRESSED_R4G4B4A4"</e></m>
		</meta>
	</UNCOMPRESSED_R4G4B4A4>
	<UNCOMPRESSED_R8G8B8A8 public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"PIXELFORMAT_UNCOMPRESSED_R8G8B8A8"</e></m>
		</meta>
	</UNCOMPRESSED_R8G8B8A8>
	<UNCOMPRESSED_R32 public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"PIXELFORMAT_UNCOMPRESSED_R32"</e></m>
		</meta>
	</UNCOMPRESSED_R32>
	<UNCOMPRESSED_R32G32B32 public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"PIXELFORMAT_UNCOMPRESSED_R32G32B32"</e></m>
		</meta>
	</UNCOMPRESSED_R32G32B32>
	<UNCOMPRESSED_R32G32B32A32 public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"PIXELFORMAT_UNCOMPRESSED_R32G32B32A32"</e></m>
		</meta>
	</UNCOMPRESSED_R32G32B32A32>
	<COMPRESSED_DXT1_RGB public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"PIXELFORMAT_COMPRESSED_DXT1_RGB"</e></m>
		</meta>
	</COMPRESSED_DXT1_RGB>
	<COMPRESSED_DXT1_RGBA public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"PIXELFORMAT_COMPRESSED_DXT1_RGBA"</e></m>
		</meta>
	</COMPRESSED_DXT1_RGBA>
	<COMPRESSED_DXT3_RGBA public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"PIXELFORMAT_COMPRESSED_DXT3_RGBA"</e></m>
		</meta>
	</COMPRESSED_DXT3_RGBA>
	<COMPRESSED_DXT5_RGBA public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"PIXELFORMAT_COMPRESSED_DXT5_RGBA"</e></m>
		</meta>
	</COMPRESSED_DXT5_RGBA>
	<COMPRESSED_ETC1_RGB public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"PIXELFORMAT_COMPRESSED_ETC1_RGB"</e></m>
		</meta>
	</COMPRESSED_ETC1_RGB>
	<COMPRESSED_ETC2_RGB public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"PIXELFORMAT_COMPRESSED_ETC2_RGB"</e></m>
		</meta>
	</COMPRESSED_ETC2_RGB>
	<COMPRESSED_ETC2_EAC_RGBA public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA"</e></m>
		</meta>
	</COMPRESSED_ETC2_EAC_RGBA>
	<COMPRESSED_PVRT_RGB public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"PIXELFORMAT_COMPRESSED_PVRT_RGB"</e></m>
		</meta>
	</COMPRESSED_PVRT_RGB>
	<COMPRESSED_PVRT_RGBA public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"PIXELFORMAT_COMPRESSED_PVRT_RGBA"</e></m>
		</meta>
	</COMPRESSED_PVRT_RGBA>
	<COMPRESSED_ASTC_4x4_RGBA public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA"</e></m>
		</meta>
	</COMPRESSED_ASTC_4x4_RGBA>
	<COMPRESSED_ASTC_8x8_RGBA public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA"</e></m>
		</meta>
	</COMPRESSED_ASTC_8x8_RGBA>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="_Rl.PixelFormat_Impl_" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" private="1" module="Rl" extern="1" final="1">
		<UNCOMPRESSED_GRAYSCALE public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"PIXELFORMAT_UNCOMPRESSED_GRAYSCALE"</e></m>
			</meta>
		</UNCOMPRESSED_GRAYSCALE>
		<UNCOMPRESSED_GRAY_ALPHA public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA"</e></m>
			</meta>
		</UNCOMPRESSED_GRAY_ALPHA>
		<UNCOMPRESSED_R5G6B5 public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"PIXELFORMAT_UNCOMPRESSED_R5G6B5"</e></m>
			</meta>
		</UNCOMPRESSED_R5G6B5>
		<UNCOMPRESSED_R8G8B8 public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"PIXELFORMAT_UNCOMPRESSED_R8G8B8"</e></m>
			</meta>
		</UNCOMPRESSED_R8G8B8>
		<UNCOMPRESSED_R5G5B5A1 public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"PIXELFORMAT_UNCOMPRESSED_R5G5B5A1"</e></m>
			</meta>
		</UNCOMPRESSED_R5G5B5A1>
		<UNCOMPRESSED_R4G4B4A4 public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"PIXELFORMAT_UNCOMPRESSED_R4G4B4A4"</e></m>
			</meta>
		</UNCOMPRESSED_R4G4B4A4>
		<UNCOMPRESSED_R8G8B8A8 public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"PIXELFORMAT_UNCOMPRESSED_R8G8B8A8"</e></m>
			</meta>
		</UNCOMPRESSED_R8G8B8A8>
		<UNCOMPRESSED_R32 public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"PIXELFORMAT_UNCOMPRESSED_R32"</e></m>
			</meta>
		</UNCOMPRESSED_R32>
		<UNCOMPRESSED_R32G32B32 public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"PIXELFORMAT_UNCOMPRESSED_R32G32B32"</e></m>
			</meta>
		</UNCOMPRESSED_R32G32B32>
		<UNCOMPRESSED_R32G32B32A32 public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"PIXELFORMAT_UNCOMPRESSED_R32G32B32A32"</e></m>
			</meta>
		</UNCOMPRESSED_R32G32B32A32>
		<COMPRESSED_DXT1_RGB public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"PIXELFORMAT_COMPRESSED_DXT1_RGB"</e></m>
			</meta>
		</COMPRESSED_DXT1_RGB>
		<COMPRESSED_DXT1_RGBA public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"PIXELFORMAT_COMPRESSED_DXT1_RGBA"</e></m>
			</meta>
		</COMPRESSED_DXT1_RGBA>
		<COMPRESSED_DXT3_RGBA public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"PIXELFORMAT_COMPRESSED_DXT3_RGBA"</e></m>
			</meta>
		</COMPRESSED_DXT3_RGBA>
		<COMPRESSED_DXT5_RGBA public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"PIXELFORMAT_COMPRESSED_DXT5_RGBA"</e></m>
			</meta>
		</COMPRESSED_DXT5_RGBA>
		<COMPRESSED_ETC1_RGB public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"PIXELFORMAT_COMPRESSED_ETC1_RGB"</e></m>
			</meta>
		</COMPRESSED_ETC1_RGB>
		<COMPRESSED_ETC2_RGB public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"PIXELFORMAT_COMPRESSED_ETC2_RGB"</e></m>
			</meta>
		</COMPRESSED_ETC2_RGB>
		<COMPRESSED_ETC2_EAC_RGBA public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA"</e></m>
			</meta>
		</COMPRESSED_ETC2_EAC_RGBA>
		<COMPRESSED_PVRT_RGB public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"PIXELFORMAT_COMPRESSED_PVRT_RGB"</e></m>
			</meta>
		</COMPRESSED_PVRT_RGB>
		<COMPRESSED_PVRT_RGBA public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"PIXELFORMAT_COMPRESSED_PVRT_RGBA"</e></m>
			</meta>
		</COMPRESSED_PVRT_RGBA>
		<COMPRESSED_ASTC_4x4_RGBA public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA"</e></m>
			</meta>
		</COMPRESSED_ASTC_4x4_RGBA>
		<COMPRESSED_ASTC_8x8_RGBA public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA"</e></m>
			</meta>
		</COMPRESSED_ASTC_8x8_RGBA>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="TextureFilter" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl">
		<this><x path="UInt"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":include"><e>"raylib.h"</e></m>
		</meta>
		<impl><class path="_Rl.TextureFilter_Impl_" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" private="1" module="Rl" extern="1" final="1">
	<TEXTURE_FILTER_POINT public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"TEXTURE_FILTER_POINT"</e></m>
		</meta>
	</TEXTURE_FILTER_POINT>
	<TEXTURE_FILTER_BILINEAR public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"TEXTURE_FILTER_BILINEAR"</e></m>
		</meta>
	</TEXTURE_FILTER_BILINEAR>
	<TEXTURE_FILTER_TRILINEAR public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"TEXTURE_FILTER_TRILINEAR"</e></m>
		</meta>
	</TEXTURE_FILTER_TRILINEAR>
	<TEXTURE_FILTER_ANISOTROPIC_4X public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"TEXTURE_FILTER_ANISOTROPIC_4X"</e></m>
		</meta>
	</TEXTURE_FILTER_ANISOTROPIC_4X>
	<TEXTURE_FILTER_ANISOTROPIC_8X public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"TEXTURE_FILTER_ANISOTROPIC_8X"</e></m>
		</meta>
	</TEXTURE_FILTER_ANISOTROPIC_8X>
	<TEXTURE_FILTER_ANISOTROPIC_16X public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"TEXTURE_FILTER_ANISOTROPIC_16X"</e></m>
		</meta>
	</TEXTURE_FILTER_ANISOTROPIC_16X>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="_Rl.TextureFilter_Impl_" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" private="1" module="Rl" extern="1" final="1">
		<TEXTURE_FILTER_POINT public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"TEXTURE_FILTER_POINT"</e></m>
			</meta>
		</TEXTURE_FILTER_POINT>
		<TEXTURE_FILTER_BILINEAR public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"TEXTURE_FILTER_BILINEAR"</e></m>
			</meta>
		</TEXTURE_FILTER_BILINEAR>
		<TEXTURE_FILTER_TRILINEAR public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"TEXTURE_FILTER_TRILINEAR"</e></m>
			</meta>
		</TEXTURE_FILTER_TRILINEAR>
		<TEXTURE_FILTER_ANISOTROPIC_4X public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"TEXTURE_FILTER_ANISOTROPIC_4X"</e></m>
			</meta>
		</TEXTURE_FILTER_ANISOTROPIC_4X>
		<TEXTURE_FILTER_ANISOTROPIC_8X public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"TEXTURE_FILTER_ANISOTROPIC_8X"</e></m>
			</meta>
		</TEXTURE_FILTER_ANISOTROPIC_8X>
		<TEXTURE_FILTER_ANISOTROPIC_16X public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"TEXTURE_FILTER_ANISOTROPIC_16X"</e></m>
			</meta>
		</TEXTURE_FILTER_ANISOTROPIC_16X>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="TextureWrap" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl">
		<this><x path="UInt"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":include"><e>"raylib.h"</e></m>
		</meta>
		<impl><class path="_Rl.TextureWrap_Impl_" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" private="1" module="Rl" extern="1" final="1">
	<TEXTURE_WRAP_REPEAT public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"TEXTURE_WRAP_REPEAT"</e></m>
		</meta>
	</TEXTURE_WRAP_REPEAT>
	<TEXTURE_WRAP_CLAMP public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"TEXTURE_WRAP_CLAMP"</e></m>
		</meta>
	</TEXTURE_WRAP_CLAMP>
	<TEXTURE_WRAP_MIRROR_REPEAT public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"TEXTURE_WRAP_MIRROR_REPEAT"</e></m>
		</meta>
	</TEXTURE_WRAP_MIRROR_REPEAT>
	<TEXTURE_WRAP_MIRROR_CLAMP public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"TEXTURE_WRAP_MIRROR_CLAMP"</e></m>
		</meta>
	</TEXTURE_WRAP_MIRROR_CLAMP>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="_Rl.TextureWrap_Impl_" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" private="1" module="Rl" extern="1" final="1">
		<TEXTURE_WRAP_REPEAT public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"TEXTURE_WRAP_REPEAT"</e></m>
			</meta>
		</TEXTURE_WRAP_REPEAT>
		<TEXTURE_WRAP_CLAMP public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"TEXTURE_WRAP_CLAMP"</e></m>
			</meta>
		</TEXTURE_WRAP_CLAMP>
		<TEXTURE_WRAP_MIRROR_REPEAT public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"TEXTURE_WRAP_MIRROR_REPEAT"</e></m>
			</meta>
		</TEXTURE_WRAP_MIRROR_REPEAT>
		<TEXTURE_WRAP_MIRROR_CLAMP public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"TEXTURE_WRAP_MIRROR_CLAMP"</e></m>
			</meta>
		</TEXTURE_WRAP_MIRROR_CLAMP>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="CubemapLayout" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl">
		<this><x path="UInt"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":include"><e>"raylib.h"</e></m>
		</meta>
		<impl><class path="_Rl.CubemapLayout_Impl_" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" private="1" module="Rl" extern="1" final="1">
	<CUBEMAP_LAYOUT_AUTO_DETECT public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"CUBEMAP_LAYOUT_AUTO_DETECT"</e></m>
		</meta>
	</CUBEMAP_LAYOUT_AUTO_DETECT>
	<CUBEMAP_LAYOUT_LINE_VERTICAL public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"CUBEMAP_LAYOUT_LINE_VERTICAL"</e></m>
		</meta>
	</CUBEMAP_LAYOUT_LINE_VERTICAL>
	<CUBEMAP_LAYOUT_LINE_HORIZONTAL public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"CUBEMAP_LAYOUT_LINE_HORIZONTAL"</e></m>
		</meta>
	</CUBEMAP_LAYOUT_LINE_HORIZONTAL>
	<CUBEMAP_LAYOUT_CROSS_THREE_BY_FOUR public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"CUBEMAP_LAYOUT_CROSS_THREE_BY_FOUR"</e></m>
		</meta>
	</CUBEMAP_LAYOUT_CROSS_THREE_BY_FOUR>
	<CUBEMAP_LAYOUT_CROSS_FOUR_BY_THREE public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"CUBEMAP_LAYOUT_CROSS_FOUR_BY_THREE"</e></m>
		</meta>
	</CUBEMAP_LAYOUT_CROSS_FOUR_BY_THREE>
	<CUBEMAP_LAYOUT_PANORAMA public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"CUBEMAP_LAYOUT_PANORAMA"</e></m>
		</meta>
	</CUBEMAP_LAYOUT_PANORAMA>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="_Rl.CubemapLayout_Impl_" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" private="1" module="Rl" extern="1" final="1">
		<CUBEMAP_LAYOUT_AUTO_DETECT public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"CUBEMAP_LAYOUT_AUTO_DETECT"</e></m>
			</meta>
		</CUBEMAP_LAYOUT_AUTO_DETECT>
		<CUBEMAP_LAYOUT_LINE_VERTICAL public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"CUBEMAP_LAYOUT_LINE_VERTICAL"</e></m>
			</meta>
		</CUBEMAP_LAYOUT_LINE_VERTICAL>
		<CUBEMAP_LAYOUT_LINE_HORIZONTAL public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"CUBEMAP_LAYOUT_LINE_HORIZONTAL"</e></m>
			</meta>
		</CUBEMAP_LAYOUT_LINE_HORIZONTAL>
		<CUBEMAP_LAYOUT_CROSS_THREE_BY_FOUR public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"CUBEMAP_LAYOUT_CROSS_THREE_BY_FOUR"</e></m>
			</meta>
		</CUBEMAP_LAYOUT_CROSS_THREE_BY_FOUR>
		<CUBEMAP_LAYOUT_CROSS_FOUR_BY_THREE public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"CUBEMAP_LAYOUT_CROSS_FOUR_BY_THREE"</e></m>
			</meta>
		</CUBEMAP_LAYOUT_CROSS_FOUR_BY_THREE>
		<CUBEMAP_LAYOUT_PANORAMA public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"CUBEMAP_LAYOUT_PANORAMA"</e></m>
			</meta>
		</CUBEMAP_LAYOUT_PANORAMA>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="FontType" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl">
		<this><x path="UInt"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":include"><e>"raylib.h"</e></m>
		</meta>
		<impl><class path="_Rl.FontType_Impl_" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" private="1" module="Rl" extern="1" final="1">
	<FONT_DEFAULT public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"FONT_DEFAULT"</e></m>
		</meta>
	</FONT_DEFAULT>
	<FONT_BITMAP public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"FONT_BITMAP"</e></m>
		</meta>
	</FONT_BITMAP>
	<FONT_SDF public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"FONT_SDF"</e></m>
		</meta>
	</FONT_SDF>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="_Rl.FontType_Impl_" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" private="1" module="Rl" extern="1" final="1">
		<FONT_DEFAULT public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"FONT_DEFAULT"</e></m>
			</meta>
		</FONT_DEFAULT>
		<FONT_BITMAP public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"FONT_BITMAP"</e></m>
			</meta>
		</FONT_BITMAP>
		<FONT_SDF public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"FONT_SDF"</e></m>
			</meta>
		</FONT_SDF>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="BlendMode" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl">
		<this><x path="UInt"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":include"><e>"raylib.h"</e></m>
		</meta>
		<impl><class path="_Rl.BlendMode_Impl_" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" private="1" module="Rl" extern="1" final="1">
	<BLEND_ALPHA public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"BLEND_ALPHA"</e></m>
		</meta>
	</BLEND_ALPHA>
	<BLEND_ADDITIVE public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"BLEND_ADDITIVE"</e></m>
		</meta>
	</BLEND_ADDITIVE>
	<BLEND_MULTIPLIED public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"BLEND_MULTIPLIED"</e></m>
		</meta>
	</BLEND_MULTIPLIED>
	<BLEND_ADD_COLORS public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"BLEND_ADD_COLORS"</e></m>
		</meta>
	</BLEND_ADD_COLORS>
	<BLEND_SUBTRACT_COLORS public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"BLEND_SUBTRACT_COLORS"</e></m>
		</meta>
	</BLEND_SUBTRACT_COLORS>
	<BLEND_CUSTOM public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"BLEND_CUSTOM"</e></m>
		</meta>
	</BLEND_CUSTOM>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="_Rl.BlendMode_Impl_" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" private="1" module="Rl" extern="1" final="1">
		<BLEND_ALPHA public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"BLEND_ALPHA"</e></m>
			</meta>
		</BLEND_ALPHA>
		<BLEND_ADDITIVE public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"BLEND_ADDITIVE"</e></m>
			</meta>
		</BLEND_ADDITIVE>
		<BLEND_MULTIPLIED public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"BLEND_MULTIPLIED"</e></m>
			</meta>
		</BLEND_MULTIPLIED>
		<BLEND_ADD_COLORS public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"BLEND_ADD_COLORS"</e></m>
			</meta>
		</BLEND_ADD_COLORS>
		<BLEND_SUBTRACT_COLORS public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"BLEND_SUBTRACT_COLORS"</e></m>
			</meta>
		</BLEND_SUBTRACT_COLORS>
		<BLEND_CUSTOM public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"BLEND_CUSTOM"</e></m>
			</meta>
		</BLEND_CUSTOM>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="Gesture" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl">
		<this><x path="UInt"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":include"><e>"raylib.h"</e></m>
		</meta>
		<impl><class path="_Rl.Gesture_Impl_" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" private="1" module="Rl" extern="1" final="1">
	<GESTURE_NONE public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"GESTURE_NONE"</e></m>
		</meta>
	</GESTURE_NONE>
	<GESTURE_TAP public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"GESTURE_TAP"</e></m>
		</meta>
	</GESTURE_TAP>
	<GESTURE_DOUBLETAP public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"GESTURE_DOUBLETAP"</e></m>
		</meta>
	</GESTURE_DOUBLETAP>
	<GESTURE_HOLD public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"GESTURE_HOLD"</e></m>
		</meta>
	</GESTURE_HOLD>
	<GESTURE_DRAG public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"GESTURE_DRAG"</e></m>
		</meta>
	</GESTURE_DRAG>
	<GESTURE_SWIPE_RIGHT public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"GESTURE_SWIPE_RIGHT"</e></m>
		</meta>
	</GESTURE_SWIPE_RIGHT>
	<GESTURE_SWIPE_LEFT public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"GESTURE_SWIPE_LEFT"</e></m>
		</meta>
	</GESTURE_SWIPE_LEFT>
	<GESTURE_SWIPE_UP public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"GESTURE_SWIPE_UP"</e></m>
		</meta>
	</GESTURE_SWIPE_UP>
	<GESTURE_SWIPE_DOWN public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"GESTURE_SWIPE_DOWN"</e></m>
		</meta>
	</GESTURE_SWIPE_DOWN>
	<GESTURE_PINCH_IN public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"GESTURE_PINCH_IN"</e></m>
		</meta>
	</GESTURE_PINCH_IN>
	<GESTURE_PINCH_OUT public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"GESTURE_PINCH_OUT"</e></m>
		</meta>
	</GESTURE_PINCH_OUT>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="_Rl.Gesture_Impl_" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" private="1" module="Rl" extern="1" final="1">
		<GESTURE_NONE public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"GESTURE_NONE"</e></m>
			</meta>
		</GESTURE_NONE>
		<GESTURE_TAP public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"GESTURE_TAP"</e></m>
			</meta>
		</GESTURE_TAP>
		<GESTURE_DOUBLETAP public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"GESTURE_DOUBLETAP"</e></m>
			</meta>
		</GESTURE_DOUBLETAP>
		<GESTURE_HOLD public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"GESTURE_HOLD"</e></m>
			</meta>
		</GESTURE_HOLD>
		<GESTURE_DRAG public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"GESTURE_DRAG"</e></m>
			</meta>
		</GESTURE_DRAG>
		<GESTURE_SWIPE_RIGHT public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"GESTURE_SWIPE_RIGHT"</e></m>
			</meta>
		</GESTURE_SWIPE_RIGHT>
		<GESTURE_SWIPE_LEFT public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"GESTURE_SWIPE_LEFT"</e></m>
			</meta>
		</GESTURE_SWIPE_LEFT>
		<GESTURE_SWIPE_UP public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"GESTURE_SWIPE_UP"</e></m>
			</meta>
		</GESTURE_SWIPE_UP>
		<GESTURE_SWIPE_DOWN public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"GESTURE_SWIPE_DOWN"</e></m>
			</meta>
		</GESTURE_SWIPE_DOWN>
		<GESTURE_PINCH_IN public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"GESTURE_PINCH_IN"</e></m>
			</meta>
		</GESTURE_PINCH_IN>
		<GESTURE_PINCH_OUT public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"GESTURE_PINCH_OUT"</e></m>
			</meta>
		</GESTURE_PINCH_OUT>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="NPatchLayout" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" module="Rl">
		<this><x path="UInt"/></this>
		<meta>
			<m n=":enum"/>
			<m n=":include"><e>"raylib.h"</e></m>
		</meta>
		<impl><class path="_Rl.NPatchLayout_Impl_" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" private="1" module="Rl" extern="1" final="1">
	<NPATCH_NINE_PATCH public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"NPATCH_NINE_PATCH"</e></m>
		</meta>
	</NPATCH_NINE_PATCH>
	<NPATCH_THREE_PATCH_VERTICAL public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"NPATCH_THREE_PATCH_VERTICAL"</e></m>
		</meta>
	</NPATCH_THREE_PATCH_VERTICAL>
	<NPATCH_THREE_PATCH_HORIZONTAL public="1" set="null" static="1">
		<x path="UInt"/>
		<meta>
			<m n=":enum"/>
			<m n=":native"><e>"NPATCH_THREE_PATCH_HORIZONTAL"</e></m>
		</meta>
	</NPATCH_THREE_PATCH_HORIZONTAL>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="_Rl.NPatchLayout_Impl_" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" private="1" module="Rl" extern="1" final="1">
		<NPATCH_NINE_PATCH public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"NPATCH_NINE_PATCH"</e></m>
			</meta>
		</NPATCH_NINE_PATCH>
		<NPATCH_THREE_PATCH_VERTICAL public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"NPATCH_THREE_PATCH_VERTICAL"</e></m>
			</meta>
		</NPATCH_THREE_PATCH_VERTICAL>
		<NPATCH_THREE_PATCH_HORIZONTAL public="1" set="null" static="1">
			<x path="UInt"/>
			<meta>
				<m n=":enum"/>
				<m n=":native"><e>"NPATCH_THREE_PATCH_HORIZONTAL"</e></m>
			</meta>
		</NPATCH_THREE_PATCH_HORIZONTAL>
		<meta><m n=":enum"/></meta>
	</class>
	<class path="Rl" params="" file="D:\Haxe\haxe\lib\raylib-hx/git/source/Rl.cpp.hx" extern="1">
		<initWindow public="1" set="method" static="1">
			<f a="width:height:title">
				<x path="Int"/>
				<x path="Int"/>
				<x path="cpp.ConstCharStar"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"InitWindow"</e></m></meta>
		</initWindow>
		<windowShouldClose public="1" set="method" static="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":native"><e>"WindowShouldClose"</e></m></meta>
		</windowShouldClose>
		<closeWindow public="1" set="method" static="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":native"><e>"CloseWindow"</e></m></meta>
		</closeWindow>
		<isWindowReady public="1" set="method" static="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":native"><e>"IsWindowReady"</e></m></meta>
		</isWindowReady>
		<isWindowFullscreen public="1" set="method" static="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":native"><e>"IsWindowFullscreen"</e></m></meta>
		</isWindowFullscreen>
		<isWindowHidden public="1" set="method" static="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":native"><e>"IsWindowHidden"</e></m></meta>
		</isWindowHidden>
		<isWindowsMinimized public="1" set="method" static="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":native"><e>"IsWindowMinimized"</e></m></meta>
		</isWindowsMinimized>
		<isWindowMaximized public="1" set="method" static="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":native"><e>"IsWindowMaximized"</e></m></meta>
		</isWindowMaximized>
		<isWindowFocused public="1" set="method" static="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":native"><e>"IsWindowFocused"</e></m></meta>
		</isWindowFocused>
		<isWindowResized public="1" set="method" static="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":native"><e>"IsWindowResized"</e></m></meta>
		</isWindowResized>
		<isWindowState public="1" set="method" static="1">
			<f a="flag">
				<x path="UInt"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"IsWindowState"</e></m></meta>
		</isWindowState>
		<setWindowState public="1" set="method" static="1">
			<f a="flag">
				<x path="UInt"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"SetWindowState"</e></m></meta>
		</setWindowState>
		<clearWindowState public="1" set="method" static="1">
			<f a="flag">
				<x path="UInt"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"ClearWindowState"</e></m></meta>
		</clearWindowState>
		<toggleFullscreen public="1" set="method" static="1">
			<f a=""><c path="cpp.Void"/></f>
			<meta><m n=":native"><e>"ToggleFullscreen"</e></m></meta>
		</toggleFullscreen>
		<maximizeWindow public="1" set="method" static="1">
			<f a=""><c path="cpp.Void"/></f>
			<meta><m n=":native"><e>"MaximizeWindow"</e></m></meta>
		</maximizeWindow>
		<minimizeWindow public="1" set="method" static="1">
			<f a=""><c path="cpp.Void"/></f>
			<meta><m n=":native"><e>"MinimizeWindow"</e></m></meta>
		</minimizeWindow>
		<restoreWindow public="1" set="method" static="1">
			<f a=""><c path="cpp.Void"/></f>
			<meta><m n=":native"><e>"RestoreWindow"</e></m></meta>
		</restoreWindow>
		<setWindowIcon public="1" set="method" static="1">
			<f a="image">
				<t path="Image"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"SetWindowIcon"</e></m></meta>
		</setWindowIcon>
		<setWindowTitle public="1" set="method" static="1">
			<f a="title">
				<x path="cpp.ConstCharStar"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"SetWindowTitle"</e></m></meta>
		</setWindowTitle>
		<setWindowPosition public="1" set="method" static="1">
			<f a="x:y">
				<x path="Int"/>
				<x path="Int"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"SetWindowPosition"</e></m></meta>
		</setWindowPosition>
		<setWindowMonitor public="1" set="method" static="1">
			<f a="monitor">
				<x path="Int"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"SetWindowMonitor"</e></m></meta>
		</setWindowMonitor>
		<setWindowMinSize public="1" set="method" static="1">
			<f a="width:height">
				<x path="Int"/>
				<x path="Int"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"SetWindowMinSize"</e></m></meta>
		</setWindowMinSize>
		<setWindowSize public="1" set="method" static="1">
			<f a="width:height">
				<x path="Int"/>
				<x path="Int"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"SetWindowSize"</e></m></meta>
		</setWindowSize>
		<getWindowHandle public="1" set="method" static="1">
			<f a=""><t path="cpp.Star"><c path="cpp.Void"/></t></f>
			<meta><m n=":native"><e>"GetWindowHandle"</e></m></meta>
		</getWindowHandle>
		<getScreenWidth public="1" set="method" static="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":native"><e>"GetScreenWidth"</e></m></meta>
		</getScreenWidth>
		<getScreenHeight public="1" set="method" static="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":native"><e>"GetScreenHeight"</e></m></meta>
		</getScreenHeight>
		<getMonitorCount public="1" set="method" static="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":native"><e>"GetMonitorCount"</e></m></meta>
		</getMonitorCount>
		<getCurrentMonitor public="1" set="method" static="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":native"><e>"GetCurrentMonitor"</e></m></meta>
		</getCurrentMonitor>
		<getMonitorPosition public="1" set="method" static="1">
			<f a="monitor">
				<x path="Int"/>
				<t path="Vector2"/>
			</f>
			<meta><m n=":native"><e>"GetMonitorPosition"</e></m></meta>
		</getMonitorPosition>
		<getMonitorWidth public="1" set="method" static="1">
			<f a="monitor">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"GetMonitorWidth"</e></m></meta>
		</getMonitorWidth>
		<getMonitorHeight public="1" set="method" static="1">
			<f a="monitor">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"GetMonitorHeight"</e></m></meta>
		</getMonitorHeight>
		<getMonitorPhysicalWidth public="1" set="method" static="1">
			<f a="monitor">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"GetMonitorPhysicalWidth"</e></m></meta>
		</getMonitorPhysicalWidth>
		<getMonitorPhysicalHeight public="1" set="method" static="1">
			<f a="monitor">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"GetMonitorPhysicalHeight"</e></m></meta>
		</getMonitorPhysicalHeight>
		<getMonitorRefershRate public="1" set="method" static="1">
			<f a="monitor">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"GetMonitorRefershRate"</e></m></meta>
		</getMonitorRefershRate>
		<getWindowPosition public="1" set="method" static="1">
			<f a=""><t path="Vector2"/></f>
			<meta><m n=":native"><e>"GetWindowPosition"</e></m></meta>
		</getWindowPosition>
		<getWindowScaleDPI public="1" set="method" static="1">
			<f a=""><t path="Vector2"/></f>
			<meta><m n=":native"><e>"GetWindowScaleDPI"</e></m></meta>
		</getWindowScaleDPI>
		<getMonitorName public="1" set="method" static="1">
			<f a="monitor">
				<x path="Int"/>
				<x path="cpp.ConstCharStar"/>
			</f>
			<meta><m n=":native"><e>"GetMonitorName"</e></m></meta>
		</getMonitorName>
		<setClipboardText public="1" set="method" static="1">
			<f a="text">
				<x path="cpp.ConstCharStar"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"SetClipboardText"</e></m></meta>
		</setClipboardText>
		<getClipboardText public="1" set="method" static="1">
			<f a=""><x path="cpp.ConstCharStar"/></f>
			<meta><m n=":native"><e>"GetClipboardText"</e></m></meta>
		</getClipboardText>
		<initTimer public="1" set="method" static="1">
			<f a=""><c path="cpp.Void"/></f>
			<meta><m n=":native"><e>"InitTimer"</e></m></meta>
		</initTimer>
		<waitTime public="1" set="method" static="1">
			<f a="ms">
				<x path="Float"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"WaitTime"</e></m></meta>
		</waitTime>
		<swapScreenBuffer public="1" set="method" static="1">
			<f a=""><c path="cpp.Void"/></f>
			<meta><m n=":native"><e>"SwapScreenBuffer"</e></m></meta>
		</swapScreenBuffer>
		<pollInputEvents public="1" set="method" static="1">
			<f a=""><c path="cpp.Void"/></f>
			<meta><m n=":native"><e>"PollInputEvents"</e></m></meta>
		</pollInputEvents>
		<showCursor public="1" set="method" static="1">
			<f a=""><c path="cpp.Void"/></f>
			<meta><m n=":native"><e>"ShowCursor"</e></m></meta>
		</showCursor>
		<hideCursor public="1" set="method" static="1">
			<f a=""><c path="cpp.Void"/></f>
			<meta><m n=":native"><e>"HideCursor"</e></m></meta>
		</hideCursor>
		<isCursorHidden public="1" set="method" static="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":native"><e>"IsCursorHidden"</e></m></meta>
		</isCursorHidden>
		<enableCursor public="1" set="method" static="1">
			<f a=""><c path="cpp.Void"/></f>
			<meta><m n=":native"><e>"EnableCursor"</e></m></meta>
		</enableCursor>
		<disableCursor public="1" set="method" static="1">
			<f a=""><c path="cpp.Void"/></f>
			<meta><m n=":native"><e>"DisableCursor"</e></m></meta>
		</disableCursor>
		<isCursorOnScreen public="1" set="method" static="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":native"><e>"IsCursorOnScreen"</e></m></meta>
		</isCursorOnScreen>
		<clearBackground public="1" set="method" static="1">
			<f a="color">
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"ClearBackground"</e></m></meta>
		</clearBackground>
		<beginDrawing public="1" set="method" static="1">
			<f a=""><c path="cpp.Void"/></f>
			<meta><m n=":native"><e>"BeginDrawing"</e></m></meta>
		</beginDrawing>
		<endDrawing public="1" set="method" static="1">
			<f a=""><c path="cpp.Void"/></f>
			<meta><m n=":native"><e>"EndDrawing"</e></m></meta>
		</endDrawing>
		<beginMode2D public="1" set="method" static="1">
			<f a="camera">
				<t path="Camera2D"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"BeginMode2D"</e></m></meta>
		</beginMode2D>
		<endMode2D public="1" set="method" static="1">
			<f a=""><c path="cpp.Void"/></f>
			<meta><m n=":native"><e>"EndMode2D"</e></m></meta>
		</endMode2D>
		<beginMode3D public="1" set="method" static="1">
			<f a="camera">
				<t path="Camera3D"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"BeginMode3D"</e></m></meta>
		</beginMode3D>
		<endMode3D public="1" set="method" static="1">
			<f a=""><c path="cpp.Void"/></f>
			<meta><m n=":native"><e>"EndMode3D"</e></m></meta>
		</endMode3D>
		<beginTextureMode public="1" set="method" static="1">
			<f a="target">
				<t path="RenderTexture2D"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"BeginTextureMode"</e></m></meta>
		</beginTextureMode>
		<endTextureMode public="1" set="method" static="1">
			<f a=""><c path="cpp.Void"/></f>
			<meta><m n=":native"><e>"EndTextureMode"</e></m></meta>
		</endTextureMode>
		<beginShaderMode public="1" set="method" static="1">
			<f a="shader">
				<c path="Shader"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"BeginShaderMode"</e></m></meta>
		</beginShaderMode>
		<endShaderMode public="1" set="method" static="1">
			<f a=""><c path="cpp.Void"/></f>
			<meta><m n=":native"><e>"EndShaderMode"</e></m></meta>
		</endShaderMode>
		<beginBlendMode public="1" set="method" static="1">
			<f a="mode">
				<x path="Int"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"BeginBlendMode"</e></m></meta>
		</beginBlendMode>
		<endBlendMode public="1" set="method" static="1">
			<f a=""><c path="cpp.Void"/></f>
			<meta><m n=":native"><e>"EndBlendMode"</e></m></meta>
		</endBlendMode>
		<beginScissorMode public="1" set="method" static="1">
			<f a="x:y:width:height">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"BeginScissorMode"</e></m></meta>
		</beginScissorMode>
		<endScissorMode public="1" set="method" static="1">
			<f a=""><c path="cpp.Void"/></f>
			<meta><m n=":native"><e>"EndScissorMode"</e></m></meta>
		</endScissorMode>
		<beginVrStereoMode public="1" set="method" static="1">
			<f a="config">
				<c path="VrStereoConfig"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"BeginVrStereoMode"</e></m></meta>
		</beginVrStereoMode>
		<endVrStereoMode public="1" set="method" static="1">
			<f a=""><c path="cpp.Void"/></f>
			<meta><m n=":native"><e>"EndVrStereoMode"</e></m></meta>
		</endVrStereoMode>
		<loadVrStereoConfig public="1" set="method" static="1">
			<f a="device">
				<c path="VrDeviceInfo"/>
				<c path="VrStereoConfig"/>
			</f>
			<meta><m n=":native"><e>"LoadVrStereoConfig"</e></m></meta>
		</loadVrStereoConfig>
		<unloadVrStereoConfig public="1" set="method" static="1">
			<f a="config">
				<c path="VrStereoConfig"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"UnloadVrStereoConfig"</e></m></meta>
		</unloadVrStereoConfig>
		<loadShader public="1" set="method" static="1">
			<f a="vsFileName:fsFileName">
				<x path="cpp.ConstCharStar"/>
				<x path="cpp.ConstCharStar"/>
				<c path="Shader"/>
			</f>
			<meta><m n=":native"><e>"LoadShader"</e></m></meta>
		</loadShader>
		<loadShaderFromMemory public="1" set="method" static="1">
			<f a="vsCode:fsCode">
				<x path="cpp.ConstCharStar"/>
				<x path="cpp.ConstCharStar"/>
				<c path="Shader"/>
			</f>
			<meta><m n=":native"><e>"LoadShaderFromMemory"</e></m></meta>
		</loadShaderFromMemory>
		<getShaderLocation public="1" set="method" static="1">
			<f a="shader:uniformName">
				<c path="Shader"/>
				<x path="cpp.ConstCharStar"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"GetShaderLocation"</e></m></meta>
		</getShaderLocation>
		<getShaderLocationAttrib public="1" set="method" static="1">
			<f a="shader:attribName">
				<c path="Shader"/>
				<x path="cpp.ConstCharStar"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"GetShaderLocationAttrib"</e></m></meta>
		</getShaderLocationAttrib>
		<setShaderValue public="1" set="method" static="1">
			<f a="shader:locIndex:value:uniformType">
				<c path="Shader"/>
				<x path="Int"/>
				<t path="cpp.ConstStar"><c path="cpp.Void"/></t>
				<x path="Int"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"SetShaderValue"</e></m></meta>
		</setShaderValue>
		<setShaderValueV public="1" set="method" static="1">
			<f a="shader:locIndex:value:uniformType:count">
				<c path="Shader"/>
				<x path="Int"/>
				<t path="cpp.ConstStar"><c path="cpp.Void"/></t>
				<x path="Int"/>
				<x path="Int"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"SetShaderValueV"</e></m></meta>
		</setShaderValueV>
		<setShaderValueMatrix public="1" set="method" static="1">
			<f a="shader:locIndex:mat">
				<c path="Shader"/>
				<x path="Int"/>
				<t path="Matrix"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"SetShaderValueMatrix"</e></m></meta>
		</setShaderValueMatrix>
		<setShaderValueTexture public="1" set="method" static="1">
			<f a="shader:locIndex:texture">
				<c path="Shader"/>
				<x path="Int"/>
				<t path="Texture2D"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"SetShaderValueTexture"</e></m></meta>
		</setShaderValueTexture>
		<unloadShader public="1" set="method" static="1">
			<f a="shader">
				<c path="Shader"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"UnloadShader"</e></m></meta>
		</unloadShader>
		<getMouseRay public="1" set="method" static="1">
			<f a="mousePosition:camera">
				<t path="Vector2"/>
				<t path="Camera"/>
				<c path="Ray"/>
			</f>
			<meta><m n=":native"><e>"GetMouseRay"</e></m></meta>
		</getMouseRay>
		<getCameraMatrix public="1" set="method" static="1">
			<f a="camera">
				<t path="Camera"/>
				<t path="Matrix"/>
			</f>
			<meta><m n=":native"><e>"GetCameraMatrix"</e></m></meta>
		</getCameraMatrix>
		<getCameraMatrix2D public="1" set="method" static="1">
			<f a="camera">
				<t path="Camera2D"/>
				<t path="Matrix"/>
			</f>
			<meta><m n=":native"><e>"GetCameraMatrix2D"</e></m></meta>
		</getCameraMatrix2D>
		<getWorldToScreen public="1" set="method" static="1">
			<f a="position:camera">
				<t path="Vector3"/>
				<t path="Camera"/>
				<t path="Vector2"/>
			</f>
			<meta><m n=":native"><e>"GetWorldToScreen"</e></m></meta>
		</getWorldToScreen>
		<getWorldToScreenEx public="1" set="method" static="1">
			<f a="position:camera:width:height">
				<t path="Vector3"/>
				<t path="Camera"/>
				<x path="Int"/>
				<x path="Int"/>
				<t path="Vector2"/>
			</f>
			<meta><m n=":native"><e>"GetWorldToScreenEx"</e></m></meta>
		</getWorldToScreenEx>
		<getWorldToScreen2D public="1" set="method" static="1">
			<f a="postition:camera">
				<t path="Vector2"/>
				<t path="Camera2D"/>
				<t path="Vector2"/>
			</f>
			<meta><m n=":native"><e>"GetWorldToScreen2D"</e></m></meta>
		</getWorldToScreen2D>
		<getScreenToWorld public="1" set="method" static="1">
			<f a="position:camera">
				<t path="Vector2"/>
				<t path="Camera2D"/>
				<t path="Vector2"/>
			</f>
			<meta><m n=":native"><e>"GetScreenToWorld"</e></m></meta>
		</getScreenToWorld>
		<setTargetFPS public="1" set="method" static="1">
			<f a="fps">
				<x path="Int"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"SetTargetFPS"</e></m></meta>
		</setTargetFPS>
		<getFrameTime public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<meta><m n=":native"><e>"GetFrameTime"</e></m></meta>
		</getFrameTime>
		<getFPS public="1" set="method" static="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":native"><e>"GetFPS"</e></m></meta>
		</getFPS>
		<getTime public="1" set="method" static="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":native"><e>"GetTime"</e></m></meta>
		</getTime>
		<getRandomValue public="1" set="method" static="1">
			<f a="min:max">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"GetRandomValue"</e></m></meta>
		</getRandomValue>
		<takeScreenshot public="1" set="method" static="1">
			<f a="fileName">
				<x path="cpp.ConstCharStar"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"TakeScreenshot"</e></m></meta>
		</takeScreenshot>
		<setConfigFlags public="1" set="method" static="1">
			<f a="flags">
				<x path="UInt"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"SetConfigFlags"</e></m></meta>
		</setConfigFlags>
		<traceLog public="1" set="method" static="1">
			<f a="logLevel:text">
				<x path="Int"/>
				<x path="cpp.ConstCharStar"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"TraceLog"</e></m></meta>
		</traceLog>
		<setTraceLogLevel public="1" set="method" static="1">
			<f a="logLevel">
				<x path="Int"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"SetTraceLogLevel"</e></m></meta>
		</setTraceLogLevel>
		<memAlloc public="1" set="method" static="1">
			<f a="size">
				<x path="Int"/>
				<t path="cpp.Star"><c path="cpp.Void"/></t>
			</f>
			<meta><m n=":native"><e>"MemAlloc"</e></m></meta>
		</memAlloc>
		<memRealloc public="1" set="method" static="1">
			<f a="ptr:size">
				<t path="cpp.Star"><c path="cpp.Void"/></t>
				<x path="Int"/>
				<t path="cpp.Star"><c path="cpp.Void"/></t>
			</f>
			<meta><m n=":native"><e>"MemRealloc"</e></m></meta>
		</memRealloc>
		<memFree public="1" set="method" static="1">
			<f a="ptr">
				<t path="cpp.Star"><c path="cpp.Void"/></t>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"MemFree"</e></m></meta>
		</memFree>
		<loadFileData public="1" set="method" static="1">
			<f a="filename:bytesRead">
				<x path="cpp.ConstCharStar"/>
				<t path="cpp.Star"><x path="UInt"/></t>
				<t path="cpp.Star"><x path="cpp.UInt16"/></t>
			</f>
			<meta><m n=":native"><e>"LoadFileData"</e></m></meta>
		</loadFileData>
		<unloadFileData public="1" set="method" static="1">
			<f a="data">
				<t path="cpp.Star"><x path="cpp.UInt16"/></t>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"UnloadFileData"</e></m></meta>
		</unloadFileData>
		<saveFileData public="1" set="method" static="1">
			<f a="filename:data:byetsToWrite">
				<t path="cpp.Star"><x path="cpp.UInt16"/></t>
				<t path="cpp.Star"><c path="cpp.Void"/></t>
				<x path="UInt"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"SaveFileData"</e></m></meta>
		</saveFileData>
		<loadFileText public="1" set="method" static="1">
			<f a="fileName">
				<x path="cpp.ConstCharStar"/>
				<x path="cpp.ConstCharStar"/>
			</f>
			<meta><m n=":native"><e>"LoadFileText"</e></m></meta>
		</loadFileText>
		<unloadFileText public="1" set="method" static="1">
			<f a="text">
				<x path="cpp.ConstCharStar"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"UnloadFileText"</e></m></meta>
		</unloadFileText>
		<saveFileText public="1" set="method" static="1">
			<f a="fileName:text">
				<x path="cpp.ConstCharStar"/>
				<x path="cpp.ConstCharStar"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"SaveFileText"</e></m></meta>
		</saveFileText>
		<fileExists public="1" set="method" static="1">
			<f a="fileName">
				<x path="cpp.ConstCharStar"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"FileExists"</e></m></meta>
		</fileExists>
		<directoryExists public="1" set="method" static="1">
			<f a="dirPath">
				<x path="cpp.ConstCharStar"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"DirectoryExists"</e></m></meta>
		</directoryExists>
		<isFileExtension public="1" set="method" static="1">
			<f a="fileName:ext">
				<x path="cpp.ConstCharStar"/>
				<x path="cpp.ConstCharStar"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"IsFileExtension"</e></m></meta>
		</isFileExtension>
		<getFileExtension public="1" set="method" static="1">
			<f a="fileName">
				<x path="cpp.ConstCharStar"/>
				<x path="cpp.ConstCharStar"/>
			</f>
			<meta><m n=":native"><e>"GetFileExtension"</e></m></meta>
		</getFileExtension>
		<getFileName public="1" set="method" static="1">
			<f a="filePath">
				<x path="cpp.ConstCharStar"/>
				<x path="cpp.ConstCharStar"/>
			</f>
			<meta><m n=":native"><e>"GetFileName"</e></m></meta>
		</getFileName>
		<getFileNameWithoutExt public="1" set="method" static="1">
			<f a="filePath">
				<x path="cpp.ConstCharStar"/>
				<x path="cpp.ConstCharStar"/>
			</f>
			<meta><m n=":native"><e>"GetFileNameWithoutExt"</e></m></meta>
		</getFileNameWithoutExt>
		<getDirectoryPath public="1" set="method" static="1">
			<f a="filePath">
				<x path="cpp.ConstCharStar"/>
				<x path="cpp.ConstCharStar"/>
			</f>
			<meta><m n=":native"><e>"GetDirectoryPath"</e></m></meta>
		</getDirectoryPath>
		<getPrevDirectoryPath public="1" set="method" static="1">
			<f a="dirPath">
				<x path="cpp.ConstCharStar"/>
				<x path="cpp.ConstCharStar"/>
			</f>
			<meta><m n=":native"><e>"GetPrevDirectoryPath"</e></m></meta>
		</getPrevDirectoryPath>
		<getWorkingDirectory public="1" set="method" static="1">
			<f a=""><x path="cpp.ConstCharStar"/></f>
			<meta><m n=":native"><e>"GetWorkingDirectory"</e></m></meta>
		</getWorkingDirectory>
		<getDirectoryFiles public="1" set="method" static="1">
			<f a="dirPath:count">
				<x path="cpp.ConstCharStar"/>
				<t path="cpp.Star"><x path="Int"/></t>
				<t path="cpp.Star"><x path="cpp.ConstCharStar"/></t>
			</f>
			<meta><m n=":native"><e>"GetDirectoryFiles"</e></m></meta>
		</getDirectoryFiles>
		<clearDirectoryFiles public="1" set="method" static="1">
			<f a=""><c path="cpp.Void"/></f>
			<meta><m n=":native"><e>"ClearDirectoryFiles"</e></m></meta>
		</clearDirectoryFiles>
		<changeDirectory public="1" set="method" static="1">
			<f a="dir">
				<x path="cpp.ConstCharStar"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"ChangeDirectory"</e></m></meta>
		</changeDirectory>
		<isFileDropped public="1" set="method" static="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":native"><e>"IsFileDropped"</e></m></meta>
		</isFileDropped>
		<getDroppedFiles public="1" set="method" static="1">
			<f a="count">
				<t path="cpp.Star"><x path="Int"/></t>
				<t path="cpp.Star"><x path="cpp.ConstCharStar"/></t>
			</f>
			<meta><m n=":native"><e>"GetDroppedFiles"</e></m></meta>
		</getDroppedFiles>
		<clearDroppedFiles public="1" set="method" static="1">
			<f a=""><c path="cpp.Void"/></f>
			<meta><m n=":native"><e>"ClearDroppedFiles"</e></m></meta>
		</clearDroppedFiles>
		<getFileModTime public="1" set="method" static="1">
			<f a="fileName">
				<x path="cpp.ConstCharStar"/>
				<x path="Float"/>
			</f>
			<meta><m n=":native"><e>"GetFileModTime"</e></m></meta>
		</getFileModTime>
		<saveStorageValue public="1" set="method" static="1">
			<f a="postition:value">
				<x path="UInt"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"SaveStorageValue"</e></m></meta>
		</saveStorageValue>
		<loadStorageValue public="1" set="method" static="1">
			<f a="position">
				<x path="UInt"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"LoadStorageValue"</e></m></meta>
		</loadStorageValue>
		<openURL public="1" set="method" static="1">
			<f a="url">
				<x path="cpp.ConstCharStar"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"OpenURL"</e></m></meta>
		</openURL>
		<isKeyPressed public="1" set="method" static="1">
			<f a="key">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"IsKeyPressed"</e></m></meta>
		</isKeyPressed>
		<isKeyDown public="1" set="method" static="1">
			<f a="key">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"IsKeyDown"</e></m></meta>
		</isKeyDown>
		<isKeyReleased public="1" set="method" static="1">
			<f a="key">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"IsKeyReleased"</e></m></meta>
		</isKeyReleased>
		<isKeyUp public="1" set="method" static="1">
			<f a="key">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"IsKeyUp"</e></m></meta>
		</isKeyUp>
		<setExitKey public="1" set="method" static="1">
			<f a="key">
				<x path="Int"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"SetExitKey"</e></m></meta>
		</setExitKey>
		<getKeyPressed public="1" set="method" static="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":native"><e>"GetKeyPressed"</e></m></meta>
		</getKeyPressed>
		<getCharPressed public="1" set="method" static="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":native"><e>"GetCharPressed"</e></m></meta>
		</getCharPressed>
		<isGamepadAvailable public="1" set="method" static="1">
			<f a="gamepad">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"IsGamepadAvailable"</e></m></meta>
		</isGamepadAvailable>
		<isGamepadName public="1" set="method" static="1">
			<f a="gamepad:name">
				<x path="Int"/>
				<x path="cpp.ConstCharStar"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"IsGamepadName"</e></m></meta>
		</isGamepadName>
		<getGamepadName public="1" set="method" static="1">
			<f a="gamepad">
				<x path="Int"/>
				<x path="cpp.ConstCharStar"/>
			</f>
			<meta><m n=":native"><e>"GetGamepadName"</e></m></meta>
		</getGamepadName>
		<isGamepadButtonPressed public="1" set="method" static="1">
			<f a="gamepad:button">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"IsGamepadButtonPressed"</e></m></meta>
		</isGamepadButtonPressed>
		<isGamepadButtonDown public="1" set="method" static="1">
			<f a="gamepad:button">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"IsGamepadButtonDown"</e></m></meta>
		</isGamepadButtonDown>
		<isGamepadButtonReleased public="1" set="method" static="1">
			<f a="gamepad:button">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"IsGamepadButtonReleased"</e></m></meta>
		</isGamepadButtonReleased>
		<isGamepadButtonUp public="1" set="method" static="1">
			<f a="gamepad:button">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"IsGamepadButtonUp"</e></m></meta>
		</isGamepadButtonUp>
		<getGamepadButtonPressed public="1" set="method" static="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":native"><e>"GetGamepadButtonPressed"</e></m></meta>
		</getGamepadButtonPressed>
		<getGamepadAxisCount public="1" set="method" static="1">
			<f a="gamepad">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"GetGamepadAxisCount"</e></m></meta>
		</getGamepadAxisCount>
		<getGamepadAxisMovement public="1" set="method" static="1">
			<f a="gamepad:axis">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":native"><e>"GetGamepadAxisMovement"</e></m></meta>
		</getGamepadAxisMovement>
		<setGamepadMappings public="1" set="method" static="1">
			<f a="mappings">
				<x path="cpp.ConstCharStar"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"SetGamepadMappings"</e></m></meta>
		</setGamepadMappings>
		<isMouseButtonPressed public="1" set="method" static="1">
			<f a="button">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"IsMouseButtonPressed"</e></m></meta>
		</isMouseButtonPressed>
		<isMouseButtonDown public="1" set="method" static="1">
			<f a="button">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"IsMouseButtonDown"</e></m></meta>
		</isMouseButtonDown>
		<isMouseButtonReleased public="1" set="method" static="1">
			<f a="button">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"IsMouseButtonReleased"</e></m></meta>
		</isMouseButtonReleased>
		<isMouseButtonUp public="1" set="method" static="1">
			<f a="buttton">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"IsMouseButtonUp"</e></m></meta>
		</isMouseButtonUp>
		<getMouseX public="1" set="method" static="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":native"><e>"GetMouseX"</e></m></meta>
		</getMouseX>
		<getMouseY public="1" set="method" static="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":native"><e>"GetMouseY"</e></m></meta>
		</getMouseY>
		<getMousePosition public="1" set="method" static="1">
			<f a=""><t path="Vector2"/></f>
			<meta><m n=":native"><e>"GetMousePosition"</e></m></meta>
		</getMousePosition>
		<getMouseDelta public="1" set="method" static="1">
			<f a=""><t path="Vector2"/></f>
			<meta><m n=":native"><e>"GetMouseDelta"</e></m></meta>
		</getMouseDelta>
		<setMousePosition public="1" set="method" static="1">
			<f a="x:y">
				<x path="Int"/>
				<x path="Int"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"SetMousePosition"</e></m></meta>
		</setMousePosition>
		<setMouseOffset public="1" set="method" static="1">
			<f a="offsetX:offsetY">
				<x path="Int"/>
				<x path="Int"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"SetMouseOffset"</e></m></meta>
		</setMouseOffset>
		<getMouseWheelMove public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<meta><m n=":native"><e>"GetMouseWheelMove"</e></m></meta>
		</getMouseWheelMove>
		<setMouseCursor public="1" set="method" static="1">
			<f a="cursor">
				<x path="Int"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"SetMouseCursor"</e></m></meta>
		</setMouseCursor>
		<getTouchX public="1" set="method" static="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":native"><e>"GetTouchX"</e></m></meta>
		</getTouchX>
		<getTouchY public="1" set="method" static="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":native"><e>"GetTouchY"</e></m></meta>
		</getTouchY>
		<getTouchPosition public="1" set="method" static="1">
			<f a="index">
				<x path="Int"/>
				<t path="Vector2"/>
			</f>
			<meta><m n=":native"><e>"GetTouchPosition"</e></m></meta>
		</getTouchPosition>
		<setGestureEnabled public="1" set="method" static="1">
			<f a="flags">
				<x path="UInt"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"SetGestureEnabled"</e></m></meta>
		</setGestureEnabled>
		<isGestureDetected public="1" set="method" static="1">
			<f a="gesture">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"IsGestureDetected"</e></m></meta>
		</isGestureDetected>
		<getGestureDetected public="1" set="method" static="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":native"><e>"GetGestureDetected"</e></m></meta>
		</getGestureDetected>
		<getTouchPointsCount public="1" set="method" static="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":native"><e>"GetTouchPointsCount"</e></m></meta>
		</getTouchPointsCount>
		<getGestureHoldDuration public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<meta><m n=":native"><e>"GetGestureHoldDuration"</e></m></meta>
		</getGestureHoldDuration>
		<getGestureDragVector public="1" set="method" static="1">
			<f a=""><t path="Vector2"/></f>
			<meta><m n=":native"><e>"GetGestureDragVector"</e></m></meta>
		</getGestureDragVector>
		<getGestureDragAngle public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<meta><m n=":native"><e>"GetGestureDragAngle"</e></m></meta>
		</getGestureDragAngle>
		<getGesturePinchVector public="1" set="method" static="1">
			<f a=""><t path="Vector2"/></f>
			<meta><m n=":native"><e>"GetGesturePinchVector"</e></m></meta>
		</getGesturePinchVector>
		<getGesturePinchAngle public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<meta><m n=":native"><e>"GetGesturePinchAngle"</e></m></meta>
		</getGesturePinchAngle>
		<setCameraMode public="1" set="method" static="1">
			<f a="camera:mode">
				<t path="Camera"/>
				<x path="Int"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"SetCameraMode"</e></m></meta>
		</setCameraMode>
		<updateCamera public="1" set="method" static="1">
			<f a="camera">
				<t path="cpp.Star"><t path="Camera"/></t>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"UpdateCamera"</e></m></meta>
		</updateCamera>
		<setCameraPanControl public="1" set="method" static="1">
			<f a="keyPan">
				<x path="Int"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"SetCameraPanControl"</e></m></meta>
		</setCameraPanControl>
		<setCameraAltControl public="1" set="method" static="1">
			<f a="keyAlt">
				<x path="Int"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"SetCameraAltControl"</e></m></meta>
		</setCameraAltControl>
		<setCameraSmoothZoomControl public="1" set="method" static="1">
			<f a="keySmoothZoom">
				<x path="Int"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"SetCameraSmoothZoomControl"</e></m></meta>
		</setCameraSmoothZoomControl>
		<setCameraMoveControls public="1" set="method" static="1">
			<f a="keyFron:keyBack:keyRight:keyLeft:keyUp:keyDown">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"SetCameraMoveControls"</e></m></meta>
		</setCameraMoveControls>
		<setShapesTexture public="1" set="method" static="1">
			<f a="texture:source">
				<t path="Texture2D"/>
				<t path="Rectangle"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"SetShapesTexture"</e></m></meta>
		</setShapesTexture>
		<drawPixel public="1" set="method" static="1">
			<f a="posX:posY:color">
				<x path="Int"/>
				<x path="Int"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawPixel"</e></m></meta>
		</drawPixel>
		<drawPixelV public="1" set="method" static="1">
			<f a="position:color">
				<t path="Vector2"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawPixelV"</e></m></meta>
		</drawPixelV>
		<drawLine public="1" set="method" static="1">
			<f a="startPosX:startPosY:endPosX:endPosY:color">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawLine"</e></m></meta>
		</drawLine>
		<drawLineV public="1" set="method" static="1">
			<f a="startPos:endPos:color">
				<t path="Vector2"/>
				<t path="Vector2"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawLineV"</e></m></meta>
		</drawLineV>
		<drawLineEx public="1" set="method" static="1">
			<f a="startPos:endPos:thick:color">
				<t path="Vector2"/>
				<t path="Vector2"/>
				<x path="Float"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawLineEx"</e></m></meta>
		</drawLineEx>
		<drawLineBezier public="1" set="method" static="1">
			<f a="startPos:endPos:thick:color">
				<t path="Vector2"/>
				<t path="Vector2"/>
				<x path="Float"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawLineBezier"</e></m></meta>
		</drawLineBezier>
		<drawLineBezierQuad public="1" set="method" static="1">
			<f a="startPos:endPos:controlPos:thick:color">
				<t path="Vector2"/>
				<t path="Vector2"/>
				<t path="Vector2"/>
				<x path="Float"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawLineBezierQuad"</e></m></meta>
		</drawLineBezierQuad>
		<drawLineStrip public="1" set="method" static="1">
			<f a="points:pointsCount:color">
				<t path="cpp.Star"><t path="Vector2"/></t>
				<x path="Int"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawLineStrip"</e></m></meta>
		</drawLineStrip>
		<drawCircle public="1" set="method" static="1">
			<f a="centerX:centerY:radius:color">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawCircle"</e></m></meta>
		</drawCircle>
		<drawCircleSector public="1" set="method" static="1">
			<f a="center:radius:startAngle:endAngle:segments:color">
				<t path="Vector2"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawCircleSector"</e></m></meta>
		</drawCircleSector>
		<drawCircleSectorLines public="1" set="method" static="1">
			<f a="center:radius:startAngle:endAngle:segments:color">
				<t path="Vector2"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawCircleSectorLines"</e></m></meta>
		</drawCircleSectorLines>
		<drawCircleGradient public="1" set="method" static="1">
			<f a="centerX:centerY:radius:color1:color2">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<t path="Color"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawCircleGradient"</e></m></meta>
		</drawCircleGradient>
		<drawCircleV public="1" set="method" static="1">
			<f a="center:radius:color">
				<t path="Vector2"/>
				<x path="Float"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawCircleV"</e></m></meta>
		</drawCircleV>
		<drawRectangle public="1" set="method" static="1">
			<f a="posX:posY:width:height:color">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawRectangle"</e></m></meta>
		</drawRectangle>
		<drawRectangleV public="1" set="method" static="1">
			<f a="position:size:color">
				<t path="Vector2"/>
				<t path="Vector2"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawRectangleV"</e></m></meta>
		</drawRectangleV>
		<drawRectangleRec public="1" set="method" static="1">
			<f a="rec:color">
				<t path="Rectangle"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawRectangleRec"</e></m></meta>
		</drawRectangleRec>
		<drawRectanglePro public="1" set="method" static="1">
			<f a="rec:origin:rotation:color">
				<t path="Rectangle"/>
				<t path="Vector2"/>
				<x path="Float"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawRectanglePro"</e></m></meta>
		</drawRectanglePro>
		<drawRectangleGradientV public="1" set="method" static="1">
			<f a="posX:posY:width:height:color1:color2">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<t path="Color"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawRectangleGradientV"</e></m></meta>
		</drawRectangleGradientV>
		<drawRectangleGradientH public="1" set="method" static="1">
			<f a="posX:posY:width:height:color1:color2">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<t path="Color"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawRectangleGradientH"</e></m></meta>
		</drawRectangleGradientH>
		<drawRectangleLines public="1" set="method" static="1">
			<f a="posX:posY:width:height:color">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawRectangleLines"</e></m></meta>
		</drawRectangleLines>
		<drawRectangleLinesEx public="1" set="method" static="1">
			<f a="rec:lineThick:color">
				<t path="Rectangle"/>
				<x path="Int"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawRectangleLinesEx"</e></m></meta>
		</drawRectangleLinesEx>
		<drawRectangleRounded public="1" set="method" static="1">
			<f a="rec:roundness:segments:color">
				<t path="Rectangle"/>
				<x path="Float"/>
				<x path="Int"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawRectangleRounded"</e></m></meta>
		</drawRectangleRounded>
		<drawRectangleRoundedLines public="1" set="method" static="1">
			<f a="rec:roundness:segments:lineThick:color">
				<t path="Rectangle"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawRectangleRoundedLines"</e></m></meta>
		</drawRectangleRoundedLines>
		<drawTriangle public="1" set="method" static="1">
			<f a="v1:v2:v3:color">
				<t path="Vector2"/>
				<t path="Vector2"/>
				<t path="Vector3"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawTriangle"</e></m></meta>
		</drawTriangle>
		<drawTriangleLines public="1" set="method" static="1">
			<f a="v1:v2:v3:color">
				<t path="Vector2"/>
				<t path="Vector2"/>
				<t path="Vector3"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawTriangleLines"</e></m></meta>
		</drawTriangleLines>
		<drawTriangleFan public="1" set="method" static="1">
			<f a="points:pointsCount:color">
				<t path="cpp.Star"><t path="Vector2"/></t>
				<x path="Int"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawTriangleFan"</e></m></meta>
		</drawTriangleFan>
		<drawTriangleStrip public="1" set="method" static="1">
			<f a="points:pointsCount:color">
				<t path="cpp.Star"><t path="Vector2"/></t>
				<x path="Int"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawTriangleStrip"</e></m></meta>
		</drawTriangleStrip>
		<drawPoly public="1" set="method" static="1">
			<f a="center:sides:radius:rotation:color">
				<t path="Vector2"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawPoly"</e></m></meta>
		</drawPoly>
		<drawPolyLines public="1" set="method" static="1">
			<f a="center:sides:radius:rotation:color">
				<t path="Vector2"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawPolyLines"</e></m></meta>
		</drawPolyLines>
		<drawPolyLinesEx public="1" set="method" static="1">
			<f a="center:sides:radius:rotation:lineThick:color">
				<t path="Vector2"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawPolyLinesEx"</e></m></meta>
		</drawPolyLinesEx>
		<checkCollisionRecs public="1" set="method" static="1">
			<f a="rec1:rec2">
				<t path="Rectangle"/>
				<t path="Rectangle"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"CheckCollisionRecs"</e></m></meta>
		</checkCollisionRecs>
		<checkCollisionCircles public="1" set="method" static="1">
			<f a="center1:radius1:center2:radius2">
				<t path="Vector2"/>
				<x path="Float"/>
				<t path="Vector2"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"CheckCollisionCircles"</e></m></meta>
		</checkCollisionCircles>
		<checkCollisionCircleRec public="1" set="method" static="1">
			<f a="center:radius:rec">
				<t path="Vector2"/>
				<x path="Float"/>
				<t path="Rectangle"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"CheckCollisionCircleRec"</e></m></meta>
		</checkCollisionCircleRec>
		<checkCollisionPointRec public="1" set="method" static="1">
			<f a="point:rec">
				<t path="Vector2"/>
				<t path="Rectangle"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"CheckCollisionPointRec"</e></m></meta>
		</checkCollisionPointRec>
		<checkCollisionPointCircle public="1" set="method" static="1">
			<f a="point:center:radius">
				<t path="Vector2"/>
				<t path="Vector2"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"CheckCollisionPointCircle"</e></m></meta>
		</checkCollisionPointCircle>
		<checkCollisionPointTriangle public="1" set="method" static="1">
			<f a="point:p1:p2:p3">
				<t path="Vector2"/>
				<t path="Vector2"/>
				<t path="Vector2"/>
				<t path="Vector2"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"CheckCollisionPointTriangle"</e></m></meta>
		</checkCollisionPointTriangle>
		<checkCollisionLines public="1" set="method" static="1">
			<f a="startPos1:endPos1:startPos2:endPos2:collisionPoint">
				<t path="Vector2"/>
				<t path="Vector2"/>
				<t path="Vector2"/>
				<t path="Vector2"/>
				<t path="cpp.Star"><t path="Vector2"/></t>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"CheckCollisionLines"</e></m></meta>
		</checkCollisionLines>
		<checkCollisionPointLine public="1" set="method" static="1">
			<f a="point:p1:p2:threshold">
				<t path="Vector2"/>
				<t path="Vector2"/>
				<t path="Vector2"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"CheckCollisionPointLine"</e></m></meta>
		</checkCollisionPointLine>
		<getCollisionRec public="1" set="method" static="1">
			<f a="rec1:rec2">
				<t path="Rectangle"/>
				<t path="Rectangle"/>
				<t path="Rectangle"/>
			</f>
			<meta><m n=":native"><e>"GetCollisionRec"</e></m></meta>
		</getCollisionRec>
		<loadImage public="1" set="method" static="1">
			<f a="fileName">
				<x path="cpp.ConstCharStar"/>
				<t path="Image"/>
			</f>
			<meta><m n=":native"><e>"LoadImage"</e></m></meta>
		</loadImage>
		<loadImageRaw public="1" set="method" static="1">
			<f a="fileName:width:height:format:headerSize">
				<x path="cpp.ConstCharStar"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<t path="Image"/>
			</f>
			<meta><m n=":native"><e>"LoadImageRaw"</e></m></meta>
		</loadImageRaw>
		<loadImageAnim public="1" set="method" static="1">
			<f a="fileName:frames">
				<x path="cpp.ConstCharStar"/>
				<x path="Int"/>
				<t path="Image"/>
			</f>
			<meta><m n=":native"><e>"LoadImageAnim"</e></m></meta>
		</loadImageAnim>
		<loadImageFromMemory public="1" set="method" static="1">
			<f a="fileType:fileData:dataSize">
				<x path="cpp.ConstCharStar"/>
				<t path="cpp.ConstStar"><x path="cpp.UInt8"/></t>
				<x path="Int"/>
				<t path="Image"/>
			</f>
			<meta><m n=":native"><e>"LoadImageFromMemory"</e></m></meta>
		</loadImageFromMemory>
		<loadImageFromTexture public="1" set="method" static="1">
			<f a="texture">
				<t path="Texture2D"/>
				<t path="Image"/>
			</f>
			<meta><m n=":native"><e>"LoadImageFromTexture"</e></m></meta>
		</loadImageFromTexture>
		<loadImageFromScreen public="1" set="method" static="1">
			<f a=""><c path="cpp.Void"/></f>
			<meta><m n=":native"><e>"LoadImageFromScreen"</e></m></meta>
		</loadImageFromScreen>
		<unloadImage public="1" set="method" static="1">
			<f a="image">
				<t path="Image"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"UnloadImage"</e></m></meta>
		</unloadImage>
		<exportImage public="1" set="method" static="1">
			<f a="image:fileName">
				<t path="Image"/>
				<x path="cpp.ConstCharStar"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"ExportImage"</e></m></meta>
		</exportImage>
		<exportImageAsCode public="1" set="method" static="1">
			<f a="image:fileName">
				<t path="Image"/>
				<x path="cpp.ConstCharStar"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"ExportImageAsCode"</e></m></meta>
		</exportImageAsCode>
		<genImageColor public="1" set="method" static="1">
			<f a="width:height:color">
				<x path="Int"/>
				<x path="Int"/>
				<t path="Color"/>
				<t path="Image"/>
			</f>
			<meta><m n=":native"><e>"GenImageColor"</e></m></meta>
		</genImageColor>
		<genImageGradientV public="1" set="method" static="1">
			<f a="width:height:top:bottom">
				<x path="Int"/>
				<x path="Int"/>
				<t path="Color"/>
				<t path="Color"/>
				<t path="Image"/>
			</f>
			<meta><m n=":native"><e>"GenImageGradientV"</e></m></meta>
		</genImageGradientV>
		<genImageGradientH public="1" set="method" static="1">
			<f a="width:height:left:right">
				<x path="Int"/>
				<x path="Int"/>
				<t path="Color"/>
				<t path="Color"/>
				<t path="Image"/>
			</f>
			<meta><m n=":native"><e>"GenImageGradientH"</e></m></meta>
		</genImageGradientH>
		<genImageGradientRadial public="1" set="method" static="1">
			<f a="width:height:density:inner:outer">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<t path="Color"/>
				<t path="Color"/>
				<t path="Image"/>
			</f>
			<meta><m n=":native"><e>"GenImageGradientRadial"</e></m></meta>
		</genImageGradientRadial>
		<genImageChecked public="1" set="method" static="1">
			<f a="width:height:checksX:checksY:color">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<t path="Color"/>
				<t path="Image"/>
			</f>
			<meta><m n=":native"><e>"GenImageChecked"</e></m></meta>
		</genImageChecked>
		<genImageWhiteNoise public="1" set="method" static="1">
			<f a="width:height:factor">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<t path="Image"/>
			</f>
			<meta><m n=":native"><e>"GenImageWhiteNoise"</e></m></meta>
		</genImageWhiteNoise>
		<genImageCellular public="1" set="method" static="1">
			<f a="width:height:tileSize">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<t path="Image"/>
			</f>
			<meta><m n=":native"><e>"GenImageCellular"</e></m></meta>
		</genImageCellular>
		<imageCopy public="1" set="method" static="1">
			<f a="image">
				<t path="Image"/>
				<t path="Image"/>
			</f>
			<meta><m n=":native"><e>"ImageCopy"</e></m></meta>
		</imageCopy>
		<imageFromImage public="1" set="method" static="1">
			<f a="image:rec">
				<t path="Image"/>
				<t path="Rectangle"/>
				<t path="Image"/>
			</f>
			<meta><m n=":native"><e>"ImageFromImage"</e></m></meta>
		</imageFromImage>
		<imageText public="1" set="method" static="1">
			<f a="text:fontSize:color">
				<x path="cpp.ConstCharStar"/>
				<x path="Int"/>
				<t path="Color"/>
				<t path="Image"/>
			</f>
			<meta><m n=":native"><e>"ImageText"</e></m></meta>
		</imageText>
		<imageTextEx public="1" set="method" static="1">
			<f a="font:text:fontSize:spacing:tint">
				<c path="Font"/>
				<x path="cpp.ConstCharStar"/>
				<x path="Float"/>
				<x path="Float"/>
				<t path="Color"/>
				<t path="Image"/>
			</f>
			<meta><m n=":native"><e>"ImageTextEx"</e></m></meta>
		</imageTextEx>
		<imageFormat public="1" set="method" static="1">
			<f a="image:newFormat">
				<t path="cpp.Star"><t path="Image"/></t>
				<x path="Int"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"ImageFormat"</e></m></meta>
		</imageFormat>
		<imageToPOT public="1" set="method" static="1">
			<f a="image:fill">
				<t path="cpp.Star"><t path="Image"/></t>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"ImageToPOT"</e></m></meta>
		</imageToPOT>
		<imageCrop public="1" set="method" static="1">
			<f a="image:crop">
				<t path="cpp.Star"><t path="Image"/></t>
				<t path="Rectangle"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"ImageCrop"</e></m></meta>
		</imageCrop>
		<imageAlphaCrop public="1" set="method" static="1">
			<f a="image:threshold">
				<t path="cpp.Star"><t path="Image"/></t>
				<x path="Float"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"ImageAlphaCrop"</e></m></meta>
		</imageAlphaCrop>
		<imageAlphaClear public="1" set="method" static="1">
			<f a="image:threshold">
				<t path="cpp.Star"><t path="Image"/></t>
				<x path="Float"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"ImageAlphaClear"</e></m></meta>
		</imageAlphaClear>
		<imageAlphaMask public="1" set="method" static="1">
			<f a="image:alphaMask">
				<t path="cpp.Star"><t path="Image"/></t>
				<t path="Image"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"ImageAlphaMask"</e></m></meta>
		</imageAlphaMask>
		<imageAlphaPremultiply public="1" set="method" static="1">
			<f a="image">
				<t path="cpp.Star"><t path="Image"/></t>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"ImageAlphaPremultiply"</e></m></meta>
		</imageAlphaPremultiply>
		<imageResize public="1" set="method" static="1">
			<f a="image:newWidth:newHeight">
				<t path="cpp.Star"><t path="Image"/></t>
				<x path="Int"/>
				<x path="Int"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"ImageResize"</e></m></meta>
		</imageResize>
		<imageResizeNN public="1" set="method" static="1">
			<f a="image:newWidth:newHeight">
				<t path="cpp.Star"><t path="Image"/></t>
				<x path="Int"/>
				<x path="Int"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"ImageResizeNN"</e></m></meta>
		</imageResizeNN>
		<imageResizeCanvas public="1" set="method" static="1">
			<f a="image:newWidth:newHeight:offsetX:offsetY:fill">
				<t path="cpp.Star"><t path="Image"/></t>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"ImageResizeCanvas"</e></m></meta>
		</imageResizeCanvas>
		<imageMipmaps public="1" set="method" static="1">
			<f a="image">
				<t path="cpp.Star"><t path="Image"/></t>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"ImageMipmaps"</e></m></meta>
		</imageMipmaps>
		<imageDither public="1" set="method" static="1">
			<f a="image:rBpp:gBpp:bBpp:aBpp">
				<t path="cpp.Star"><t path="Image"/></t>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"ImageDither"</e></m></meta>
		</imageDither>
		<imageFlipVertical public="1" set="method" static="1">
			<f a="image">
				<t path="cpp.Star"><t path="Image"/></t>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"ImageFlipVertical"</e></m></meta>
		</imageFlipVertical>
		<imageFlipHorizontal public="1" set="method" static="1">
			<f a="image">
				<t path="cpp.Star"><t path="Image"/></t>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"ImageFlipHorizontal"</e></m></meta>
		</imageFlipHorizontal>
		<imageRotateCW public="1" set="method" static="1">
			<f a="image">
				<t path="cpp.Star"><t path="Image"/></t>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"ImageRotateCW"</e></m></meta>
		</imageRotateCW>
		<imageRotateCCW public="1" set="method" static="1">
			<f a="image">
				<t path="cpp.Star"><t path="Image"/></t>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"ImageRotateCCW"</e></m></meta>
		</imageRotateCCW>
		<imageColorTint public="1" set="method" static="1">
			<f a="image:color">
				<t path="cpp.Star"><t path="Image"/></t>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"ImageColorTint"</e></m></meta>
		</imageColorTint>
		<imageColorInvert public="1" set="method" static="1">
			<f a="image">
				<t path="cpp.Star"><t path="Image"/></t>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"ImageColorInvert"</e></m></meta>
		</imageColorInvert>
		<imageColorGrayscale public="1" set="method" static="1">
			<f a="image">
				<t path="cpp.Star"><t path="Image"/></t>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"ImageColorGrayscale"</e></m></meta>
		</imageColorGrayscale>
		<imageColorContrast public="1" set="method" static="1">
			<f a="image:contrast">
				<t path="cpp.Star"><t path="Image"/></t>
				<x path="Float"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"ImageColorContrast"</e></m></meta>
		</imageColorContrast>
		<imageColorBrightness public="1" set="method" static="1">
			<f a="image:brightness">
				<t path="cpp.Star"><t path="Image"/></t>
				<x path="Int"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"ImageColorBrightness"</e></m></meta>
		</imageColorBrightness>
		<imageColorReplace public="1" set="method" static="1">
			<f a="image:color:replace">
				<t path="cpp.Star"><t path="Image"/></t>
				<t path="Color"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"ImageColorReplace"</e></m></meta>
		</imageColorReplace>
		<loadImageColors public="1" set="method" static="1">
			<f a="image">
				<t path="Image"/>
				<t path="cpp.Star"><t path="Color"/></t>
			</f>
			<meta><m n=":native"><e>"LoadImageColors"</e></m></meta>
		</loadImageColors>
		<loadImagePalette public="1" set="method" static="1">
			<f a="image:maxPaletteSize:colorsCount">
				<t path="Image"/>
				<x path="Int"/>
				<t path="cpp.Star"><x path="Int"/></t>
				<t path="cpp.Star"><t path="Color"/></t>
			</f>
			<meta><m n=":native"><e>"LoadImagePalette"</e></m></meta>
		</loadImagePalette>
		<unloadImageColors public="1" set="method" static="1">
			<f a="colors">
				<t path="cpp.Star"><t path="Color"/></t>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"UnloadImageColors"</e></m></meta>
		</unloadImageColors>
		<unloadImagePalette public="1" set="method" static="1">
			<f a="colors">
				<t path="cpp.Star"><t path="Color"/></t>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"UnloadImagePalette"</e></m></meta>
		</unloadImagePalette>
		<getImageAlphaBorder public="1" set="method" static="1">
			<f a="image:threshold">
				<t path="Image"/>
				<x path="Float"/>
				<t path="Rectangle"/>
			</f>
			<meta><m n=":native"><e>"GetImageAlphaBorder"</e></m></meta>
		</getImageAlphaBorder>
		<getImageColor public="1" set="method" static="1">
			<f a="image:x:y">
				<t path="Image"/>
				<x path="Int"/>
				<x path="Int"/>
				<t path="Color"/>
			</f>
			<meta><m n=":native"><e>"GetImageColor"</e></m></meta>
		</getImageColor>
		<imageClearBackground public="1" set="method" static="1">
			<f a="dst:color">
				<t path="cpp.Star"><t path="Image"/></t>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"ImageClearBackground"</e></m></meta>
		</imageClearBackground>
		<imageDrawPixel public="1" set="method" static="1">
			<f a="dst:posX:posY:color">
				<t path="cpp.Star"><t path="Image"/></t>
				<x path="Int"/>
				<x path="Int"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"ImageDrawPixel"</e></m></meta>
		</imageDrawPixel>
		<imageDrawPixelV public="1" set="method" static="1">
			<f a="dst:position:color">
				<t path="cpp.Star"><t path="Image"/></t>
				<t path="Vector2"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"ImageDrawPixelV"</e></m></meta>
		</imageDrawPixelV>
		<imageDrawLine public="1" set="method" static="1">
			<f a="dst:startPosX:startPosY:endPosX:endPosY:color">
				<t path="cpp.Star"><t path="Image"/></t>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"ImageDrawLine"</e></m></meta>
		</imageDrawLine>
		<imageDrawLineV public="1" set="method" static="1">
			<f a="dst:start:end:color">
				<t path="cpp.Star"><t path="Image"/></t>
				<t path="Vector2"/>
				<t path="Vector2"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"ImageDrawLineV"</e></m></meta>
		</imageDrawLineV>
		<imageDrawCircle public="1" set="method" static="1">
			<f a="dst:centerX:centerY:radius:color">
				<t path="cpp.Star"><t path="Image"/></t>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"ImageDrawCircle"</e></m></meta>
		</imageDrawCircle>
		<imageDrawCircleV public="1" set="method" static="1">
			<f a="dst:center:radius:color">
				<t path="cpp.Star"><t path="Image"/></t>
				<t path="Vector2"/>
				<x path="Int"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"ImageDrawCircleV"</e></m></meta>
		</imageDrawCircleV>
		<imageDrawRectangle public="1" set="method" static="1">
			<f a="dst:posX:posY:width:height:color">
				<t path="cpp.Star"><t path="Image"/></t>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"ImageDrawRectangle"</e></m></meta>
		</imageDrawRectangle>
		<imageDrawRectangleV public="1" set="method" static="1">
			<f a="dst:position:size:color">
				<t path="cpp.Star"><t path="Image"/></t>
				<t path="Vector2"/>
				<t path="Vector2"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"ImageDrawRectangleV"</e></m></meta>
		</imageDrawRectangleV>
		<imageDrawRectangleRec public="1" set="method" static="1">
			<f a="dst:rec:color">
				<t path="cpp.Star"><t path="Image"/></t>
				<t path="Rectangle"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"ImageDrawRectangleRec"</e></m></meta>
		</imageDrawRectangleRec>
		<imageDrawRectangleLines public="1" set="method" static="1">
			<f a="dst:rec:thick:color">
				<t path="cpp.Star"><t path="Image"/></t>
				<t path="Rectangle"/>
				<x path="Int"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"ImageDrawRectangleLines"</e></m></meta>
		</imageDrawRectangleLines>
		<imageDraw public="1" set="method" static="1">
			<f a="dst:src:srcRec:dstRec:tint">
				<t path="cpp.Star"><t path="Image"/></t>
				<t path="Image"/>
				<t path="Rectangle"/>
				<t path="Rectangle"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"ImageDraw"</e></m></meta>
		</imageDraw>
		<imageDrawText public="1" set="method" static="1">
			<f a="dst:text:posX:posY:fontSize:color">
				<t path="cpp.Star"><t path="Image"/></t>
				<x path="cpp.ConstCharStar"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"ImageDrawText"</e></m></meta>
		</imageDrawText>
		<imageDrawTextEx public="1" set="method" static="1">
			<f a="dst:font:text:position:fontSize:spacing:tint">
				<t path="cpp.Star"><t path="Image"/></t>
				<c path="Font"/>
				<x path="cpp.ConstCharStar"/>
				<t path="Vector2"/>
				<x path="Float"/>
				<x path="Float"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"ImageDrawTextEx"</e></m></meta>
		</imageDrawTextEx>
		<loadTexture public="1" set="method" static="1">
			<f a="fileName">
				<x path="cpp.ConstCharStar"/>
				<t path="Texture2D"/>
			</f>
			<meta><m n=":native"><e>"LoadTexture"</e></m></meta>
		</loadTexture>
		<loadTextureFromImage public="1" set="method" static="1">
			<f a="image">
				<t path="Image"/>
				<t path="Texture2D"/>
			</f>
			<meta><m n=":native"><e>"LoadTextureFromImage"</e></m></meta>
		</loadTextureFromImage>
		<loadTextureCubemap public="1" set="method" static="1">
			<f a="image:layout">
				<t path="Image"/>
				<x path="Int"/>
				<t path="TextureCubemap"/>
			</f>
			<meta><m n=":native"><e>"LoadTextureCubemap"</e></m></meta>
		</loadTextureCubemap>
		<loadRenderTexture public="1" set="method" static="1">
			<f a="width:height">
				<x path="Int"/>
				<x path="Int"/>
				<t path="RenderTexture2D"/>
			</f>
			<meta><m n=":native"><e>"LoadRenderTexture"</e></m></meta>
		</loadRenderTexture>
		<unloadTexture public="1" set="method" static="1">
			<f a="texture">
				<t path="Texture2D"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"UnloadTexture"</e></m></meta>
		</unloadTexture>
		<unloadRenderTexture public="1" set="method" static="1">
			<f a="texture">
				<t path="RenderTexture2D"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"UnloadRenderTexture"</e></m></meta>
		</unloadRenderTexture>
		<updateTexture public="1" set="method" static="1">
			<f a="texture:pixels">
				<t path="Texture2D"/>
				<t path="cpp.ConstStar"><c path="cpp.Void"/></t>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"UpdateTexture"</e></m></meta>
		</updateTexture>
		<updateTextureRec public="1" set="method" static="1">
			<f a="texture:rec:pixels">
				<t path="Texture2D"/>
				<t path="Rectangle"/>
				<t path="cpp.ConstStar"><c path="cpp.Void"/></t>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"UpdateTextureRec"</e></m></meta>
		</updateTextureRec>
		<genTextureMipmaps public="1" set="method" static="1">
			<f a="texture">
				<t path="cpp.Star"><t path="Texture2D"/></t>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"GenTextureMipmaps"</e></m></meta>
		</genTextureMipmaps>
		<setTextureFilter public="1" set="method" static="1">
			<f a="texture:filter">
				<t path="Texture2D"/>
				<x path="Int"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"SetTextureFilter"</e></m></meta>
		</setTextureFilter>
		<setTextureWrap public="1" set="method" static="1">
			<f a="texture:wrap">
				<t path="Texture2D"/>
				<x path="Int"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"SetTextureWrap"</e></m></meta>
		</setTextureWrap>
		<drawTexture public="1" set="method" static="1">
			<f a="texture:posX:posy:tint">
				<t path="Texture2D"/>
				<x path="Int"/>
				<x path="Int"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawTexture"</e></m></meta>
		</drawTexture>
		<drawTextureV public="1" set="method" static="1">
			<f a="texture:position:tint">
				<t path="Texture2D"/>
				<t path="Vector2"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawTextureV"</e></m></meta>
		</drawTextureV>
		<drawTextureEx public="1" set="method" static="1">
			<f a="texture:position:rotation:scale:tint">
				<t path="Texture2D"/>
				<t path="Vector2"/>
				<x path="Float"/>
				<x path="Float"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawTextureEx"</e></m></meta>
		</drawTextureEx>
		<drawTextureRec public="1" set="method" static="1">
			<f a="texture:source:position:tint">
				<t path="Texture2D"/>
				<t path="Rectangle"/>
				<t path="Vector2"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawTextureRec"</e></m></meta>
		</drawTextureRec>
		<drawTextureQuad public="1" set="method" static="1">
			<f a="texture:tiling:offset:quad:tint">
				<t path="Texture2D"/>
				<t path="Vector2"/>
				<t path="Vector2"/>
				<t path="Rectangle"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawTextureQuad"</e></m></meta>
		</drawTextureQuad>
		<drawTextureTiled public="1" set="method" static="1">
			<f a="texture:source:dest:origin:rotation:scale:tint">
				<t path="Texture2D"/>
				<t path="Rectangle"/>
				<t path="Rectangle"/>
				<t path="Vector2"/>
				<x path="Float"/>
				<x path="Float"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawTextureTiled"</e></m></meta>
		</drawTextureTiled>
		<drawTexturePro public="1" set="method" static="1">
			<f a="texture:source:dest:origin:rotation:tint">
				<t path="Texture2D"/>
				<t path="Rectangle"/>
				<t path="Rectangle"/>
				<t path="Vector2"/>
				<x path="Float"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawTexturePro"</e></m></meta>
		</drawTexturePro>
		<drawTextureNPatch public="1" set="method" static="1">
			<f a="texture:nPatchInfo:dest:origin:rotation:tint">
				<t path="Texture2D"/>
				<c path="NPatchInfo"/>
				<t path="Rectangle"/>
				<t path="Vector2"/>
				<x path="Float"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawTextureNPatch"</e></m></meta>
		</drawTextureNPatch>
		<drawTexturePoly public="1" set="method" static="1">
			<f a="texture:center:points:texcoords:pointsCount:tint">
				<t path="Texture2D"/>
				<t path="Vector2"/>
				<t path="cpp.Star"><t path="Vector2"/></t>
				<t path="cpp.Star"><t path="Vector2"/></t>
				<x path="Int"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawTexturePoly"</e></m></meta>
		</drawTexturePoly>
		<fade public="1" set="method" static="1">
			<f a="color:alpha">
				<t path="Color"/>
				<x path="Float"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"Fade"</e></m></meta>
		</fade>
		<colorToInt public="1" set="method" static="1">
			<f a="color">
				<t path="Color"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"ColorToInt"</e></m></meta>
		</colorToInt>
		<colorNormalize public="1" set="method" static="1">
			<f a="color">
				<t path="Color"/>
				<t path="Vector4"/>
			</f>
			<meta><m n=":native"><e>"ColorNormalize"</e></m></meta>
		</colorNormalize>
		<colorFromNormalized public="1" set="method" static="1">
			<f a="normalized">
				<t path="Vector4"/>
				<t path="Color"/>
			</f>
			<meta><m n=":native"><e>"ColorFromNormalized"</e></m></meta>
		</colorFromNormalized>
		<colorToHSV public="1" set="method" static="1">
			<f a="color">
				<t path="Color"/>
				<t path="Vector3"/>
			</f>
			<meta><m n=":native"><e>"ColorToHSV"</e></m></meta>
		</colorToHSV>
		<colorFromHSV public="1" set="method" static="1">
			<f a="hue:saturation:Value">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<t path="Color"/>
			</f>
			<meta><m n=":native"><e>"ColorFromHSV"</e></m></meta>
		</colorFromHSV>
		<colorAlpha public="1" set="method" static="1">
			<f a="color:alpha">
				<t path="Color"/>
				<x path="Float"/>
				<t path="Color"/>
			</f>
			<meta><m n=":native"><e>"ColorAlpha"</e></m></meta>
		</colorAlpha>
		<colorAlphaBlend public="1" set="method" static="1">
			<f a="dst:src:tint">
				<t path="Color"/>
				<t path="Color"/>
				<t path="Color"/>
				<t path="Color"/>
			</f>
			<meta><m n=":native"><e>"ColorAlphaBlend"</e></m></meta>
		</colorAlphaBlend>
		<getColor public="1" set="method" static="1">
			<f a="hexValue">
				<x path="UInt"/>
				<t path="Color"/>
			</f>
			<meta><m n=":native"><e>"GetColor"</e></m></meta>
		</getColor>
		<getPixelColor public="1" set="method" static="1">
			<f a="srcPtr:format">
				<t path="cpp.Star"><c path="cpp.Void"/></t>
				<x path="PixelFormat"/>
				<t path="Color"/>
			</f>
			<meta><m n=":native"><e>"GetPixelColor"</e></m></meta>
		</getPixelColor>
		<setPixelColor public="1" set="method" static="1">
			<f a="dstPtr:color:format">
				<t path="cpp.Star"><c path="cpp.Void"/></t>
				<t path="Color"/>
				<x path="Int"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"SetPixelColor"</e></m></meta>
		</setPixelColor>
		<getPixelDataSize public="1" set="method" static="1">
			<f a="width:height:format">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"GetPixelDataSize"</e></m></meta>
		</getPixelDataSize>
		<getFontDefault public="1" set="method" static="1">
			<f a=""><c path="cpp.Void"/></f>
			<meta><m n=":native"><e>"GetFontDefault"</e></m></meta>
		</getFontDefault>
		<loadFont public="1" set="method" static="1">
			<f a="fileName">
				<x path="cpp.ConstCharStar"/>
				<c path="Font"/>
			</f>
			<meta><m n=":native"><e>"LoadFont"</e></m></meta>
		</loadFont>
		<loadFontEx public="1" set="method" static="1">
			<f a="fileName:fontSize:fontChars:glyphCount">
				<x path="cpp.ConstCharStar"/>
				<x path="Int"/>
				<t path="cpp.Star"><x path="Int"/></t>
				<x path="Int"/>
				<c path="Font"/>
			</f>
			<meta><m n=":native"><e>"LoadFontEx"</e></m></meta>
		</loadFontEx>
		<loadFontFromImage public="1" set="method" static="1">
			<f a="image:key:firstChar">
				<t path="Image"/>
				<t path="Color"/>
				<x path="Int"/>
				<c path="Font"/>
			</f>
			<meta><m n=":native"><e>"LoadFontFromImage"</e></m></meta>
		</loadFontFromImage>
		<loadFontFromMemory public="1" set="method" static="1">
			<f a="fileType:fileData:dataSize:fontSize:fontChars:glyphCount">
				<x path="cpp.ConstCharStar"/>
				<t path="cpp.Star"><x path="cpp.UInt8"/></t>
				<x path="Int"/>
				<x path="Int"/>
				<t path="cpp.Star"><x path="Int"/></t>
				<x path="Int"/>
				<c path="Font"/>
			</f>
			<meta><m n=":native"><e>"LoadFontFromMemory"</e></m></meta>
		</loadFontFromMemory>
		<loadFontData public="1" set="method" static="1">
			<f a="fileData:dataSize:fontSize:fontChars:glyphCount:type">
				<t path="cpp.ConstStar"><x path="cpp.UInt8"/></t>
				<x path="Int"/>
				<x path="Int"/>
				<t path="cpp.Star"><x path="Int"/></t>
				<x path="Int"/>
				<x path="Int"/>
				<c path="GlyphInfo"/>
			</f>
			<meta><m n=":native"><e>"LoadFontData"</e></m></meta>
		</loadFontData>
		<genImageFontAtlas public="1" set="method" static="1">
			<f a="chars:recs:glyphCount:fontSize:padding:packMethod">
				<t path="cpp.ConstStar"><c path="GlyphInfo"/></t>
				<t path="cpp.Star"><t path="cpp.Star"><t path="Rectangle"/></t></t>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<t path="Image"/>
			</f>
			<meta><m n=":native"><e>"GenImageFontAtlas"</e></m></meta>
		</genImageFontAtlas>
		<unloadFontData public="1" set="method" static="1">
			<f a="chars:glyphCount">
				<t path="cpp.Star"><c path="GlyphInfo"/></t>
				<x path="Int"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"UnloadFontData"</e></m></meta>
		</unloadFontData>
		<unloadFont public="1" set="method" static="1">
			<f a="font">
				<c path="Font"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"UnloadFont"</e></m></meta>
		</unloadFont>
		<drawFPS public="1" set="method" static="1">
			<f a="posX:posY">
				<x path="Int"/>
				<x path="Int"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawFPS"</e></m></meta>
		</drawFPS>
		<drawText public="1" set="method" static="1">
			<f a="text:posX:posY:FontSize:color">
				<x path="cpp.ConstCharStar"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawText"</e></m></meta>
		</drawText>
		<drawTextEx public="1" set="method" static="1">
			<f a="font:text:position:fontSize:spacing:tint">
				<c path="Font"/>
				<x path="cpp.ConstCharStar"/>
				<t path="Vector2"/>
				<x path="Float"/>
				<x path="Float"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawTextEx"</e></m></meta>
		</drawTextEx>
		<drawTextPro public="1" set="method" static="1">
			<f a="font:text:position:origin:rotation:fontSize:spacing:tint">
				<c path="Font"/>
				<x path="cpp.ConstCharStar"/>
				<t path="Vector2"/>
				<t path="Vector2"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawTextPro"</e></m></meta>
		</drawTextPro>
		<drawTextCodePoint public="1" set="method" static="1">
			<f a="font:codepoint:position:fontSize:tint">
				<c path="Font"/>
				<x path="Int"/>
				<t path="Vector2"/>
				<x path="Float"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawTextCodePoint"</e></m></meta>
		</drawTextCodePoint>
		<measureText public="1" set="method" static="1">
			<f a="text:fontSize">
				<x path="cpp.ConstCharStar"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"MeasureText"</e></m></meta>
		</measureText>
		<measureTextEx public="1" set="method" static="1">
			<f a="font:text:fontsize:tint">
				<c path="Font"/>
				<x path="cpp.ConstCharStar"/>
				<x path="Float"/>
				<t path="Color"/>
				<t path="Vector2"/>
			</f>
			<meta><m n=":native"><e>"MeasureTextEx"</e></m></meta>
		</measureTextEx>
		<getGlyphIndex public="1" set="method" static="1">
			<f a="font:codepoint">
				<c path="Font"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"GetGlyphIndex"</e></m></meta>
		</getGlyphIndex>
		<getGlyphInfo public="1" set="method" static="1">
			<f a="font:codepoint">
				<c path="Font"/>
				<x path="Int"/>
				<c path="GlyphInfo"/>
			</f>
			<meta><m n=":native"><e>"GetGlyphInfo"</e></m></meta>
		</getGlyphInfo>
		<getGlyphAtlasRec public="1" set="method" static="1">
			<f a="font:codepoint">
				<c path="Font"/>
				<x path="Int"/>
				<t path="Rectangle"/>
			</f>
			<meta><m n=":native"><e>"GetGlyphAtlasRec"</e></m></meta>
		</getGlyphAtlasRec>
		<drawLine3D public="1" set="method" static="1">
			<f a="startPos:endPos:color">
				<t path="Vector3"/>
				<t path="Vector3"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawLine3D"</e></m></meta>
		</drawLine3D>
		<drawPoint3D public="1" set="method" static="1">
			<f a="position:color">
				<t path="Vector3"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawPoint3D"</e></m></meta>
		</drawPoint3D>
		<drawCircle3D public="1" set="method" static="1">
			<f a="center:radius:rotationAxis:rotationAngle:color">
				<t path="Vector3"/>
				<x path="Float"/>
				<t path="Vector3"/>
				<x path="Float"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawCircle3D"</e></m></meta>
		</drawCircle3D>
		<drawTriangle3D public="1" set="method" static="1">
			<f a="v1:v2:v3:color">
				<t path="Vector3"/>
				<t path="Vector3"/>
				<t path="Vector3"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawTriangle3D"</e></m></meta>
		</drawTriangle3D>
		<drawTriangleStrip3D public="1" set="method" static="1">
			<f a="points:pointsCount:color">
				<t path="cpp.Star"><t path="Vector3"/></t>
				<x path="Int"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawTriangleStrip3D"</e></m></meta>
		</drawTriangleStrip3D>
		<drawCube public="1" set="method" static="1">
			<f a="position:width:height:length:color">
				<t path="Vector3"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawCube"</e></m></meta>
		</drawCube>
		<drawCubeV public="1" set="method" static="1">
			<f a="position:size:color">
				<t path="Vector3"/>
				<t path="Vector3"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawCubeV"</e></m></meta>
		</drawCubeV>
		<drawCubeWires public="1" set="method" static="1">
			<f a="position:width:height:length:color">
				<t path="Vector3"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawCubeWires"</e></m></meta>
		</drawCubeWires>
		<drawCubeWiresV public="1" set="method" static="1">
			<f a="position:size:color">
				<t path="Vector3"/>
				<t path="Vector3"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawCubeWiresV"</e></m></meta>
		</drawCubeWiresV>
		<drawCubeTexture public="1" set="method" static="1">
			<f a="texture:position:width:height:length:color">
				<t path="Texture2D"/>
				<t path="Vector3"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawCubeTexture"</e></m></meta>
		</drawCubeTexture>
		<drawCubeTextureRec public="1" set="method" static="1">
			<f a="texture:source:position:width:height:length:color">
				<t path="Texture2D"/>
				<t path="Rectangle"/>
				<t path="Vector3"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawCubeTextureRec"</e></m></meta>
		</drawCubeTextureRec>
		<drawSphere public="1" set="method" static="1">
			<f a="centerPos:radius:color">
				<t path="Vector3"/>
				<x path="Float"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawSphere"</e></m></meta>
		</drawSphere>
		<drawSphereEx public="1" set="method" static="1">
			<f a="centerPos:radius:rings:slices:color">
				<t path="Vector3"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawSphereEx"</e></m></meta>
		</drawSphereEx>
		<drawSphereWires public="1" set="method" static="1">
			<f a="centerPos:radius:rings:slices:color">
				<t path="Vector3"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawSphereWires"</e></m></meta>
		</drawSphereWires>
		<drawCylinder public="1" set="method" static="1">
			<f a="position:radiusTop:radiusBottom:height:slices:color">
				<t path="Vector3"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawCylinder"</e></m></meta>
		</drawCylinder>
		<drawCylinderEx public="1" set="method" static="1">
			<f a="startPos:endPos:startRadius:endRadius:sides:color">
				<t path="Vector3"/>
				<t path="Vector3"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawCylinderEx"</e></m></meta>
		</drawCylinderEx>
		<drawCylinderWires public="1" set="method" static="1">
			<f a="position:radiusTop:radiusBottom:height:slices:color">
				<t path="Vector3"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawCylinderWires"</e></m></meta>
		</drawCylinderWires>
		<drawCylinderWiresEx public="1" set="method" static="1">
			<f a="startPos:endPos:startRadius:endRadius:sides:color">
				<t path="Vector3"/>
				<t path="Vector3"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawCylinderWiresEx"</e></m></meta>
		</drawCylinderWiresEx>
		<drawPlane public="1" set="method" static="1">
			<f a="centerPos:size:color">
				<t path="Vector3"/>
				<t path="Vector2"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawPlane"</e></m></meta>
		</drawPlane>
		<drawRay public="1" set="method" static="1">
			<f a="ray:color">
				<c path="Ray"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawRay"</e></m></meta>
		</drawRay>
		<drawGrid public="1" set="method" static="1">
			<f a="slices:spacing">
				<x path="Int"/>
				<x path="Float"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawGrid"</e></m></meta>
		</drawGrid>
		<loadModel public="1" set="method" static="1">
			<f a="fileName">
				<x path="cpp.ConstCharStar"/>
				<c path="Model"/>
			</f>
			<meta><m n=":native"><e>"LoadModel"</e></m></meta>
		</loadModel>
		<loadModelFromMesh public="1" set="method" static="1">
			<f a="mesh">
				<c path="Mesh"/>
				<c path="Model"/>
			</f>
			<meta><m n=":native"><e>"LoadModelFromMesh"</e></m></meta>
		</loadModelFromMesh>
		<unloadModel public="1" set="method" static="1">
			<f a="model">
				<c path="Model"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"UnloadModel"</e></m></meta>
		</unloadModel>
		<unloadModelKeepMeshes public="1" set="method" static="1">
			<f a="model">
				<c path="Model"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"UnloadModelKeepMeshes"</e></m></meta>
		</unloadModelKeepMeshes>
		<getModelBoundingBox public="1" set="method" static="1">
			<f a="model">
				<c path="Model"/>
				<c path="BoundingBox"/>
			</f>
			<meta><m n=":native"><e>"GetModelBoundingBox"</e></m></meta>
		</getModelBoundingBox>
		<drawModel public="1" set="method" static="1">
			<f a="model:position:scale:tint">
				<c path="Model"/>
				<t path="Vector3"/>
				<x path="Float"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawModel"</e></m></meta>
		</drawModel>
		<drawModelEx public="1" set="method" static="1">
			<f a="model:position:rotationAxis:rotationAngle:scale:color">
				<c path="Model"/>
				<t path="Vector3"/>
				<t path="Vector3"/>
				<x path="Float"/>
				<t path="Vector3"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawModelEx"</e></m></meta>
		</drawModelEx>
		<drawModelWires public="1" set="method" static="1">
			<f a="model:position:scale:tint">
				<c path="Model"/>
				<t path="Vector3"/>
				<x path="Float"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawModelWires"</e></m></meta>
		</drawModelWires>
		<drawModelWiresEx public="1" set="method" static="1">
			<f a="model:position:rotationAxis:rotationAngle:scale:color">
				<c path="Model"/>
				<t path="Vector3"/>
				<t path="Vector3"/>
				<x path="Float"/>
				<t path="Vector3"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawModelWiresEx"</e></m></meta>
		</drawModelWiresEx>
		<drawBoundingBox public="1" set="method" static="1">
			<f a="box:color">
				<c path="BoundingBox"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawBoundingBox"</e></m></meta>
		</drawBoundingBox>
		<drawBillboard public="1" set="method" static="1">
			<f a="camera:texture:position:size:tint">
				<t path="Camera"/>
				<t path="Texture2D"/>
				<t path="Vector3"/>
				<x path="Float"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawBillboard"</e></m></meta>
		</drawBillboard>
		<drawBillboardRec public="1" set="method" static="1">
			<f a="camera:texture:source:position:size:tint">
				<t path="Camera"/>
				<t path="Texture2D"/>
				<t path="Rectangle"/>
				<t path="Vector3"/>
				<t path="Vector2"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawBillboardRec"</e></m></meta>
		</drawBillboardRec>
		<drawBillboardPro public="1" set="method" static="1">
			<f a="camera:texture:source:position:up:size:origin:rotation:tint">
				<t path="Camera"/>
				<t path="Texture2D"/>
				<t path="Rectangle"/>
				<t path="Vector3"/>
				<t path="Vector3"/>
				<t path="Vector2"/>
				<t path="Vector2"/>
				<x path="Float"/>
				<t path="Color"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawBillboardPro"</e></m></meta>
		</drawBillboardPro>
		<uploadMesh public="1" set="method" static="1">
			<f a="mesh:dyn">
				<t path="cpp.Star"><c path="Mesh"/></t>
				<x path="Bool"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"UploadMesh"</e></m></meta>
		</uploadMesh>
		<updateMeshBuffer public="1" set="method" static="1">
			<f a="mesh:index:data:dataSize:offset">
				<c path="Mesh"/>
				<x path="Int"/>
				<t path="cpp.Star"><c path="cpp.Void"/></t>
				<x path="Int"/>
				<x path="Int"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"UpdateMeshBuffer"</e></m></meta>
		</updateMeshBuffer>
		<unloadMesh public="1" set="method" static="1">
			<f a="mesh">
				<c path="Mesh"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"UnloadMesh"</e></m></meta>
		</unloadMesh>
		<drawMesh public="1" set="method" static="1">
			<f a="mesh:material:transform">
				<c path="Mesh"/>
				<c path="Material"/>
				<t path="Matrix"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawMesh"</e></m></meta>
		</drawMesh>
		<drawMeshInstanced public="1" set="method" static="1">
			<f a="mesh:material:transforms:instances">
				<c path="Mesh"/>
				<c path="Material"/>
				<t path="cpp.Star"><t path="Matrix"/></t>
				<x path="Int"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"DrawMeshInstanced"</e></m></meta>
		</drawMeshInstanced>
		<exportMesh public="1" set="method" static="1">
			<f a="mesh:fileName">
				<c path="Mesh"/>
				<x path="cpp.ConstCharStar"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"ExportMesh"</e></m></meta>
		</exportMesh>
		<getMeshBoundingBox public="1" set="method" static="1">
			<f a="mesh">
				<c path="Mesh"/>
				<c path="BoundingBox"/>
			</f>
			<meta><m n=":native"><e>"GetMeshBoundingBox"</e></m></meta>
		</getMeshBoundingBox>
		<getMeshTangents public="1" set="method" static="1">
			<f a="mesh">
				<t path="cpp.Star"><c path="Mesh"/></t>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"GetMeshTangents"</e></m></meta>
		</getMeshTangents>
		<getMeshBinomials public="1" set="method" static="1">
			<f a="mesh">
				<t path="cpp.Star"><c path="Mesh"/></t>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"GetMeshBinomials"</e></m></meta>
		</getMeshBinomials>
		<genMeshPoly public="1" set="method" static="1">
			<f a="sides:radius">
				<x path="Int"/>
				<x path="Float"/>
				<c path="Mesh"/>
			</f>
			<meta><m n=":native"><e>"GenMeshPoly"</e></m></meta>
		</genMeshPoly>
		<genMeshPlane public="1" set="method" static="1">
			<f a="width:length:resX:resZ">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="Mesh"/>
			</f>
			<meta><m n=":native"><e>"GenMeshPlane"</e></m></meta>
		</genMeshPlane>
		<genMeshCube public="1" set="method" static="1">
			<f a="width:height:length">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="Mesh"/>
			</f>
			<meta><m n=":native"><e>"GenMeshCube"</e></m></meta>
		</genMeshCube>
		<genMeshSphere public="1" set="method" static="1">
			<f a="radius:rings:slices">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="Mesh"/>
			</f>
			<meta><m n=":native"><e>"GenMeshSphere"</e></m></meta>
		</genMeshSphere>
		<genMeshHemiSphere public="1" set="method" static="1">
			<f a="radius:rings:slices">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="Mesh"/>
			</f>
			<meta><m n=":native"><e>"GenMeshHemiSphere"</e></m></meta>
		</genMeshHemiSphere>
		<genMeshCylinder public="1" set="method" static="1">
			<f a="radius:rings:slices">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="Mesh"/>
			</f>
			<meta><m n=":native"><e>"GenMeshCylinder"</e></m></meta>
		</genMeshCylinder>
		<genMeshCone public="1" set="method" static="1">
			<f a="radius:rings:slices">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="Mesh"/>
			</f>
			<meta><m n=":native"><e>"GenMeshCone"</e></m></meta>
		</genMeshCone>
		<genMeshTorus public="1" set="method" static="1">
			<f a="radius:size:radSeg:sides">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="Mesh"/>
			</f>
			<meta><m n=":native"><e>"GenMeshTorus"</e></m></meta>
		</genMeshTorus>
		<genMeshKnot public="1" set="method" static="1">
			<f a="radius:size:radSeg:sides">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="Mesh"/>
			</f>
			<meta><m n=":native"><e>"GenMeshKnot"</e></m></meta>
		</genMeshKnot>
		<genMeshHeightMap public="1" set="method" static="1">
			<f a="heightMap:size">
				<t path="Image"/>
				<t path="Vector3"/>
				<c path="Mesh"/>
			</f>
			<meta><m n=":native"><e>"GenMeshHeightMap"</e></m></meta>
		</genMeshHeightMap>
		<genMeshCubicMap public="1" set="method" static="1">
			<f a="cubicmap:cubeSize">
				<t path="Image"/>
				<t path="Vector3"/>
				<c path="Mesh"/>
			</f>
			<meta><m n=":native"><e>"GenMeshCubicMap"</e></m></meta>
		</genMeshCubicMap>
		<loadMaterials public="1" set="method" static="1">
			<f a="fileName:materialCount">
				<x path="cpp.ConstCharStar"/>
				<t path="cpp.Star"><x path="Int"/></t>
				<t path="cpp.Star"><c path="Material"/></t>
			</f>
			<meta><m n=":native"><e>"LoadMaterials"</e></m></meta>
		</loadMaterials>
		<loadMaterialDefault public="1" set="method" static="1">
			<f a=""><c path="Material"/></f>
			<meta><m n=":native"><e>"LoadMaterialDefault"</e></m></meta>
		</loadMaterialDefault>
		<unloadMaterial public="1" set="method" static="1">
			<f a="material">
				<c path="Material"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"UnloadMaterial"</e></m></meta>
		</unloadMaterial>
		<setMaterialTexture public="1" set="method" static="1">
			<f a="material:mapType:texture">
				<t path="cpp.Star"><c path="Material"/></t>
				<x path="Int"/>
				<t path="Texture2D"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"SetMaterialTexture"</e></m></meta>
		</setMaterialTexture>
		<setModelMeshMaterial public="1" set="method" static="1">
			<f a="model:meshId:materialId">
				<t path="cpp.Star"><c path="Model"/></t>
				<x path="Int"/>
				<x path="Int"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"SetModelMeshMaterial"</e></m></meta>
		</setModelMeshMaterial>
		<loadModelAnimations public="1" set="method" static="1">
			<f a="fileName:animCount">
				<x path="cpp.ConstCharStar"/>
				<t path="cpp.Star"><x path="UInt"/></t>
				<t path="cpp.Star"><c path="ModelAnimation"/></t>
			</f>
			<meta><m n=":native"><e>"LoadModelAnimations"</e></m></meta>
		</loadModelAnimations>
		<updateModelAnimation public="1" set="method" static="1">
			<f a="model:anim:frame">
				<c path="Model"/>
				<c path="ModelAnimation"/>
				<x path="Int"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"UpdateModelAnimation"</e></m></meta>
		</updateModelAnimation>
		<unloadModelAnimation public="1" set="method" static="1">
			<f a="anim">
				<c path="ModelAnimation"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"UnloadModelAnimation"</e></m></meta>
		</unloadModelAnimation>
		<unloadModelAnimations public="1" set="method" static="1">
			<f a="animations:count">
				<t path="cpp.Star"><c path="ModelAnimation"/></t>
				<x path="UInt"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"UnloadModelAnimations"</e></m></meta>
		</unloadModelAnimations>
		<isModelAnimationValid public="1" set="method" static="1">
			<f a="model:anim">
				<c path="Model"/>
				<c path="ModelAnimation"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"IsModelAnimationValid"</e></m></meta>
		</isModelAnimationValid>
		<checkCollisionSpheres public="1" set="method" static="1">
			<f a="center1:radius1:center2:radius2">
				<t path="Vector3"/>
				<x path="Float"/>
				<t path="Vector3"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"CheckCollisionSpheres"</e></m></meta>
		</checkCollisionSpheres>
		<checkCollisionBoxes public="1" set="method" static="1">
			<f a="box1:box2">
				<c path="BoundingBox"/>
				<c path="BoundingBox"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"CheckCollisionBoxes"</e></m></meta>
		</checkCollisionBoxes>
		<checkCollisionBoxSphere public="1" set="method" static="1">
			<f a="box:center:radius">
				<c path="BoundingBox"/>
				<t path="Vector3"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"CheckCollisionBoxSphere"</e></m></meta>
		</checkCollisionBoxSphere>
		<getRayCollisionSphere public="1" set="method" static="1">
			<f a="ray:center:radius">
				<c path="Ray"/>
				<t path="Vector3"/>
				<x path="Float"/>
				<c path="RayCollision"/>
			</f>
			<meta><m n=":native"><e>"GetRayCollisionSphere"</e></m></meta>
		</getRayCollisionSphere>
		<getRayCollisionBox public="1" set="method" static="1">
			<f a="ray:box">
				<c path="Ray"/>
				<c path="BoundingBox"/>
				<c path="RayCollision"/>
			</f>
			<meta><m n=":native"><e>"GetRayCollisionBox"</e></m></meta>
		</getRayCollisionBox>
		<getRayCollisionModel public="1" set="method" static="1">
			<f a="ray:model">
				<c path="Ray"/>
				<c path="Model"/>
				<c path="RayCollision"/>
			</f>
			<meta><m n=":native"><e>"GetRayCollisionModel"</e></m></meta>
		</getRayCollisionModel>
		<getRayCollisionMesh public="1" set="method" static="1">
			<f a="ray:mesh:transform">
				<c path="Ray"/>
				<c path="Mesh"/>
				<t path="Matrix"/>
				<c path="RayCollision"/>
			</f>
			<meta><m n=":native"><e>"GetRayCollisionMesh"</e></m></meta>
		</getRayCollisionMesh>
		<getRayCollisionTriangle public="1" set="method" static="1">
			<f a="ray:p1:p2:p3">
				<c path="Ray"/>
				<t path="Vector3"/>
				<t path="Vector3"/>
				<t path="Vector3"/>
				<c path="RayCollision"/>
			</f>
			<meta><m n=":native"><e>"GetRayCollisionTriangle"</e></m></meta>
		</getRayCollisionTriangle>
		<getRayCollisionQuad public="1" set="method" static="1">
			<f a="ray:p1:p2:p3:p4">
				<c path="Ray"/>
				<t path="Vector3"/>
				<t path="Vector3"/>
				<t path="Vector3"/>
				<t path="Vector3"/>
				<c path="RayCollision"/>
			</f>
			<meta><m n=":native"><e>"GetRayCollisionQuad"</e></m></meta>
		</getRayCollisionQuad>
		<initAudioDevice public="1" set="method" static="1">
			<f a=""><c path="cpp.Void"/></f>
			<meta><m n=":native"><e>"InitAudioDevice"</e></m></meta>
		</initAudioDevice>
		<closeAudioDevice public="1" set="method" static="1">
			<f a=""><c path="cpp.Void"/></f>
			<meta><m n=":native"><e>"CloseAudioDevice"</e></m></meta>
		</closeAudioDevice>
		<isAudioDeviceReady public="1" set="method" static="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":native"><e>"IsAudioDeviceReady"</e></m></meta>
		</isAudioDeviceReady>
		<setMasterVolume public="1" set="method" static="1">
			<f a="volume">
				<x path="Float"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"SetMasterVolume"</e></m></meta>
		</setMasterVolume>
		<loadWave public="1" set="method" static="1">
			<f a="fileName">
				<x path="cpp.ConstCharStar"/>
				<c path="Wave"/>
			</f>
			<meta><m n=":native"><e>"LoadWave"</e></m></meta>
		</loadWave>
		<loadWaveFromMemory public="1" set="method" static="1">
			<f a="fileType:fileData:dataSize">
				<x path="cpp.ConstCharStar"/>
				<t path="cpp.Star"><x path="cpp.UInt8"/></t>
				<x path="Int"/>
				<c path="Wave"/>
			</f>
			<meta><m n=":native"><e>"LoadWaveFromMemory"</e></m></meta>
		</loadWaveFromMemory>
		<loadSound public="1" set="method" static="1">
			<f a="fileName">
				<x path="cpp.ConstCharStar"/>
				<c path="Sound"/>
			</f>
			<meta><m n=":native"><e>"LoadSound"</e></m></meta>
		</loadSound>
		<loadSoundFromWave public="1" set="method" static="1">
			<f a="wave">
				<c path="Wave"/>
				<c path="Sound"/>
			</f>
			<meta><m n=":native"><e>"LoadSoundFromWave"</e></m></meta>
		</loadSoundFromWave>
		<updateSound public="1" set="method" static="1">
			<f a="sound:data:samplesCount">
				<c path="Sound"/>
				<x path="cpp.ConstCharStar"/>
				<x path="Int"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"UpdateSound"</e></m></meta>
		</updateSound>
		<unloadWave public="1" set="method" static="1">
			<f a="wave">
				<c path="Wave"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"UnloadWave"</e></m></meta>
		</unloadWave>
		<unloadSound public="1" set="method" static="1">
			<f a="sound">
				<c path="Sound"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"UnloadSound"</e></m></meta>
		</unloadSound>
		<exportWave public="1" set="method" static="1">
			<f a="wave:fileName">
				<c path="Wave"/>
				<x path="cpp.ConstCharStar"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"ExportWave"</e></m></meta>
		</exportWave>
		<exportWaveAsCode public="1" set="method" static="1">
			<f a="wave:fileName">
				<c path="Wave"/>
				<x path="cpp.ConstCharStar"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"ExportWaveAsCode"</e></m></meta>
		</exportWaveAsCode>
		<playSound public="1" set="method" static="1">
			<f a="sound">
				<c path="Sound"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"PlaySound"</e></m></meta>
		</playSound>
		<stopSound public="1" set="method" static="1">
			<f a="sound">
				<c path="Sound"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"StopSound"</e></m></meta>
		</stopSound>
		<pauseSound public="1" set="method" static="1">
			<f a="sound">
				<c path="Sound"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"PauseSound"</e></m></meta>
		</pauseSound>
		<resumeSound public="1" set="method" static="1">
			<f a="sound">
				<c path="Sound"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"ResumeSound"</e></m></meta>
		</resumeSound>
		<playSoundMulti public="1" set="method" static="1">
			<f a="sound">
				<c path="Sound"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"PlaySoundMulti"</e></m></meta>
		</playSoundMulti>
		<stopSoundMulti public="1" set="method" static="1">
			<f a=""><c path="cpp.Void"/></f>
			<meta><m n=":native"><e>"StopSoundMulti"</e></m></meta>
		</stopSoundMulti>
		<getSoundsPlaying public="1" set="method" static="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":native"><e>"GetSoundsPlaying"</e></m></meta>
		</getSoundsPlaying>
		<isSoundPlaying public="1" set="method" static="1">
			<f a="sound">
				<c path="Sound"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"IsSoundPlaying"</e></m></meta>
		</isSoundPlaying>
		<setSoundVolume public="1" set="method" static="1">
			<f a="sound:volume">
				<c path="Sound"/>
				<x path="Float"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"SetSoundVolume"</e></m></meta>
		</setSoundVolume>
		<setSoundPitch public="1" set="method" static="1">
			<f a="sound:pitch">
				<c path="Sound"/>
				<x path="Float"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"SetSoundPitch"</e></m></meta>
		</setSoundPitch>
		<waveFormat public="1" set="method" static="1">
			<f a="wave:sampleRate:sampleSize:channels">
				<t path="cpp.Star"><c path="Wave"/></t>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"WaveFormat"</e></m></meta>
		</waveFormat>
		<waveCopy public="1" set="method" static="1">
			<f a="wave">
				<c path="Wave"/>
				<c path="Wave"/>
			</f>
			<meta><m n=":native"><e>"WaveCopy"</e></m></meta>
		</waveCopy>
		<waveCrop public="1" set="method" static="1">
			<f a="wave:initSample:finalSample">
				<t path="cpp.Star"><c path="Wave"/></t>
				<x path="Int"/>
				<x path="Int"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"WaveCrop"</e></m></meta>
		</waveCrop>
		<loadWaveSamples public="1" set="method" static="1">
			<f a="wave">
				<c path="Wave"/>
				<t path="cpp.Star"><x path="Float"/></t>
			</f>
			<meta><m n=":native"><e>"LoadWaveSamples"</e></m></meta>
		</loadWaveSamples>
		<unloadWaveSamples public="1" set="method" static="1">
			<f a="samples">
				<t path="cpp.Star"><x path="Float"/></t>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"UnloadWaveSamples"</e></m></meta>
		</unloadWaveSamples>
		<loadMusicStream public="1" set="method" static="1">
			<f a="fileName">
				<x path="cpp.ConstCharStar"/>
				<c path="Music"/>
			</f>
			<meta><m n=":native"><e>"LoadMusicStream"</e></m></meta>
		</loadMusicStream>
		<loadMusicStreamFromMemory public="1" set="method" static="1">
			<f a="fileType:data:dataSize">
				<x path="cpp.ConstCharStar"/>
				<t path="cpp.Star"><x path="cpp.UInt8"/></t>
				<x path="Int"/>
				<c path="Music"/>
			</f>
			<meta><m n=":native"><e>"LoadMusicStreamFromMemory"</e></m></meta>
		</loadMusicStreamFromMemory>
		<unloadMusicStream public="1" set="method" static="1">
			<f a="music">
				<c path="Music"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"UnloadMusicStream"</e></m></meta>
		</unloadMusicStream>
		<playMusicStream public="1" set="method" static="1">
			<f a="music">
				<c path="Music"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"PlayMusicStream"</e></m></meta>
		</playMusicStream>
		<isMusicStreamPlaying public="1" set="method" static="1">
			<f a="music">
				<c path="Music"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"IsMusicStreamPlaying"</e></m></meta>
		</isMusicStreamPlaying>
		<updateMusicStream public="1" set="method" static="1">
			<f a="music">
				<c path="Music"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"UpdateMusicStream"</e></m></meta>
		</updateMusicStream>
		<stopMusicStream public="1" set="method" static="1">
			<f a="music">
				<c path="Music"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"StopMusicStream"</e></m></meta>
		</stopMusicStream>
		<pauseMusicStream public="1" set="method" static="1">
			<f a="music">
				<c path="Music"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"PauseMusicStream"</e></m></meta>
		</pauseMusicStream>
		<resumeMusicStream public="1" set="method" static="1">
			<f a="music">
				<c path="Music"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"ResumeMusicStream"</e></m></meta>
		</resumeMusicStream>
		<seekMusicStream public="1" set="method" static="1">
			<f a="music:position">
				<c path="Music"/>
				<x path="Float"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"SeekMusicStream"</e></m></meta>
		</seekMusicStream>
		<setMusicVolume public="1" set="method" static="1">
			<f a="music:volume">
				<c path="Music"/>
				<x path="Float"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"SetMusicVolume"</e></m></meta>
		</setMusicVolume>
		<setMusicPitch public="1" set="method" static="1">
			<f a="music:pitch">
				<c path="Music"/>
				<x path="Float"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"SetMusicPitch"</e></m></meta>
		</setMusicPitch>
		<getMusicTimeLength public="1" set="method" static="1">
			<f a="music">
				<c path="Music"/>
				<x path="Float"/>
			</f>
			<meta><m n=":native"><e>"GetMusicTimeLength"</e></m></meta>
		</getMusicTimeLength>
		<getMusicTimePlayed public="1" set="method" static="1">
			<f a="music">
				<c path="Music"/>
				<x path="Float"/>
			</f>
			<meta><m n=":native"><e>"GetMusicTimePlayed"</e></m></meta>
		</getMusicTimePlayed>
		<initAudioStream public="1" set="method" static="1">
			<f a="sampleRate:sampleSize:channels">
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<c path="AudioStream"/>
			</f>
			<meta><m n=":native"><e>"InitAudioStream"</e></m></meta>
		</initAudioStream>
		<updateAudioStream public="1" set="method" static="1">
			<f a="stream:data:samplesCount">
				<c path="AudioStream"/>
				<t path="cpp.ConstStar"><c path="cpp.Void"/></t>
				<x path="Int"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"UpdateAudioStream"</e></m></meta>
		</updateAudioStream>
		<closeAudioStream public="1" set="method" static="1">
			<f a="stream">
				<c path="AudioStream"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"CloseAudioStream"</e></m></meta>
		</closeAudioStream>
		<isAudioStreamProcessed public="1" set="method" static="1">
			<f a="stream">
				<c path="AudioStream"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"IsAudioStreamProcessed"</e></m></meta>
		</isAudioStreamProcessed>
		<playAudioStream public="1" set="method" static="1">
			<f a="stream">
				<c path="AudioStream"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"PlayAudioStream"</e></m></meta>
		</playAudioStream>
		<pauseAudioStream public="1" set="method" static="1">
			<f a="stream">
				<c path="AudioStream"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"PauseAudioStream"</e></m></meta>
		</pauseAudioStream>
		<resumeAudioStream public="1" set="method" static="1">
			<f a="stream">
				<c path="AudioStream"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"ResumeAudioStream"</e></m></meta>
		</resumeAudioStream>
		<isAudioStreamPlaying public="1" set="method" static="1">
			<f a="stream">
				<c path="AudioStream"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"IsAudioStreamPlaying"</e></m></meta>
		</isAudioStreamPlaying>
		<stopAudioStream public="1" set="method" static="1">
			<f a="stream">
				<c path="AudioStream"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"StopAudioStream"</e></m></meta>
		</stopAudioStream>
		<setAudioStreamVolume public="1" set="method" static="1">
			<f a="stream:volume">
				<c path="AudioStream"/>
				<x path="Float"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"SetAudioStreamVolume"</e></m></meta>
		</setAudioStreamVolume>
		<setAudioStreamPitch public="1" set="method" static="1">
			<f a="stream:pitch">
				<c path="AudioStream"/>
				<x path="Float"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"SetAudioStreamPitch"</e></m></meta>
		</setAudioStreamPitch>
		<setAudioStreamBufferSizeDefault public="1" set="method" static="1">
			<f a="size">
				<x path="Int"/>
				<c path="cpp.Void"/>
			</f>
			<meta><m n=":native"><e>"SetAudioStreamBufferSizeDefault"</e></m></meta>
		</setAudioStreamBufferSizeDefault>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":buildXml"><e><![CDATA["<include name='${haxelib:raylib-hx}/source/Build.xml'/>"]]></e></m>
			<m n=":include"><e>"raylib.h"</e></m>
		</meta>
	</class>
	<class path="Std" params="" file="D:\Haxe\haxe\std/cpp/_std/Std.hx">
		<is public="1" get="inline" set="null" line="25" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":deprecated"><e>"Std.is is deprecated. Use Std.isOfType instead."</e></m>
				<m n=":keep"/>
			</meta>
			<haxe_doc>DEPRECATED. Use `Std.isOfType(v, t)` instead.

		Tells if a value `v` is of the type `t`. Returns `false` if `v` or `t` are null.

		If `t` is a class or interface with `@:generic` meta, the result is `false`.</haxe_doc>
		</is>
		<isOfType public="1" set="method" line="29" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Tells if a value `v` is of the type `t`. Returns `false` if `v` or `t` are null.

		If `t` is a class or interface with `@:generic` meta, the result is `false`.</haxe_doc>
		</isOfType>
		<downcast public="1" params="T:S" set="method" line="33" static="1">
			<f a="value:c">
				<c path="downcast.T"/>
				<x path="Class"><c path="downcast.S"/></x>
				<c path="downcast.S"/>
			</f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>Checks if object `value` is an instance of class or interface `c`.

		Compiles only if the type specified by `c` can be assigned to the type
		of `value`.

		This method checks if a downcast is possible. That is, if the runtime
		type of `value` is assignable to the type specified by `c`, `value` is
		returned. Otherwise null is returned.

		This method is not guaranteed to work with core types such as `String`,
		`Array` and `Date`.

		If `value` is null, the result is null. If `c` is null, the result is
		unspecified.</haxe_doc>
		</downcast>
		<instance public="1" params="T:S" set="method" line="38" static="1">
			<f a="value:c">
				<c path="instance.T"/>
				<x path="Class"><c path="instance.S"/></x>
				<c path="instance.S"/>
			</f>
			<meta>
				<m n=":deprecated"><e>"Std.instance() is deprecated. Use Std.downcast() instead."</e></m>
				<m n=":keep"/>
			</meta>
		</instance>
		<string public="1" set="method" line="42" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":keep"/>
			</meta>
			<haxe_doc>Converts any value to a String.

		If `s` is of `String`, `Int`, `Float` or `Bool`, its value is returned.

		If `s` is an instance of a class and that class or one of its parent classes has
		a `toString` method, that method is called. If no such method is present, the result
		is unspecified.

		If `s` is an enum constructor without argument, the constructor's name is returned. If
		arguments exists, the constructor's name followed by the String representations of
		the arguments is returned.

		If `s` is a structure, the field names along with their values are returned. The field order
		and the operator separating field names and values are unspecified.

		If s is null, "null" is returned.</haxe_doc>
		</string>
		<int public="1" set="method" line="46" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":keep"/>
			</meta>
			<haxe_doc>Converts a `Float` to an `Int`, rounded towards 0.

		If `x` is outside of the signed Int32 range, or is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</int>
		<parseInt public="1" set="method" line="50" static="1">
			<f a="x">
				<c path="String"/>
				<x path="Null"><x path="Int"/></x>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":keep"/>
			</meta>
			<haxe_doc>Converts a `String` to an `Int`.

		Leading whitespaces are ignored.

		If `x` starts with 0x or 0X, hexadecimal notation is recognized where the following digits may
		contain 0-9 and A-F.

		Otherwise `x` is read as decimal number with 0-9 being allowed characters. `x` may also start with
		a - to denote a negative value.

		In decimal mode, parsing continues until an invalid character is detected, in which case the
		result up to that point is returned. For hexadecimal notation, the effect of invalid characters
		is unspecified.

		Leading 0s that are not part of the 0x/0X hexadecimal notation are ignored, which means octal
		notation is not supported.

		If `x` is null, the result is unspecified.
		If `x` cannot be parsed as integer, the result is `null`.</haxe_doc>
		</parseInt>
		<parseFloat public="1" set="method" line="54" static="1">
			<f a="x">
				<c path="String"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":keep"/>
			</meta>
			<haxe_doc>Converts a `String` to a `Float`.

		The parsing rules for `parseInt` apply here as well, with the exception of invalid input
		resulting in a `NaN` value instead of null.

		Additionally, decimal notation may contain a single `.` to denote the start of the fractions.</haxe_doc>
		</parseFloat>
		<random public="1" set="method" line="58" static="1">
			<f a="x">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":keep"/>
			</meta>
			<haxe_doc><![CDATA[Return a random integer between 0 included and `x` excluded.

		If `x <= 1`, the result is always 0.]]></haxe_doc>
		</random>
		<haxe_doc>The Std class provides standard methods for manipulating basic types.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":headerClassCode"><e><![CDATA["\t\tstatic inline String string(String &s) { return s; }"]]></e></m>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Void" params="" file="D:\Haxe\haxe\std/StdTypes.hx" module="StdTypes">
		<this><x path="Void"/></this>
		<haxe_doc>The standard `Void` type. Only `null` values can be of the type `Void`.

	@see https://haxe.org/manual/types-void.html</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<abstract path="Float" params="" file="D:\Haxe\haxe\std/StdTypes.hx" module="StdTypes">
		<this><x path="Float"/></this>
		<haxe_doc><![CDATA[The standard `Float` type, this is a double-precision IEEE 64bit float.

	On static targets, `null` cannot be assigned to Float. If this is necessary,
	`Null<Float>` can be used instead.

	`Std.int` converts a `Float` to an `Int`, rounded towards 0.
	`Std.parseFloat` converts a `String` to a `Float`.

	@see https://haxe.org/manual/types-basic-types.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Int" params="" file="D:\Haxe\haxe\std/StdTypes.hx" module="StdTypes">
		<this><x path="Int"/></this>
		<to><icast><x path="Float"/></icast></to>
		<haxe_doc><![CDATA[The standard `Int` type. Its precision depends on the platform.

	On static targets, `null` cannot be assigned to `Int`. If this is necessary,
	`Null<Int>` can be used instead.

	`Std.int` converts a `Float` to an `Int`, rounded towards 0.
	`Std.parseInt` converts a `String` to an `Int`.

	@see https://haxe.org/manual/types-basic-types.html
	@see https://haxe.org/manual/std-math-integer-math.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Single" params="" file="D:\Haxe\haxe\std/StdTypes.hx" module="StdTypes">
		<from><icast><x path="Float"/></icast></from>
		<this><x path="Single"/></this>
		<to><icast><x path="Float"/></icast></to>
		<haxe_doc>Single-precision IEEE 32bit float (4-byte).</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Null" params="T" file="D:\Haxe\haxe\std/StdTypes.hx" module="StdTypes">
		<from><icast><c path="Null.T"/></icast></from>
		<this><x path="Null"><c path="Null.T"/></x></this>
		<to><icast><c path="Null.T"/></icast></to>
		<haxe_doc><![CDATA[`Null<T>` is a wrapper that can be used to make the basic types `Int`,
	`Float` and `Bool` nullable on static targets.

	If null safety is enabled, only types wrapped in `Null<T>` are nullable.

	Otherwise, it has no effect on non-basic-types, but it can be useful as a way to document
	that `null` is an acceptable value for a method argument, return value or variable.

	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":forward"/>
			<m n=":coreType"/>
		</meta>
	</abstract>
	<abstract path="Bool" params="" file="D:\Haxe\haxe\std/StdTypes.hx" module="StdTypes">
		<this><x path="Bool"/></this>
		<haxe_doc><![CDATA[The standard Boolean type, which can either be `true` or `false`.

	On static targets, `null` cannot be assigned to `Bool`. If this is necessary,
	`Null<Bool>` can be used instead.

	@see https://haxe.org/manual/types-bool.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Dynamic" params="T" file="D:\Haxe\haxe\std/StdTypes.hx" module="StdTypes">
		<this><x path="Dynamic"><c path="Dynamic.T"/></x></this>
		<haxe_doc>`Dynamic` is a special type which is compatible with all other types.

	Use of `Dynamic` should be minimized as it prevents several compiler
	checks and optimizations. See `Any` type for a safer alternative for
	representing values of any type.

	@see https://haxe.org/manual/types-dynamic.html</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Iterator" params="T" file="D:\Haxe\haxe\std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method">
				<f a=""><c path="Iterator.T"/></f>
				<haxe_doc>Returns the current item of the `Iterator` and advances to the next one.

		This method is not required to check `hasNext()` first. A call to this
		method while `hasNext()` is `false` yields unspecified behavior.

		On the other hand, iterators should not require a call to `hasNext()`
		before the first call to `next()` if an element is available.</haxe_doc>
			</next>
			<hasNext set="method">
				<f a=""><x path="Bool"/></f>
				<haxe_doc>Returns `false` if the iteration is complete, `true` otherwise.

		Usually iteration is considered to be complete if all elements of the
		underlying data structure were handled through calls to `next()`. However,
		in custom iterators any logic may be used to determine the completion
		state.</haxe_doc>
			</hasNext>
		</a>
		<haxe_doc>An `Iterator` is a structure that permits iteration over elements of type `T`.

	Any class with matching `hasNext()` and `next()` fields is considered an `Iterator`
	and can then be used e.g. in `for`-loops. This makes it easy to implement
	custom iterators.

	@see https://haxe.org/manual/lf-iterators.html</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="D:\Haxe\haxe\std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>An `Iterable` is a data structure which has an `iterator()` method.
	See `Lambda` for generic functions on iterable structures.

	@see https://haxe.org/manual/lf-iterators.html</haxe_doc>
	</typedef>
	<typedef path="KeyValueIterator" params="K:V" file="D:\Haxe\haxe\std/StdTypes.hx" module="StdTypes">
		<t path="Iterator"><a>
	<value><c path="KeyValueIterator.V"/></value>
	<key><c path="KeyValueIterator.K"/></key>
</a></t>
		<haxe_doc>A `KeyValueIterator` is an `Iterator` that has a key and a value.</haxe_doc>
	</typedef>
	<typedef path="KeyValueIterable" params="K:V" file="D:\Haxe\haxe\std/StdTypes.hx" module="StdTypes">
		<a><keyValueIterator set="method"><f a=""><t path="KeyValueIterator">
	<c path="KeyValueIterable.K"/>
	<c path="KeyValueIterable.V"/>
</t></f></keyValueIterator></a>
		<haxe_doc>A `KeyValueIterable` is a data structure which has a `keyValueIterator()`
	method to iterate over key-value-pairs.</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="D:\Haxe\haxe\std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>`ArrayAccess` is used to indicate a class that can be accessed using brackets.
	The type parameter represents the type of the elements stored.

	This interface should be used for externs only. Haxe does not support custom
	array access on classes. However, array access can be implemented for
	abstract types.

	@see https://haxe.org/manual/types-abstract-array-access.html</haxe_doc></class>
	<class path="String" params="" file="D:\Haxe\haxe\std/String.hx" extern="1">
		<fromCharCode public="1" set="method" static="1">
			<f a="code">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the String corresponding to the character code `code`.

		If `code` is negative or has another invalid value, the result is
		unspecified.</haxe_doc>
		</fromCharCode>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The number of characters in `this` String.</haxe_doc>
		</length>
		<toUpperCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are upper case.</haxe_doc>
		</toUpperCase>
		<toLowerCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are lower case.</haxe_doc>
		</toLowerCase>
		<charAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the character at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, the empty String `""`
		is returned.</haxe_doc>
		</charAt>
		<charCodeAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<x path="Null"><x path="Int"/></x>
			</f>
			<haxe_doc>Returns the character code at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, `null` is returned.

		To obtain the character code of a single character, `"x".code` can be
		used instead to inline the character code at compile time. Note that
		this only works on String literals of length 1.</haxe_doc>
		</charCodeAt>
		<indexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the leftmost occurrence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String starting from `startIndex`.

		If `startIndex` exceeds `this.length`, -1 is returned.

		If `startIndex` is negative, the result is unspecifed.

		Otherwise the search is performed within `this` String. In either case,
		the returned position is relative to the beginning of `this` String.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the rightmost occurrence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String from 0 to `startIndex + str.length`. Otherwise the search
		is performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.

		If `startIndex` is negative, the result is unspecifed.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</lastIndexOf>
		<split public="1" set="method">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Splits `this` String at each occurrence of `delimiter`.

		If `this` String is the empty String `""`, the result is not consistent
		across targets and may either be `[]` (on Js, Cpp) or `[""]`.

		If `delimiter` is the empty String `""`, `this` String is split into an
		Array of `this.length` elements, where the elements correspond to the
		characters of `this` String.

		If `delimiter` is not found within `this` String, the result is an Array
		with one element, which equals `this` String.

		If `delimiter` is null, the result is unspecified.

		Otherwise, `this` String is split into parts at each occurrence of
		`delimiter`. If `this` String starts (or ends) with `delimiter`, the
		result `Array` contains a leading (or trailing) empty String `""` element.
		Two subsequent delimiters also result in an empty String `""` element.</haxe_doc>
		</split>
		<substr public="1" set="method">
			<f a="pos:?len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns `len` characters of `this` String, starting at position `pos`.

		If `len` is omitted, all characters from position `pos` to the end of
		`this` String are included.

		If `pos` is negative, its value is calculated from the end of `this`
		String by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the calculated position + `len` exceeds `this.length`, the characters
		from that position to the end of `this` String are returned.

		If `len` is negative, the result is unspecified.</haxe_doc>
		</substr>
		<substring public="1" set="method">
			<f a="startIndex:?endIndex">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the part of `this` String from `startIndex` to but not including `endIndex`.

		If `startIndex` or `endIndex` are negative, 0 is used instead.

		If `startIndex` exceeds `endIndex`, they are swapped.

		If the (possibly swapped) `endIndex` is omitted or exceeds
		`this.length`, `this.length` is used instead.

		If the (possibly swapped) `startIndex` exceeds `this.length`, the empty
		String `""` is returned.</haxe_doc>
		</substring>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the String itself.</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="string">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a copy from a given String.</haxe_doc>
		</new>
		<haxe_doc>The basic String class.

	A Haxe String is immutable, it is not possible to modify individual
	characters. No method of this class changes the state of `this` String.

	Strings can be constructed using the String literal syntax `"string value"`.

	String can be concatenated by using the `+` operator. If an operand is not a
	String, it is passed through `Std.string()` first.

	@see https://haxe.org/manual/std-String.html</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="StringBuf" params="" file="D:\Haxe\haxe\std/cpp/_std/StringBuf.hx">
		<b><c path="Array"><c path="String"/></c></b>
		<charBuf><c path="Array"><x path="cpp.Char"/></c></charBuf>
		<charBufAsString set="method" line="37"><f a=""><c path="String"/></f></charBufAsString>
		<flush set="method" line="43"><f a=""><x path="Void"/></f></flush>
		<toString public="1" set="method" line="92">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the content of `this` StringBuf as String.

		The buffer is not emptied by this operation.</haxe_doc>
		</toString>
		<new public="1" set="method" line="35">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new StringBuf instance.

		This may involve initialization of the internal buffer.</haxe_doc>
		</new>
		<haxe_doc>A String buffer is an efficient way to build a big string by appending small
	elements together.

	Unlike String, an instance of StringBuf is not immutable in the sense that
	it can be passed as argument to functions which modify it by appending more
	values.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="StringTools" params="" file="D:\Haxe\haxe\std/StringTools.hx">
		<replace public="1" set="method" line="412" static="1">
			<f a="s:sub:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Replace all occurrences of the String `sub` in the String `s` by the
		String `by`.

		If `sub` is the empty String `""`, `by` is inserted after each character
		of `s` except the last one. If `by` is also the empty String `""`, `s`
		remains unchanged.

		If `sub` or `by` are null, the result is unspecified.</haxe_doc>
		</replace>
		<haxe_doc>This class provides advanced methods on Strings. It is ideally used with
	`using StringTools` and then acts as an [extension](https://haxe.org/manual/lf-static-extension.html)
	to the `String` class.

	If the first argument to any of the methods is null, the result is
	unspecified.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="Sys" params="" file="D:\Haxe\haxe\std/cpp/_std/Sys.hx">
		<println public="1" set="method" line="31" static="1">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Prints any value to the standard output, followed by a newline.
		On Windows, this function outputs a CRLF newline.
		LF newlines are printed on all other platforms.</haxe_doc>
		</println>
		<args public="1" set="method" line="55" static="1">
			<f a=""><c path="Array"><c path="String"/></c></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns all the arguments that were passed in the command line.
		This does not include the interpreter or the name of the program file.

		(java)(eval) On Windows, non-ASCII Unicode arguments will not work correctly.

		(cs) Non-ASCII Unicode arguments will not work correctly.</haxe_doc>
		</args>
		<getCwd public="1" set="method" line="78" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Gets the current working directory (usually the one in which the program was started).</haxe_doc>
		</getCwd>
		<setCwd public="1" set="method" line="82" static="1">
			<f a="s">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Changes the current working directory.

		(java) This functionality is not available on Java; calling this function will throw.</haxe_doc>
		</setCwd>
		<systemName public="1" set="method" line="86" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the type of the current system. Possible values are:
		 - `"Windows"`
		 - `"Linux"`
		 - `"BSD"`
		 - `"Mac"`</haxe_doc>
		</systemName>
		<programPath public="1" set="method" line="124" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the absolute path to the current program file that we are running.
		Concretely, for an executable binary, it returns the path to the binary.
		For a script (e.g. a PHP file), it returns the path to the script.</haxe_doc>
		</programPath>
		<haxe_doc>This class provides access to various base functions of system platforms.
	Look in the `sys` package for more system APIs.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="Type" params="" file="D:\Haxe\haxe\std/cpp/_std/Type.hx">
		<nativeEnumEq set="method" static="1">
			<f a="a:b">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"__hxcpp_enum_eq"</e></m></meta>
		</nativeEnumEq>
		<getEnumValueIndex set="method" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"_hx_getEnumValueIndex"</e></m></meta>
		</getEnumValueIndex>
		<haxe_doc>The Haxe Reflection API allows retrieval of type information at runtime.

	This class complements the more lightweight Reflect class, with a focus on
	class and enum instances.

	@see https://haxe.org/manual/types.html
	@see https://haxe.org/manual/std-reflection.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="UInt" params="" file="D:\Haxe\haxe\std/UInt.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="Int"/></icast>
			<icast field="toFloat"><x path="Float"/></icast>
		</to>
		<haxe_doc>The unsigned `Int` type is only defined for Flash and C#.
	Simulate it for other platforms.

	@see https://haxe.org/manual/types-basic-types.html</haxe_doc>
		<meta><m n=":transitive"/></meta>
		<impl><class path="_UInt.UInt_Impl_" params="" file="D:\Haxe\haxe\std/UInt.hx" private="1" module="UInt" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="cli.CLI" params="" file="cli/CLI.hx">
		<workingDir expr="&quot;&quot;" line="12" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</workingDir>
		<main set="method" line="14" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":keep"/></meta>
		</main>
		<processCmd set="method" line="18" static="1"><f a=""><x path="Void"/></f></processCmd>
		<callCmd set="method" line="46" static="1"><f a="cmd:?args">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></callCmd>
		<recursiveCopyDir set="method" line="75" static="1">
			<f a="srcPath:dstPath:?overwrite:?filter:?exclude" v="::true::false">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
				<c path="EReg"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ exclude : false, overwrite : true }</e></m></meta>
		</recursiveCopyDir>
	</class>
	<class path="cpp.ArrayBase" params="" file="D:\Haxe\haxe\std/cpp/ArrayBase.hx" extern="1">
		<length public="1" set="null"><x path="Int"/></length>
		<getElementSize public="1" set="method"><f a=""><x path="Int"/></f></getElementSize>
		<getByteCount public="1" set="method"><f a=""><x path="Int"/></f></getByteCount>
		<getBase public="1" set="method"><f a=""><c path="cpp.RawPointer"><x path="cpp.Char"/></c></f></getBase>
	</class>
	<class path="cpp.AutoCast" params="" file="D:\Haxe\haxe\std/cpp/AutoCast.hx" extern="1"/>
	<abstract path="cpp.Char" params="" file="D:\Haxe\haxe\std/cpp/Char.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="cpp.Char"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="cpp.ConstCharStar" params="" file="D:\Haxe\haxe\std/cpp/ConstCharStar.hx">
		<from><icast field="fromString"><c path="String"/></icast></from>
		<this><c path="cpp.RawConstPointer"><x path="cpp.Char"/></c></this>
		<to>
			<icast><c path="cpp.RawConstPointer"><x path="cpp.Char"/></c></icast>
			<icast field="toString"><c path="String"/></icast>
			<icast field="toPointer"><c path="cpp.RawConstPointer"><x path="cpp.Char"/></c></icast>
		</to>
		<impl><class path="cpp._ConstCharStar.ConstCharStar_Impl_" params="" file="D:\Haxe\haxe\std/cpp/ConstCharStar.hx" private="1" module="cpp.ConstCharStar" extern="1" final="1">
	<_new public="1" get="inline" set="null" line="26" static="1">
		<f a="s">
			<c path="String"/>
			<x path="cpp.ConstCharStar"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":noCompletion"/>
		</meta>
	</_new>
	<fromString public="1" get="inline" set="null" line="31" static="1">
		<f a="s">
			<c path="String"/>
			<x path="cpp.ConstCharStar"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromString>
	<toString public="1" get="inline" set="null" line="34" static="1">
		<f a="this">
			<c path="cpp.RawConstPointer"><x path="cpp.Char"/></c>
			<c path="String"/>
		</f>
		<meta>
			<m n=":has_untyped"/>
			<m n=":to"/>
		</meta>
	</toString>
	<toPointer public="1" get="inline" set="null" line="37" static="1">
		<f a="this">
			<c path="cpp.RawConstPointer"><x path="cpp.Char"/></c>
			<c path="cpp.RawConstPointer"><x path="cpp.Char"/></c>
		</f>
		<meta><m n=":to"/></meta>
	</toPointer>
</class></impl>
	</abstract>
	<class path="cpp._ConstCharStar.ConstCharStar_Impl_" params="" file="D:\Haxe\haxe\std/cpp/ConstCharStar.hx" private="1" module="cpp.ConstCharStar" extern="1" final="1">
		<_new public="1" get="inline" set="null" line="26" static="1">
			<f a="s">
				<c path="String"/>
				<x path="cpp.ConstCharStar"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":noCompletion"/>
			</meta>
		</_new>
		<fromString public="1" get="inline" set="null" line="31" static="1">
			<f a="s">
				<c path="String"/>
				<x path="cpp.ConstCharStar"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromString>
		<toString public="1" get="inline" set="null" line="34" static="1">
			<f a="this">
				<c path="cpp.RawConstPointer"><x path="cpp.Char"/></c>
				<c path="String"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":to"/>
			</meta>
		</toString>
		<toPointer public="1" get="inline" set="null" line="37" static="1">
			<f a="this">
				<c path="cpp.RawConstPointer"><x path="cpp.Char"/></c>
				<c path="cpp.RawConstPointer"><x path="cpp.Char"/></c>
			</f>
			<meta><m n=":to"/></meta>
		</toPointer>
	</class>
	<class path="cpp.ConstPointer" params="T" file="D:\Haxe\haxe\std/cpp/ConstPointer.hx" extern="1">
		<fromRaw public="1" params="T" set="method" static="1"><f a="ptr">
	<c path="cpp.RawConstPointer"><c path="fromRaw.T"/></c>
	<c path="cpp.ConstPointer"><c path="fromRaw.T"/></c>
</f></fromRaw>
		<fromStar public="1" params="T" set="method" static="1">
			<f a="star">
				<t path="cpp.Star"><c path="fromStar.T"/></t>
				<c path="cpp.ConstPointer"><c path="fromStar.T"/></c>
			</f>
			<meta><m n=":native"><e>"::cpp::Pointer_obj::fromRaw"</e></m></meta>
		</fromStar>
		<fromPointer public="1" params="T" set="method" static="1"><f a="inNativePointer">
	<d/>
	<c path="cpp.ConstPointer"><c path="fromPointer.T"/></c>
</f></fromPointer>
		<ptr public="1"><t path="cpp.Star"><c path="cpp.ConstPointer.T"/></t></ptr>
		<value public="1" get="accessor" set="null"><c path="cpp.ConstPointer.T"/></value>
		<raw public="1" get="accessor" set="null"><c path="cpp.RawPointer"><c path="cpp.ConstPointer.T"/></c></raw>
		<constRaw public="1" get="accessor" set="null"><c path="cpp.RawConstPointer"><c path="cpp.ConstPointer.T"/></c></constRaw>
		<get_value public="1" set="method"><f a=""><t path="cpp.Reference"><c path="cpp.ConstPointer.T"/></t></f></get_value>
		<get_constRaw public="1" set="method"><f a=""><c path="cpp.RawConstPointer"><c path="cpp.ConstPointer.T"/></c></f></get_constRaw>
		<get_raw public="1" set="method"><f a=""><c path="cpp.RawPointer"><c path="cpp.ConstPointer.T"/></c></f></get_raw>
		<lt public="1" set="method"><f a="inOther">
	<c path="cpp.ConstPointer"><c path="cpp.ConstPointer.T"/></c>
	<x path="Bool"/>
</f></lt>
		<leq public="1" set="method"><f a="inOther">
	<c path="cpp.ConstPointer"><c path="cpp.ConstPointer.T"/></c>
	<x path="Bool"/>
</f></leq>
		<gt public="1" set="method"><f a="inOther">
	<c path="cpp.ConstPointer"><c path="cpp.ConstPointer.T"/></c>
	<x path="Bool"/>
</f></gt>
		<geq public="1" set="method"><f a="inOther">
	<c path="cpp.ConstPointer"><c path="cpp.ConstPointer.T"/></c>
	<x path="Bool"/>
</f></geq>
		<setRaw public="1" params="O" set="method"><f a="ptr">
	<c path="cpp.RawPointer"><c path="setRaw.O"/></c>
	<x path="Void"/>
</f></setRaw>
		<reinterpret public="1" params="Other" set="method"><f a=""><c path="cpp.Pointer"><c path="reinterpret.Other"/></c></f></reinterpret>
		<rawCast public="1" params="Other" set="method"><f a=""><c path="cpp.RawPointer"><c path="rawCast.Other"/></c></f></rawCast>
		<at public="1" set="method"><f a="inIndex">
	<x path="Int"/>
	<t path="cpp.Reference"><c path="cpp.ConstPointer.T"/></t>
</f></at>
		<inc public="1" set="method"><f a=""><c path="cpp.ConstPointer"><c path="cpp.ConstPointer.T"/></c></f></inc>
		<dec public="1" set="method"><f a=""><c path="cpp.ConstPointer"><c path="cpp.ConstPointer.T"/></c></f></dec>
		<incBy public="1" set="method"><f a="inT">
	<x path="Int"/>
	<c path="cpp.ConstPointer"><c path="cpp.ConstPointer.T"/></c>
</f></incBy>
		<decBy public="1" set="method"><f a="inT">
	<x path="Int"/>
	<c path="cpp.ConstPointer"><c path="cpp.ConstPointer.T"/></c>
</f></decBy>
		<add public="1" set="method"><f a="inT">
	<x path="Int"/>
	<c path="cpp.ConstPointer"><c path="cpp.ConstPointer.T"/></c>
</f></add>
		<sub public="1" set="method"><f a="inT">
	<x path="Int"/>
	<c path="cpp.ConstPointer"><c path="cpp.ConstPointer.T"/></c>
</f></sub>
		<postIncVal public="1" set="method"><f a=""><t path="cpp.Reference"><c path="cpp.ConstPointer.T"/></t></f></postIncVal>
		<meta>
			<m n=":coreType"/>
			<m n=":include"><e>"cpp/Pointer.h"</e></m>
			<m n=":native"><e>"cpp.Pointer"</e></m>
			<m n=":semantics"><e>variable</e></m>
		</meta>
	</class>
	<typedef path="cpp.ConstStar" params="T" file="D:\Haxe\haxe\std/cpp/ConstStar.hx">
		<x path="Null"><c path="cpp.ConstStar.T"/></x>
		<haxe_doc>Allows haxe to type the result correctly, and hxcpp can recognise this uses
	the correct type.</haxe_doc>
	</typedef>
	<class path="cpp.EnumBase" params="" file="D:\Haxe\haxe\std/cpp/EnumBase.hx" extern="1">
		<_hx_getIndex public="1" set="method"><f a=""><x path="Int"/></f></_hx_getIndex>
		<_hx_getTag public="1" set="method"><f a=""><c path="String"/></f></_hx_getTag>
		<_hx_getParamCount public="1" set="method"><f a=""><x path="Int"/></f></_hx_getParamCount>
		<_hx_getParamI public="1" set="method"><f a="inIndex">
	<x path="Int"/>
	<d/>
</f></_hx_getParamI>
		<_hx_getParameters public="1" set="method"><f a=""><c path="Array"><d/></c></f></_hx_getParameters>
		<getIndex public="1" get="inline" set="null" line="35"><f a=""><x path="Int"/></f></getIndex>
		<getTag public="1" get="inline" set="null" line="37"><f a=""><c path="String"/></f></getTag>
		<getParamCount public="1" get="inline" set="null" line="39"><f a=""><x path="Int"/></f></getParamCount>
		<getParamI public="1" get="inline" set="null" line="41"><f a="inIndex">
	<x path="Int"/>
	<d/>
</f></getParamI>
		<getParameters public="1" get="inline" set="null" line="43"><f a=""><c path="Array"><d/></c></f></getParameters>
		<meta><m n=":native"><e>"hx.EnumBase"</e></m></meta>
	</class>
	<class path="cpp.ErrorConstants" params="" file="D:\Haxe\haxe\std/cpp/ErrorConstants.hx" extern="1">
		<invalidCast public="1" static="1">
			<d/>
			<meta><m n=":native"><e>"HX_INVALID_CAST"</e></m></meta>
		</invalidCast>
		<indexOutOfBounds public="1" static="1">
			<d/>
			<meta><m n=":native"><e>"HX_INDEX_OUT_OF_BOUNDS"</e></m></meta>
		</indexOutOfBounds>
		<invalidObject public="1" static="1">
			<d/>
			<meta><m n=":native"><e>"HX_INVALID_OBJECT"</e></m></meta>
		</invalidObject>
		<invalidArgCount public="1" static="1">
			<d/>
			<meta><m n=":native"><e>"HX_INVALID_ARG_COUNT"</e></m></meta>
		</invalidArgCount>
		<nullFunctionPointer public="1" static="1">
			<d/>
			<meta><m n=":native"><e>"HX_NULL_FUNCTION_POINTER"</e></m></meta>
		</nullFunctionPointer>
	</class>
	<class path="cpp.NativeArray" params="" file="D:\Haxe\haxe\std/cpp/NativeArray.hx" extern="1">
		<create public="1" params="T" set="method" static="1">
			<f a="length">
				<x path="Int"/>
				<c path="Array"><c path="create.T"/></c>
			</f>
			<meta><m n=":native"><e>"_hx_create_array_length"</e></m></meta>
		</create>
		<blit public="1" params="T" get="inline" set="null" line="37" static="1">
			<f a="ioDestArray:inDestElement:inSourceArray:inSourceElement:inElementCount">
				<c path="Array"><c path="blit.T"/></c>
				<x path="Int"/>
				<c path="Array"><c path="blit.T"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</blit>
		<getBase public="1" get="inline" set="null" line="41" static="1">
			<f a="inArray">
				<c path="Array"><d/></c>
				<c path="cpp.ArrayBase"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</getBase>
		<reserve public="1" params="T" set="method" static="1">
			<f a="inArray:inElements">
				<c path="Array"><c path="reserve.T"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":nativeStaticExtension"/></meta>
		</reserve>
		<capacity public="1" params="T" set="method" static="1">
			<f a="inArray">
				<c path="Array"><c path="capacity.T"/></c>
				<x path="Int"/>
			</f>
			<meta><m n=":nativeStaticExtension"/></meta>
		</capacity>
		<getElementSize public="1" params="T" set="method" static="1">
			<f a="inArray">
				<c path="Array"><c path="getElementSize.T"/></c>
				<x path="Int"/>
			</f>
			<meta><m n=":nativeStaticExtension"/></meta>
		</getElementSize>
		<address public="1" params="T" get="inline" set="null" line="54" static="1"><f a="inArray:inIndex">
	<c path="Array"><c path="address.T"/></c>
	<x path="Int"/>
	<c path="cpp.Pointer"><c path="address.T"/></c>
</f></address>
		<setData public="1" params="T" set="method" static="1">
			<f a="inArray:inData:inElementCount">
				<c path="Array"><c path="setData.T"/></c>
				<c path="cpp.Pointer"><c path="setData.T"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":nativeStaticExtension"/></meta>
		</setData>
		<setUnmanagedData public="1" params="T" set="method" static="1">
			<f a="inArray:inData:inElementCount">
				<c path="Array"><c path="setUnmanagedData.T"/></c>
				<c path="cpp.ConstPointer"><c path="setUnmanagedData.T"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":nativeStaticExtension"/></meta>
		</setUnmanagedData>
		<zero public="1" params="T" set="method" static="1">
			<f a="ioDestArray:?inFirst:?inElements">
				<c path="Array"><c path="zero.T"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":nativeStaticExtension"/></meta>
		</zero>
		<removeAt public="1" params="T" set="method" static="1">
			<f a="ioDestArray:inIndex">
				<c path="Array"><c path="removeAt.T"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":nativeStaticExtension"/></meta>
		</removeAt>
		<memcmp public="1" params="T" set="method" static="1">
			<f a="inArrayA:inArrayB">
				<c path="Array"><c path="memcmp.T"/></c>
				<c path="Array"><c path="memcmp.T"/></c>
				<x path="Int"/>
			</f>
			<meta><m n=":nativeStaticExtension"/></meta>
		</memcmp>
		<resolveVirtualArray public="1" set="method" static="1">
			<f a="inArray">
				<c path="Array"><d/></c>
				<d/>
			</f>
			<meta><m n=":native"><e>"_hx_reslove_virtual_array"</e></m></meta>
		</resolveVirtualArray>
		<unsafeGet public="1" params="T" set="method" static="1">
			<f a="inDestArray:inIndex">
				<c path="Array"><c path="unsafeGet.T"/></c>
				<x path="Int"/>
				<c path="unsafeGet.T"/>
			</f>
			<meta><m n=":native"><e>"_hx_array_unsafe_get"</e></m></meta>
		</unsafeGet>
		<unsafeSet public="1" params="T" get="inline" set="null" line="93" static="1">
			<f a="ioDestArray:inIndex:inValue">
				<c path="Array"><c path="unsafeSet.T"/></c>
				<x path="Int"/>
				<c path="unsafeSet.T"/>
				<c path="unsafeSet.T"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":native"><e>"_hx_array_unsafe_set"</e></m>
			</meta>
		</unsafeSet>
		<setSize public="1" params="T" set="method" static="1">
			<f a="ioArray:inSize">
				<c path="Array"><c path="setSize.T"/></c>
				<x path="Int"/>
				<c path="Array"><c path="setSize.T"/></c>
			</f>
			<meta><m n=":native"><e>"_hx_array_set_size_exact"</e></m></meta>
		</setSize>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="cpp.NativeFile" params="" file="D:\Haxe\haxe\std/cpp/NativeFile.hx" extern="1">
		<file_open public="1" set="method" static="1">
			<f a="fname:r">
				<c path="String"/>
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":native"><e>"_hx_std_file_open"</e></m></meta>
		</file_open>
		<file_close public="1" set="method" static="1">
			<f a="handle">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_file_close"</e></m></meta>
		</file_close>
		<file_write public="1" set="method" static="1">
			<f a="handle:s:p:n">
				<d/>
				<t path="haxe.io.BytesData"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_file_write"</e></m></meta>
		</file_write>
		<file_write_char public="1" set="method" static="1">
			<f a="handle:c">
				<d/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_file_write_char"</e></m></meta>
		</file_write_char>
		<file_read public="1" set="method" static="1">
			<f a="handle:s:p:n">
				<d/>
				<t path="haxe.io.BytesData"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_file_read"</e></m></meta>
		</file_read>
		<file_read_char public="1" set="method" static="1">
			<f a="handle">
				<d/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_file_read_char"</e></m></meta>
		</file_read_char>
		<file_seek public="1" set="method" static="1">
			<f a="handle:pos:kind">
				<d/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_file_seek"</e></m></meta>
		</file_seek>
		<file_tell public="1" set="method" static="1">
			<f a="handle">
				<d/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_file_tell"</e></m></meta>
		</file_tell>
		<file_eof public="1" set="method" static="1">
			<f a="handle">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_file_eof"</e></m></meta>
		</file_eof>
		<file_flush public="1" set="method" static="1">
			<f a="handle">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_file_flush"</e></m></meta>
		</file_flush>
		<file_contents_string public="1" set="method" static="1">
			<f a="name">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_file_contents_string"</e></m></meta>
		</file_contents_string>
		<file_contents_bytes public="1" set="method" static="1">
			<f a="name">
				<c path="String"/>
				<t path="haxe.io.BytesData"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_file_contents_bytes"</e></m></meta>
		</file_contents_bytes>
		<file_stdin public="1" set="method" static="1">
			<f a=""><d/></f>
			<meta><m n=":native"><e>"_hx_std_file_stdin"</e></m></meta>
		</file_stdin>
		<file_stdout public="1" set="method" static="1">
			<f a=""><d/></f>
			<meta><m n=":native"><e>"_hx_std_file_stdout"</e></m></meta>
		</file_stdout>
		<file_stderr public="1" set="method" static="1">
			<f a=""><d/></f>
			<meta><m n=":native"><e>"_hx_std_file_stderr"</e></m></meta>
		</file_stderr>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":buildXml"><e><![CDATA["<include name=\"${HXCPP}/src/hx/libs/std/Build.xml\"/>"]]></e></m>
		</meta>
	</class>
	<class path="cpp.NativeString" params="" file="D:\Haxe\haxe\std/cpp/NativeString.hx" extern="1">
		<raw public="1" get="inline" set="null" line="26" static="1">
			<f a="inString">
				<c path="String"/>
				<c path="cpp.RawConstPointer"><x path="cpp.Char"/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</raw>
		<c_str public="1" get="inline" set="null" line="29" static="1">
			<f a="inString">
				<c path="String"/>
				<c path="cpp.ConstPointer"><x path="cpp.Char"/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</c_str>
		<fromPointer public="1" get="inline" set="null" line="32" static="1">
			<f a="inPtr">
				<c path="cpp.ConstPointer"><x path="cpp.Char"/></c>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</fromPointer>
		<fromGcPointer public="1" get="inline" set="null" line="35" static="1">
			<f a="inPtr:inLen">
				<c path="cpp.ConstPointer"><x path="cpp.Char"/></c>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</fromGcPointer>
		<parseFloat public="1" set="method" static="1">
			<f a="inString">
				<c path="String"/>
				<x path="Float"/>
			</f>
			<meta><m n=":native"><e>"__hxcpp_parse_float"</e></m></meta>
		</parseFloat>
		<parseSubstrFloat public="1" set="method" static="1">
			<f a="inString:start:length">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":native"><e>"__hxcpp_parse_substr_float"</e></m></meta>
		</parseSubstrFloat>
		<parseInt public="1" set="method" static="1">
			<f a="inString">
				<c path="String"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"__hxcpp_parse_substr_int"</e></m></meta>
		</parseInt>
		<parseSubstrInt public="1" set="method" static="1">
			<f a="inString:start:length">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"__hxcpp_parse_substr_int"</e></m></meta>
		</parseSubstrInt>
		<compare public="1" set="method" static="1">
			<f a="inString0:inString1">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"_hx_string_compare"</e></m></meta>
		</compare>
		<utf8CharCodeAt public="1" set="method" static="1">
			<f a="inString:inIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"_hx_utf8_char_code_at"</e></m></meta>
		</utf8CharCodeAt>
		<utf8Length public="1" set="method" static="1">
			<f a="inString">
				<c path="String"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"_hx_utf8_length"</e></m></meta>
		</utf8Length>
		<utf8IsValid public="1" set="method" static="1">
			<f a="inString">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"_hx_utf8_is_valid"</e></m></meta>
		</utf8IsValid>
		<utf8Sub public="1" set="method" static="1">
			<f a="inString:charStart:inLen">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":native"><e>"_hx_utf8_sub"</e></m></meta>
		</utf8Sub>
		<fromPointerLen public="1" set="method" static="1">
			<f a="inPtr:len">
				<c path="cpp.ConstPointer"><x path="cpp.Char"/></c>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":native"><e>"_hx_string_create"</e></m></meta>
		</fromPointerLen>
		<utf8DecodeAdvance public="1" set="method" static="1">
			<f a="reference">
				<x path="cpp.Char"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"_hx_utf8_decode_advance"</e></m></meta>
		</utf8DecodeAdvance>
	</class>
	<class path="cpp.NativeSys" params="" file="D:\Haxe\haxe\std/cpp/NativeSys.hx" extern="1">
		<print public="1" set="method" static="1">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"__hxcpp_print"</e></m></meta>
		</print>
		<println public="1" set="method" static="1">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"__hxcpp_println"</e></m></meta>
		</println>
		<get_env public="1" set="method" static="1">
			<f a="v">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_get_env"</e></m></meta>
		</get_env>
		<put_env public="1" set="method" static="1">
			<f a="e:v">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_put_env"</e></m></meta>
		</put_env>
		<sys_sleep public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_sys_sleep"</e></m></meta>
		</sys_sleep>
		<set_time_locale public="1" set="method" static="1">
			<f a="l">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_set_time_locale"</e></m></meta>
		</set_time_locale>
		<get_cwd public="1" set="method" static="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":native"><e>"_hx_std_get_cwd"</e></m></meta>
		</get_cwd>
		<set_cwd public="1" set="method" static="1">
			<f a="d">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_set_cwd"</e></m></meta>
		</set_cwd>
		<sys_string public="1" set="method" static="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":native"><e>"_hx_std_sys_string"</e></m></meta>
		</sys_string>
		<sys_is64 public="1" set="method" static="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":native"><e>"_hx_std_sys_is64"</e></m></meta>
		</sys_is64>
		<sys_command public="1" set="method" static="1">
			<f a="cmd">
				<c path="String"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_sys_command"</e></m></meta>
		</sys_command>
		<sys_exit public="1" set="method" static="1">
			<f a="code">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_sys_exit"</e></m></meta>
		</sys_exit>
		<sys_exists public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_sys_exists"</e></m></meta>
		</sys_exists>
		<file_delete public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_file_delete"</e></m></meta>
		</file_delete>
		<sys_rename public="1" set="method" static="1">
			<f a="path:newname">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_sys_rename"</e></m></meta>
		</sys_rename>
		<sys_stat public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":native"><e>"_hx_std_sys_stat"</e></m></meta>
		</sys_stat>
		<sys_file_type public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_sys_file_type"</e></m></meta>
		</sys_file_type>
		<sys_create_dir public="1" set="method" static="1">
			<f a="path:mode">
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_sys_create_dir"</e></m></meta>
		</sys_create_dir>
		<sys_remove_dir public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_sys_remove_dir"</e></m></meta>
		</sys_remove_dir>
		<sys_time public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<meta><m n=":native"><e>"_hx_std_sys_time"</e></m></meta>
		</sys_time>
		<sys_cpu_time public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<meta><m n=":native"><e>"_hx_std_sys_cpu_time"</e></m></meta>
		</sys_cpu_time>
		<sys_read_dir public="1" set="method" static="1">
			<f a="p">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":native"><e>"_hx_std_sys_read_dir"</e></m></meta>
		</sys_read_dir>
		<file_full_path public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_file_full_path"</e></m></meta>
		</file_full_path>
		<sys_exe_path public="1" set="method" static="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":native"><e>"_hx_std_sys_exe_path"</e></m></meta>
		</sys_exe_path>
		<sys_env public="1" set="method" static="1">
			<f a=""><c path="Array"><c path="String"/></c></f>
			<meta><m n=":native"><e>"_hx_std_sys_env"</e></m></meta>
		</sys_env>
		<sys_getch public="1" set="method" static="1">
			<f a="b">
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"_hx_std_sys_getch"</e></m></meta>
		</sys_getch>
		<sys_get_pid public="1" set="method" static="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":native"><e>"_hx_std_sys_get_pid"</e></m></meta>
		</sys_get_pid>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":buildXml"><e><![CDATA["<include name=\"${HXCPP}/src/hx/libs/std/Build.xml\"/>"]]></e></m>
		</meta>
	</class>
	<class path="cpp.ObjectType" params="" file="D:\Haxe\haxe\std/cpp/ObjectType.hx" extern="1">
		<vtUnknown public="1" get="inline" set="null" expr="-1" line="26" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</vtUnknown>
		<vtInt public="1" get="inline" set="null" expr="0xff" line="27" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xff</e></m></meta>
		</vtInt>
		<vtNull public="1" get="inline" set="null" expr="0" line="28" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</vtNull>
		<vtFloat public="1" get="inline" set="null" expr="1" line="29" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</vtFloat>
		<vtBool public="1" get="inline" set="null" expr="2" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</vtBool>
		<vtString public="1" get="inline" set="null" expr="3" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</vtString>
		<vtObject public="1" get="inline" set="null" expr="4" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</vtObject>
		<vtArray public="1" get="inline" set="null" expr="5" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5</e></m></meta>
		</vtArray>
		<vtFunction public="1" get="inline" set="null" expr="6" line="34" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6</e></m></meta>
		</vtFunction>
		<vtEnum public="1" get="inline" set="null" expr="7" line="35" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>7</e></m></meta>
		</vtEnum>
		<vtClass public="1" get="inline" set="null" expr="8" line="36" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</vtClass>
		<vtInt64 public="1" get="inline" set="null" expr="9" line="37" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>9</e></m></meta>
		</vtInt64>
		<vtAbstractBase public="1" get="inline" set="null" expr="0x100" line="38" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x100</e></m></meta>
		</vtAbstractBase>
	</class>
	<class path="cpp.Pointer" params="T" file="D:\Haxe\haxe\std/cpp/Pointer.hx" extern="1">
		<extends path="cpp.ConstPointer"><c path="cpp.Pointer.T"/></extends>
		<fromRaw public="1" params="T" set="method" static="1"><f a="ptr">
	<c path="cpp.RawPointer"><c path="fromRaw.T"/></c>
	<c path="cpp.Pointer"><c path="fromRaw.T"/></c>
</f></fromRaw>
		<fromStar public="1" params="T" set="method" static="1">
			<f a="star">
				<t path="cpp.Star"><c path="fromStar.T"/></t>
				<c path="cpp.Pointer"><c path="fromStar.T"/></c>
			</f>
			<meta><m n=":native"><e>"::cpp::Pointer_obj::fromRaw"</e></m></meta>
		</fromStar>
		<nativeFromHandle public="1" params="T" set="method" static="1">
			<f a="inHandle:?inKind">
				<d/>
				<c path="String"/>
				<c path="cpp.AutoCast"/>
			</f>
			<meta><m n=":native"><e>"::cpp::Pointer_obj::fromHandle"</e></m></meta>
		</nativeFromHandle>
		<fromHandle public="1" params="T" get="inline" set="null" line="44" static="1"><f a="inHandle:?inKind">
	<d/>
	<c path="String"/>
	<c path="cpp.Pointer"><c path="fromHandle.T"/></c>
</f></fromHandle>
		<fromPointer public="1" params="T" set="method" static="1"><f a="inNativePointer">
	<d/>
	<c path="cpp.Pointer"><c path="fromPointer.T"/></c>
</f></fromPointer>
		<addressOf public="1" params="T" set="method" static="1"><f a="inVariable">
	<t path="cpp.Reference"><c path="addressOf.T"/></t>
	<c path="cpp.Pointer"><c path="addressOf.T"/></c>
</f></addressOf>
		<endOf public="1" params="T" set="method" static="1"><f a="inVariable">
	<c path="endOf.T"/>
	<c path="cpp.Pointer"><c path="cpp.Void"/></c>
</f></endOf>
		<nativeArrayElem public="1" params="T" set="method" static="1">
			<f a="array:inElem">
				<c path="Array"><c path="nativeArrayElem.T"/></c>
				<x path="Int"/>
				<c path="cpp.AutoCast"/>
			</f>
			<meta><m n=":native"><e>"::cpp::Pointer_obj::arrayElem"</e></m></meta>
		</nativeArrayElem>
		<arrayElem public="1" params="T" get="inline" set="null" line="56" static="1"><f a="array:inElem">
	<c path="Array"><c path="arrayElem.T"/></c>
	<x path="Int"/>
	<c path="cpp.Pointer"><c path="arrayElem.T"/></c>
</f></arrayElem>
		<nativeOfArray public="1" params="T" set="method" static="1">
			<f a="array">
				<c path="Array"><c path="nativeOfArray.T"/></c>
				<c path="cpp.AutoCast"/>
			</f>
			<meta><m n=":native"><e>"::cpp::Pointer_obj::ofArray"</e></m></meta>
		</nativeOfArray>
		<ofArray public="1" params="T" get="inline" set="null" line="62" static="1"><f a="array">
	<c path="Array"><c path="ofArray.T"/></c>
	<c path="cpp.Pointer"><c path="ofArray.T"/></c>
</f></ofArray>
		<ref public="1" get="accessor" set="accessor"><t path="cpp.Reference"><c path="cpp.Pointer.T"/></t></ref>
		<get_ref public="1" set="method"><f a=""><t path="cpp.Reference"><c path="cpp.Pointer.T"/></t></f></get_ref>
		<set_ref public="1" set="method"><f a="t">
	<c path="cpp.Pointer.T"/>
	<t path="cpp.Reference"><c path="cpp.Pointer.T"/></t>
</f></set_ref>
		<setAt public="1" set="method"><f a="inIndex:value">
	<x path="Int"/>
	<c path="cpp.Pointer.T"/>
	<x path="Void"/>
</f></setAt>
		<toUnmanagedArray public="1" get="inline" set="null" line="66"><f a="elementCount">
	<x path="Int"/>
	<c path="Array"><c path="cpp.Pointer.T"/></c>
</f></toUnmanagedArray>
		<toUnmanagedVector public="1" get="inline" set="null" line="73"><f a="elementCount">
	<x path="Int"/>
	<x path="haxe.ds.Vector"><c path="cpp.Pointer.T"/></x>
</f></toUnmanagedVector>
		<inc public="1" set="method" override="1"><f a=""><c path="cpp.Pointer"><c path="cpp.Pointer.T"/></c></f></inc>
		<dec public="1" set="method" override="1"><f a=""><c path="cpp.Pointer"><c path="cpp.Pointer.T"/></c></f></dec>
		<incBy public="1" set="method" override="1"><f a="inT">
	<x path="Int"/>
	<c path="cpp.Pointer"><c path="cpp.Pointer.T"/></c>
</f></incBy>
		<decBy public="1" set="method" override="1"><f a="inT">
	<x path="Int"/>
	<c path="cpp.Pointer"><c path="cpp.Pointer.T"/></c>
</f></decBy>
		<add public="1" set="method" override="1"><f a="inT">
	<x path="Int"/>
	<c path="cpp.Pointer"><c path="cpp.Pointer.T"/></c>
</f></add>
		<sub public="1" set="method" override="1"><f a="inT">
	<x path="Int"/>
	<c path="cpp.Pointer"><c path="cpp.Pointer.T"/></c>
</f></sub>
		<postIncRef public="1" set="method"><f a=""><t path="cpp.Reference"><c path="cpp.Pointer.T"/></t></f></postIncRef>
		<destroy public="1" set="method"><f a=""><x path="Void"/></f></destroy>
		<destroyArray public="1" set="method"><f a=""><x path="Void"/></f></destroyArray>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":coreType"/>
			<m n=":semantics"><e>variable</e></m>
		</meta>
	</class>
	<class path="cpp.RawConstPointer" params="T" file="D:\Haxe\haxe\std/cpp/RawConstPointer.hx" extern="1">
		<addressOf public="1" params="T" set="method" static="1">
			<f a="t">
				<c path="addressOf.T"/>
				<c path="cpp.RawConstPointer"><c path="addressOf.T"/></c>
			</f>
			<meta><m n=":native"><e>"::hx::AddressOf"</e></m></meta>
		</addressOf>
		<meta><m n=":unreflective"/></meta>
	</class>
	<class path="cpp.RawPointer" params="T" file="D:\Haxe\haxe\std/cpp/RawPointer.hx" extern="1">
		<extends path="cpp.RawConstPointer"><c path="cpp.RawPointer.T"/></extends>
		<addressOf public="1" params="T" set="method" static="1">
			<f a="t">
				<c path="addressOf.T"/>
				<c path="cpp.RawPointer"><c path="addressOf.T"/></c>
			</f>
			<meta><m n=":native"><e>"::hx::AddressOf"</e></m></meta>
		</addressOf>
		<meta><m n=":unreflective"/></meta>
	</class>
	<typedef path="cpp.Reference" params="T" file="D:\Haxe\haxe\std/cpp/Reference.hx">
		<c path="cpp.Reference.T"/>
		<haxe_doc>Allows haxe to type result correctly, and hxcpp can recognise this and
	prevent unwanted casting.</haxe_doc>
		<meta><m n=":semantics"><e>reference</e></m></meta>
	</typedef>
	<typedef path="cpp.Star" params="T" file="D:\Haxe\haxe\std/cpp/Star.hx">
		<x path="Null"><c path="cpp.Star.T"/></x>
		<haxe_doc>Allows haxe to type result correctly, and hxcpp can recognise this use the
	correct type.</haxe_doc>
	</typedef>
	<typedef path="cpp.Struct" params="T" file="D:\Haxe\haxe\std/cpp/Struct.hx">
		<c path="cpp.Struct.T"/>
		<haxe_doc>Wraps external types with a class that integrates with Dynamic.</haxe_doc>
	</typedef>
	<abstract path="cpp.UInt16" params="" file="D:\Haxe\haxe\std/cpp/UInt16.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="cpp.UInt16"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="cpp.UInt8" params="" file="D:\Haxe\haxe\std/cpp/UInt8.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="cpp.UInt8"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<class path="cpp.Void" params="" file="D:\Haxe\haxe\std/cpp/Void.hx" extern="1"><meta><m n=":native"><e>"void"</e></m></meta></class>
	<abstract path="haxe.CallStack" params="" file="D:\Haxe\haxe\std/haxe/CallStack.hx">
		<from><icast><c path="Array"><e path="haxe.StackItem"/></c></icast></from>
		<this><c path="Array"><e path="haxe.StackItem"/></c></this>
		<haxe_doc>Get information about the call stack.</haxe_doc>
		<meta>
			<m n=":allow"><e>haxe.Exception</e></m>
			<m n=":using"><e>haxe.CallStack</e></m>
		</meta>
		<impl><class path="haxe._CallStack.CallStack_Impl_" params="" file="D:\Haxe\haxe\std/haxe/CallStack.hx" private="1" module="haxe.CallStack" final="1"><meta>
	<m n=":keep"/>
	<m n=":using"><e>haxe.CallStack</e></m>
	<m n=":allow"><e>haxe.Exception</e></m>
</meta></class></impl>
	</abstract>
	<abstract path="haxe.Function" params="" file="D:\Haxe\haxe\std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with any function type.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<meta><m n=":callable"/></meta>
		<impl><class path="haxe._Constraints.Function_Impl_" params="" file="D:\Haxe\haxe\std/haxe/Constraints.hx" private="1" module="haxe.Constraints" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.FlatEnum" params="" file="D:\Haxe\haxe\std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with an enum instance if all constructors of the enum
	require no arguments.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<impl><class path="haxe._Constraints.FlatEnum_Impl_" params="" file="D:\Haxe\haxe\std/haxe/Constraints.hx" private="1" module="haxe.Constraints" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.NotVoid" params="" file="D:\Haxe\haxe\std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with anything but `Void`.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<impl><class path="haxe._Constraints.NotVoid_Impl_" params="" file="D:\Haxe\haxe\std/haxe/Constraints.hx" private="1" module="haxe.Constraints" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.Constructible" params="T" file="D:\Haxe\haxe\std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc><![CDATA[This type unifies with any instance of classes that have a constructor
	which

	  * is `public` and
	  * unifies with the type used for type parameter `T`.

	If a type parameter `A` is assigned to a type parameter `B` which is constrained
	to `Constructible<T>`, A must be explicitly constrained to
	`Constructible<T>` as well.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.]]></haxe_doc>
		<impl><class path="haxe._Constraints.Constructible_Impl_" params="" file="D:\Haxe\haxe\std/haxe/Constraints.hx" private="1" module="haxe.Constraints" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.IMap" params="K:V" file="D:\Haxe\haxe\std/haxe/Constraints.hx" module="haxe.Constraints" interface="1"><meta><m n=":keep"/></meta></class>
	<class path="haxe.EnumTools" params="" file="D:\Haxe\haxe\std/haxe/EnumTools.hx" extern="1">
		<getName public="1" params="T" get="inline" set="null" line="52" static="1">
			<f a="e">
				<x path="Enum"><c path="getName.T"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of enum `e`, including its path.

		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:
		
			pack1.pack2.(...).packN.EnumName

		If `e` is a sub-type of a Haxe module, that module is not part of the
		package structure.

		If `e` has no package, the enum name is returned.

		If `e` is `null`, the result is unspecified.

		The enum name does not include any type parameters.</haxe_doc>
		</getName>
		<createByName public="1" params="T" get="inline" set="null" line="65" static="1">
			<f a="e:constr:?params">
				<x path="Enum"><c path="createByName.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createByName.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor `constr` with
		arguments `params`.

		If `e` or `constr` is `null`, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createByName>
		<createByIndex public="1" params="T" get="inline" set="null" line="81" static="1">
			<f a="e:index:?params">
				<x path="Enum"><c path="createByIndex.T"/></x>
				<x path="Int"/>
				<c path="Array"><d/></c>
				<c path="createByIndex.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor number
		`index` with arguments `params`.

		The constructor indices are preserved from Haxe syntax, so the first
		declared is index 0, the next index 1 etc.

		If `e` or `index` is `null`, or if enum `e` has no constructor
		corresponding to index `index`, or if the number of elements in `params`
		does not match the expected number of constructor arguments, or if any
		argument has an invalid type, the result is unspecified.</haxe_doc>
		</createByIndex>
		<createAll public="1" params="T" get="inline" set="null" line="98" static="1">
			<f a="e">
				<x path="Enum"><c path="createAll.T"/></x>
				<c path="Array"><c path="createAll.T"/></c>
			</f>
			<haxe_doc>Returns a list of all constructors of enum `e` that require no
		arguments.

		This may return the empty Array `[]` if all constructors of `e` require
		arguments.

		Otherwise an instance of `e` constructed through each of its non-
		argument constructors is returned, in the order of the constructor
		declaration.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</createAll>
		<getConstructors public="1" params="T" get="inline" set="null" line="110" static="1">
			<f a="e">
				<x path="Enum"><c path="getConstructors.T"/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.

		The order of the constructor names in the returned Array is preserved
		from the original syntax.

		If `c` is `null`, the result is unspecified.</haxe_doc>
		</getConstructors>
		<haxe_doc>This class provides advanced methods on enums. It is ideally used with
	`using EnumTools` and then acts as an
	  [extension](https://haxe.org/manual/lf-static-extension.html) to the
	  `enum` types.

	If the first argument to any of the methods is `null`, the result is
	unspecified.</haxe_doc>
	</class>
	<class path="haxe.EnumValueTools" params="" file="D:\Haxe\haxe\std/haxe/EnumTools.hx" module="haxe.EnumTools" extern="1">
		<equals public="1" params="T" get="inline" set="null" line="133" static="1">
			<f a="a:b">
				<c path="equals.T"/>
				<c path="equals.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Recursively compares two enum instances `a` and `b` by value.

		Unlike `a == b`, this function performs a deep equality check on the
		arguments of the constructors (if there are any).

		If `a` or `b` are `null`, the result is unspecified.</haxe_doc>
		</equals>
		<getName public="1" get="inline" set="null" line="144" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor name of enum instance `e`.

		The result String does not contain any constructor arguments.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getName>
		<getParameters public="1" get="inline" set="null" line="158" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns a list of the constructor arguments of enum instance `e`.

		If `e` has no arguments, the result is `[]`.

		Otherwise the result are the values that were used as arguments to `e`,
		in the order of their declaration.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getParameters>
		<getIndex public="1" get="inline" set="null" line="170" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of enum instance `e`.

		This corresponds to the original syntactic position of `e`. The index of
		the first declared constructor is 0, the next one is 1 etc.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getIndex>
		<haxe_doc>This class provides advanced methods on enum values. It is ideally used with
	`using EnumValueTools` and then acts as an
	  [extension](https://haxe.org/manual/lf-static-extension.html) to the
	  `EnumValue` types.

	If the first argument to any of the methods is `null`, the result is
	unspecified.</haxe_doc>
	</class>
	<class path="haxe.Exception" params="" file="D:\Haxe\haxe\std/cpp/_std/haxe/Exception.hx">
		<caught set="method" line="18" static="1"><f a="value">
	<x path="Any"/>
	<c path="haxe.Exception"/>
</f></caught>
		<thrown set="method" line="26" static="1"><f a="value">
	<x path="Any"/>
	<x path="Any"/>
</f></thrown>
		<message public="1" get="accessor" set="null">
			<c path="String"/>
			<haxe_doc>Exception message.</haxe_doc>
		</message>
		<native public="1" get="accessor" set="null">
			<x path="Any"/>
			<haxe_doc>Native exception, which caused this exception.</haxe_doc>
		</native>
		<__exceptionMessage>
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</__exceptionMessage>
		<__nativeStack>
			<c path="Array"><c path="String"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__nativeStack>
		<__skipStack expr="0">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
				<m n=":ifFeature"><e>"haxe.Exception.get_stack"</e></m>
			</meta>
		</__skipStack>
		<__nativeException>
			<x path="Any"/>
			<meta><m n=":noCompletion"/></meta>
		</__nativeException>
		<__previousException>
			<x path="Null"><c path="haxe.Exception"/></x>
			<meta><m n=":noCompletion"/></meta>
		</__previousException>
		<unwrap set="method" line="48"><f a=""><x path="Any"/></f></unwrap>
		<toString public="1" set="method" line="52">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns exception message.</haxe_doc>
		</toString>
		<get_message set="method" line="66"><f a=""><c path="String"/></f></get_message>
		<get_native final="1" set="method" line="74"><f a=""><x path="Any"/></f></get_native>
		<new public="1" set="method" line="36">
			<f a="message:?previous:?native">
				<c path="String"/>
				<c path="haxe.Exception"/>
				<x path="Any"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Create a new Exception instance.

		The `previous` argument could be used for exception chaining.

		The `native` argument is for internal usage only.
		There is no need to provide `native` argument manually and no need to keep it
		upon extending `haxe.Exception` unless you know what you're doing.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[Base class for exceptions.

	If this class (or derivatives) is used to catch an exception, then
	`haxe.CallStack.exceptionStack()` will not return a stack for the exception
	caught. Use `haxe.Exception.stack` property instead:
	```haxe
	try {
		throwSomething();
	} catch(e:Exception) {
		trace(e.stack);
	}
	```

	Custom exceptions should extend this class:
	```haxe
	class MyException extends haxe.Exception {}
	//...
	throw new MyException('terrible exception');
	```

	`haxe.Exception` is also a wildcard type to catch any exception:
	```haxe
	try {
		throw 'Catch me!';
	} catch(e:haxe.Exception) {
		trace(e.message); // Output: Catch me!
	}
	```

	To rethrow an exception just throw it again.
	Haxe will try to rethrow an original native exception whenever possible.
	```haxe
	try {
		var a:Array<Int> = null;
		a.push(1); // generates target-specific null-pointer exception
	} catch(e:haxe.Exception) {
		throw e; // rethrows native exception instead of haxe.Exception
	}
	```]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="haxe.Int32" params="" file="D:\Haxe\haxe\std/haxe/Int32.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="Int"/></icast>
			<icast field="toFloat"><x path="Float"/></icast>
		</to>
		<haxe_doc>Int32 provides a 32-bit integer with consistent overflow behavior across
	all platforms.</haxe_doc>
		<meta><m n=":transitive"/></meta>
		<impl><class path="haxe._Int32.Int32_Impl_" params="" file="D:\Haxe\haxe\std/haxe/Int32.hx" private="1" module="haxe.Int32" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe._Int64.___Int64" params="" file="D:\Haxe\haxe\std/cpp/_std/haxe/Int64.hx" private="1" module="haxe.Int64" extern="1">
		<make public="1" set="method" static="1">
			<f a="high:low">
				<x path="haxe.Int32"/>
				<x path="haxe.Int32"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_make"</e></m></meta>
		</make>
		<ofInt public="1" set="method" static="1">
			<f a="value">
				<x path="Int"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>" ::cpp::Int64Struct"</e></m></meta>
		</ofInt>
		<isInt64 public="1" set="method" static="1">
			<f a="d">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>" ::cpp::Int64Struct::is"</e></m></meta>
		</isInt64>
		<isNeg public="1" set="method" static="1">
			<f a="a">
				<t path="haxe._Int64.__Int64"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_is_neg"</e></m></meta>
		</isNeg>
		<isZero public="1" set="method" static="1">
			<f a="a">
				<t path="haxe._Int64.__Int64"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_is_zero"</e></m></meta>
		</isZero>
		<compare public="1" set="method" static="1">
			<f a="a:b">
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_compare"</e></m></meta>
		</compare>
		<ucompare public="1" set="method" static="1">
			<f a="a:b">
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_ucompare"</e></m></meta>
		</ucompare>
		<toString public="1" set="method" static="1">
			<f a="a">
				<t path="haxe._Int64.__Int64"/>
				<c path="String"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_to_string"</e></m></meta>
		</toString>
		<neg public="1" set="method" static="1">
			<f a="a">
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_neg"</e></m></meta>
		</neg>
		<preIncrement public="1" set="method" static="1">
			<f a="a">
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_pre_increment"</e></m></meta>
		</preIncrement>
		<postIncrement public="1" set="method" static="1">
			<f a="a">
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_post_increment"</e></m></meta>
		</postIncrement>
		<preDecrement public="1" set="method" static="1">
			<f a="a">
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_pre_decrement"</e></m></meta>
		</preDecrement>
		<postDecrement public="1" set="method" static="1">
			<f a="a">
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_post_decrement"</e></m></meta>
		</postDecrement>
		<add public="1" set="method" static="1">
			<f a="a:b">
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_add"</e></m></meta>
		</add>
		<addInt public="1" set="method" static="1">
			<f a="a:b">
				<t path="haxe._Int64.__Int64"/>
				<x path="Int"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_add"</e></m></meta>
		</addInt>
		<sub public="1" set="method" static="1">
			<f a="a:b">
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_sub"</e></m></meta>
		</sub>
		<subInt public="1" set="method" static="1">
			<f a="a:b">
				<t path="haxe._Int64.__Int64"/>
				<x path="Int"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_sub"</e></m></meta>
		</subInt>
		<intSub public="1" set="method" static="1">
			<f a="a:b">
				<x path="Int"/>
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_sub"</e></m></meta>
		</intSub>
		<mul public="1" set="method" static="1">
			<f a="a:b">
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_mul"</e></m></meta>
		</mul>
		<div public="1" set="method" static="1">
			<f a="a:b">
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_div"</e></m></meta>
		</div>
		<mod public="1" set="method" static="1">
			<f a="a:b">
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_mod"</e></m></meta>
		</mod>
		<eq public="1" set="method" static="1">
			<f a="a:b">
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_eq"</e></m></meta>
		</eq>
		<eqInt public="1" set="method" static="1">
			<f a="a:b">
				<t path="haxe._Int64.__Int64"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_eq"</e></m></meta>
		</eqInt>
		<neq public="1" set="method" static="1">
			<f a="a:b">
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_neq"</e></m></meta>
		</neq>
		<neqInt public="1" set="method" static="1">
			<f a="a:b">
				<t path="haxe._Int64.__Int64"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_neq"</e></m></meta>
		</neqInt>
		<complement public="1" set="method" static="1">
			<f a="a">
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_complement"</e></m></meta>
		</complement>
		<bitAnd public="1" set="method" static="1">
			<f a="a:b">
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_and"</e></m></meta>
		</bitAnd>
		<bitOr public="1" set="method" static="1">
			<f a="a:b">
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_or"</e></m></meta>
		</bitOr>
		<bitXor public="1" set="method" static="1">
			<f a="a:b">
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_xor"</e></m></meta>
		</bitXor>
		<shl public="1" set="method" static="1">
			<f a="a:b">
				<t path="haxe._Int64.__Int64"/>
				<x path="Int"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_shl"</e></m></meta>
		</shl>
		<shr public="1" set="method" static="1">
			<f a="a:b">
				<t path="haxe._Int64.__Int64"/>
				<x path="Int"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_shr"</e></m></meta>
		</shr>
		<ushr public="1" set="method" static="1">
			<f a="a:b">
				<t path="haxe._Int64.__Int64"/>
				<x path="Int"/>
				<t path="haxe._Int64.__Int64"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_ushr"</e></m></meta>
		</ushr>
		<high public="1" set="method" static="1">
			<f a="a">
				<t path="haxe._Int64.__Int64"/>
				<x path="haxe.Int32"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_high"</e></m></meta>
		</high>
		<low public="1" set="method" static="1">
			<f a="a">
				<t path="haxe._Int64.__Int64"/>
				<x path="haxe.Int32"/>
			</f>
			<meta><m n=":native"><e>"_hx_int64_low"</e></m></meta>
		</low>
		<meta>
			<m n=":notNull"/>
			<m n=":include"><e>"cpp/Int64.h"</e></m>
			<m n=":native"><e>"cpp::Int64Struct"</e></m>
		</meta>
	</class>
	<typedef path="haxe._Int64.__Int64" params="" file="D:\Haxe\haxe\std/cpp/_std/haxe/Int64.hx" private="1" module="haxe.Int64"><c path="haxe._Int64.___Int64"/></typedef>
	<abstract path="haxe.Int64" params="" file="D:\Haxe\haxe\std/cpp/_std/haxe/Int64.hx">
		<from>
			<icast><t path="haxe._Int64.__Int64"/></icast>
			<icast field="ofInt"><x path="Int"/></icast>
		</from>
		<this><t path="haxe._Int64.__Int64"/></this>
		<to><icast><t path="haxe._Int64.__Int64"/></icast></to>
		<meta>
			<m n=":coreApi"/>
			<m n=":transitive"/>
		</meta>
		<impl><class path="haxe._Int64.Int64_Impl_" params="" file="D:\Haxe\haxe\std/cpp/_std/haxe/Int64.hx" private="1" module="haxe.Int64" final="1"><meta>
	<m n=":keep"/>
	<m n=":coreApi"/>
</meta></class></impl>
	</abstract>
	<class path="haxe.NativeStackTrace" params="" file="D:\Haxe\haxe\std/cpp/_std/haxe/NativeStackTrace.hx">
		<saveStack public="1" get="inline" set="null" line="12" static="1">
			<f a="exception">
				<x path="Any"/>
				<x path="Void"/>
			</f>
			<meta><m n=":ifFeature"><e>"haxe.NativeStackTrace.exceptionStack"</e></m></meta>
		</saveStack>
		<callStack public="1" set="method" line="16" static="1">
			<f a=""><c path="Array"><c path="String"/></c></f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":noDebug"/>
			</meta>
		</callStack>
		<exceptionStack public="1" set="method" line="21" static="1">
			<f a=""><c path="Array"><c path="String"/></c></f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":noDebug"/>
			</meta>
		</exceptionStack>
		<haxe_doc>Do not use manually.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
		</meta>
	</class>
	<typedef path="haxe.PosInfos" params="" file="D:\Haxe\haxe\std/haxe/PosInfos.hx">
		<a>
			<methodName><c path="String"/></methodName>
			<lineNumber><x path="Int"/></lineNumber>
			<fileName><c path="String"/></fileName>
			<customParams>
				<x path="Null"><c path="Array"><d/></c></x>
				<meta><m n=":optional"/></meta>
			</customParams>
			<className><c path="String"/></className>
		</a>
		<haxe_doc>`PosInfos` is a magic type which can be used to generate position information
	into the output for debugging use.

	If a function has a final optional argument of this type, i.e.
	`(..., ?pos:haxe.PosInfos)`, each call to that function which does not assign
	a value to that argument has its position added as call argument.

	This can be used to track positions of calls in e.g. a unit testing
	framework.</haxe_doc>
	</typedef>
	<class path="haxe.ValueException" params="" file="D:\Haxe\haxe\std/haxe/ValueException.hx">
		<extends path="haxe.Exception"/>
		<value public="1" set="null">
			<x path="Any"/>
			<haxe_doc>Thrown value.</haxe_doc>
		</value>
		<unwrap set="method" line="35" override="1">
			<f a=""><x path="Any"/></f>
			<haxe_doc>Extract an originally thrown value.

		This method must return the same value on subsequent calls.
		Used internally for catching non-native exceptions.
		Do _not_ override unless you know what you are doing.</haxe_doc>
		</unwrap>
		<new public="1" set="method" line="23"><f a="value:?previous:?native">
	<x path="Any"/>
	<c path="haxe.Exception"/>
	<x path="Any"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>An exception containing arbitrary value.

	This class is automatically used for throwing values, which don't extend `haxe.Exception`
	or native exception type.
	For example:
	```haxe
	throw "Terrible error";
	```
	will be compiled to
	```haxe
	throw new ValueException("Terrible error");
	```</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.ds.TreeNode" params="K:V" file="D:\Haxe\haxe\std/haxe/ds/BalancedTree.hx" module="haxe.ds.BalancedTree">
		<left public="1"><c path="haxe.ds.TreeNode">
	<c path="haxe.ds.TreeNode.K"/>
	<c path="haxe.ds.TreeNode.V"/>
</c></left>
		<right public="1"><c path="haxe.ds.TreeNode">
	<c path="haxe.ds.TreeNode.K"/>
	<c path="haxe.ds.TreeNode.V"/>
</c></right>
		<key public="1"><c path="haxe.ds.TreeNode.K"/></key>
		<value public="1"><c path="haxe.ds.TreeNode.V"/></value>
		<_height><x path="Int"/></_height>
		<get_height public="1" get="inline" set="null" line="264"><f a=""><x path="Int"/></f></get_height>
		<new public="1" set="method" line="252">
			<f a="l:k:v:r:?h" v="::::-1">
				<c path="haxe.ds.TreeNode">
					<c path="haxe.ds.TreeNode.K"/>
					<c path="haxe.ds.TreeNode.V"/>
				</c>
				<c path="haxe.ds.TreeNode.K"/>
				<c path="haxe.ds.TreeNode.V"/>
				<c path="haxe.ds.TreeNode">
					<c path="haxe.ds.TreeNode.K"/>
					<c path="haxe.ds.TreeNode.V"/>
				</c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ h : -1 }</e></m></meta>
		</new>
		<haxe_doc>A tree node of `haxe.ds.BalancedTree`.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<abstract path="haxe.ds.HashMap" params="K:V" file="D:\Haxe\haxe\std/haxe/ds/HashMap.hx">
		<this><c path="haxe.ds._HashMap.HashMapData">
	<c path="haxe.ds.HashMap.K"/>
	<c path="haxe.ds.HashMap.V"/>
</c></this>
		<haxe_doc>HashMap allows mapping of hashable objects to arbitrary values.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
		<impl><class path="haxe.ds._HashMap.HashMap_Impl_" params="" file="D:\Haxe\haxe\std/haxe/ds/HashMap.hx" private="1" module="haxe.ds.HashMap" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.ds.Map" params="K:V" file="D:\Haxe\haxe\std/haxe/ds/Map.hx">
		<from>
			<icast field="fromStringMap"><c path="haxe.ds.StringMap"><c path="fromStringMap.V"/></c></icast>
			<icast field="fromIntMap"><c path="haxe.ds.IntMap"><c path="fromIntMap.V"/></c></icast>
			<icast field="fromObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="fromObjectMap.K"/>
	<c path="fromObjectMap.V"/>
</c></icast>
		</from>
		<this><c path="haxe.IMap">
	<c path="haxe.ds.Map.K"/>
	<c path="haxe.ds.Map.V"/>
</c></this>
		<to>
			<icast field="toStringMap"><c path="haxe.ds.StringMap"><c path="toStringMap.V"/></c></icast>
			<icast field="toIntMap"><c path="haxe.ds.IntMap"><c path="toIntMap.V"/></c></icast>
			<icast field="toEnumValueMapMap"><c path="haxe.ds.EnumValueMap">
	<c path="toEnumValueMapMap.K"/>
	<c path="toEnumValueMapMap.V"/>
</c></icast>
			<icast field="toObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="toObjectMap.K"/>
	<c path="toObjectMap.V"/>
</c></icast>
		</to>
		<haxe_doc><![CDATA[Map allows key to value mapping for arbitrary value types, and many key
	types.

	This is a multi-type abstract, it is instantiated as one of its
	specialization types depending on its type parameters.

	A Map can be instantiated without explicit type parameters. Type inference
	will then determine the type parameters from the usage.

	Maps can also be created with `[key1 => value1, key2 => value2]` syntax.

	Map is an abstract type, it is not available at runtime.

	@see https://haxe.org/manual/std-Map.html]]></haxe_doc>
		<meta>
			<m n=":transitive"/>
			<m n=":multiType"><e>@:followWithAbstracts K</e></m>
		</meta>
		<impl><class path="haxe.ds._Map.Map_Impl_" params="" file="D:\Haxe\haxe\std/haxe/ds/Map.hx" private="1" module="haxe.ds.Map" final="1">
	<_new public="1" set="method" static="1">
		<f a=""><x path="haxe.ds.Map">
	<c path="haxe.ds.Map.K"/>
	<c path="haxe.ds.Map.V"/>
</x></f>
		<meta><m n=":noCompletion"/></meta>
		<haxe_doc>Creates a new Map.

		This becomes a constructor call to one of the specialization types in
		the output. The rules for that are as follows:

		1. if `K` is a `String`, `haxe.ds.StringMap` is used
		2. if `K` is an `Int`, `haxe.ds.IntMap` is used
		3. if `K` is an `EnumValue`, `haxe.ds.EnumValueMap` is used
		4. if `K` is any other class or structure, `haxe.ds.ObjectMap` is used
		5. if `K` is any other type, it causes a compile-time error

		(Cpp) Map does not use weak keys on `ObjectMap` by default.</haxe_doc>
	</_new>
	<meta><m n=":keep"/></meta>
</class></impl>
	</abstract>
	<class path="haxe.ds._Map.Map_Impl_" params="" file="D:\Haxe\haxe\std/haxe/ds/Map.hx" private="1" module="haxe.ds.Map" final="1">
		<_new public="1" set="method" static="1">
			<f a=""><x path="haxe.ds.Map">
	<c path="haxe.ds.Map.K"/>
	<c path="haxe.ds.Map.V"/>
</x></f>
			<meta><m n=":noCompletion"/></meta>
			<haxe_doc>Creates a new Map.

		This becomes a constructor call to one of the specialization types in
		the output. The rules for that are as follows:

		1. if `K` is a `String`, `haxe.ds.StringMap` is used
		2. if `K` is an `Int`, `haxe.ds.IntMap` is used
		3. if `K` is an `EnumValue`, `haxe.ds.EnumValueMap` is used
		4. if `K` is any other class or structure, `haxe.ds.ObjectMap` is used
		5. if `K` is any other type, it causes a compile-time error

		(Cpp) Map does not use weak keys on `ObjectMap` by default.</haxe_doc>
		</_new>
		<meta><m n=":keep"/></meta>
	</class>
	<abstract path="haxe.ds.ReadOnlyArray" params="T" file="D:\Haxe\haxe\std/haxe/ds/ReadOnlyArray.hx">
		<from><icast><c path="Array"><c path="haxe.ds.ReadOnlyArray.T"/></c></icast></from>
		<this><c path="Array"><c path="haxe.ds.ReadOnlyArray.T"/></c></this>
		<to><icast><t path="Iterable"><c path="haxe.ds.ReadOnlyArray.T"/></t></icast></to>
		<haxe_doc>`ReadOnlyArray` is an abstract over an ordinary `Array` which only exposes
	APIs that don't modify the instance, hence "read-only".

	Note that this doesn't necessarily mean that the instance is *immutable*.
	Other code holding a reference to the underlying `Array` can still modify it,
	and the reference can be obtained with a `cast`.</haxe_doc>
		<meta><m n=":forward">
	<e>copy</e>
	<e>filter</e>
	<e>indexOf</e>
	<e>iterator</e>
	<e>keyValueIterator</e>
	<e>join</e>
	<e>lastIndexOf</e>
	<e>map</e>
	<e>slice</e>
	<e>contains</e>
	<e>toString</e>
</m></meta>
		<impl><class path="haxe.ds._ReadOnlyArray.ReadOnlyArray_Impl_" params="" file="D:\Haxe\haxe\std/haxe/ds/ReadOnlyArray.hx" private="1" module="haxe.ds.ReadOnlyArray" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.ds.StringMap" params="T" file="D:\Haxe\haxe\std/cpp/_std/haxe/ds/StringMap.hx">
		<implements path="haxe.IMap">
			<c path="String"/>
			<c path="haxe.ds.StringMap.T"/>
		</implements>
		<h>
			<d/>
			<meta><m n=":ifFeature"><e>"haxe.ds.StringMap.*"</e></m></meta>
		</h>
		<set public="1" set="method" line="60">
			<f a="key:value">
				<c path="String"/>
				<c path="haxe.ds.StringMap.T"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<get public="1" set="method" line="64">
			<f a="key">
				<c path="String"/>
				<x path="Null"><c path="haxe.ds.StringMap.T"/></x>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<exists public="1" set="method" line="68">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<remove public="1" set="method" line="72">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<keys public="1" set="method" line="76">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.keys`

		(cs, java) Implementation detail: Do not `set()` any new value while
		iterating, as it may cause a resize, which will break iteration.</haxe_doc>
		</keys>
		<clear public="1" set="method" line="101">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.clear`</haxe_doc>
		</clear>
		<new public="1" set="method" line="58">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new StringMap.</haxe_doc>
		</new>
		<haxe_doc>StringMap allows mapping of String keys to arbitrary values.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":headerClassCode"><e><![CDATA["\r\n  inline void set(String key, ::null value) { __string_hash_set(HX_MAP_THIS,key,value); }\r\n  inline void set(String key, bool value) { __string_hash_set(HX_MAP_THIS,key,value); }\r\n  inline void set(String key, char value) { __string_hash_set_int(HX_MAP_THIS,key,value); }\r\n  inline void set(String key, unsigned char value) { __string_hash_set_int(HX_MAP_THIS,key,value); }\r\n  inline void set(String key, signed char value) { __string_hash_set_int(HX_MAP_THIS,key,value); }\r\n  inline void set(String key, short value) { __string_hash_set_int(HX_MAP_THIS,key,value); }\r\n  inline void set(String key, unsigned short value) { __string_hash_set_int(HX_MAP_THIS,key,value); }\r\n  inline void set(String key, int value) { __string_hash_set_int(HX_MAP_THIS,key,value); }\r\n  inline void set(String key, unsigned int value) { __string_hash_set_int(HX_MAP_THIS,key,value); }\r\n  inline void set(String key, float value) { __string_hash_set_float(HX_MAP_THIS,key,value); }\r\n  inline void set(String key, double value) { __string_hash_set_float(HX_MAP_THIS,key,value); }\r\n  inline void set(String key, ::String value) { __string_hash_set_string(HX_MAP_THIS,key,value); }\r\n\r\n  template<typename V, typename H>\r\n  inline void set(String key, const ::cpp::Struct<V,H> &value) {__string_hash_set(HX_MAP_THIS,key,value); }\r\n  template<typename V>\r\n  inline void set(String key, const ::cpp::Function<V> &value) {__string_hash_set(HX_MAP_THIS,key,(Dynamic)value ); }\r\n  template<typename V>\r\n  inline void set(String key, const ::cpp::Pointer<V> &value) {__string_hash_set(HX_MAP_THIS,key,(Dynamic)value ); }\r\n\r\n  template<typename VALUE>\r\n  inline void set(Dynamic &key, const VALUE &value) { set( (String)key, value ); }\r\n\r\n  inline bool get_bool(String key) { return __string_hash_get_bool(h,key); }\r\n  inline int get_int(String key) { return __string_hash_get_int(h,key); }\r\n  inline Float get_float(String key) { return __string_hash_get_float(h,key); }\r\n  inline String get_string(String key) { return __string_hash_get_string(h,key); }\r\n"]]></e></m>
			<m n=":coreApi"/>
		</meta>
	</class>
	<typedef path="haxe.ds._Vector.VectorData" params="T" file="D:\Haxe\haxe\std/haxe/ds/Vector.hx" private="1" module="haxe.ds.Vector"><c path="Array"><c path="haxe.ds._Vector.VectorData.T"/></c></typedef>
	<abstract path="haxe.ds.Vector" params="T" file="D:\Haxe\haxe\std/haxe/ds/Vector.hx">
		<this><t path="haxe.ds._Vector.VectorData"><c path="haxe.ds.Vector.T"/></t></this>
		<haxe_doc>A Vector is a storage of fixed size. It can be faster than Array on some
	targets, and is never slower.

	@see https://haxe.org/manual/std-vector.html</haxe_doc>
		<impl><class path="haxe.ds._Vector.Vector_Impl_" params="" file="D:\Haxe\haxe\std/haxe/ds/Vector.hx" private="1" module="haxe.ds.Vector" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.exceptions.PosException" params="" file="D:\Haxe\haxe\std/haxe/exceptions/PosException.hx">
		<extends path="haxe.Exception"/>
		<posInfos final="1" public="1">
			<t path="haxe.PosInfos"/>
			<haxe_doc>Position where this exception was created.</haxe_doc>
		</posInfos>
		<toString public="1" set="method" line="24" override="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns exception message.</haxe_doc>
		</toString>
		<new public="1" set="method" line="12"><f a="message:?previous:?pos">
	<c path="String"/>
	<c path="haxe.Exception"/>
	<x path="Null"><t path="haxe.PosInfos"/></x>
	<x path="Void"/>
</f></new>
		<haxe_doc>An exception that carry position information of a place where it was created.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.exceptions.NotImplementedException" params="" file="D:\Haxe\haxe\std/haxe/exceptions/NotImplementedException.hx">
		<extends path="haxe.exceptions.PosException"/>
		<new public="1" set="method" line="7">
			<f a="?message:?previous:?pos" v="&quot;Not implemented&quot;::">
				<c path="String"/>
				<c path="haxe.Exception"/>
				<x path="Null"><t path="haxe.PosInfos"/></x>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ message : "Not implemented" }</e></m></meta>
		</new>
		<haxe_doc>An exception that is thrown when requested function or operation does not have an implementation.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="haxe.extern.AsVar" params="T" file="D:\Haxe\haxe\std/haxe/extern/AsVar.hx">
		<from><icast><c path="haxe.extern.AsVar.T"/></icast></from>
		<this><c path="haxe.extern.AsVar.T"/></this>
		<to><icast><c path="haxe.extern.AsVar.T"/></icast></to>
		<haxe_doc>If this type is used as an argument type, the compiler ensures that
	argument expressions are bound to a local variable.</haxe_doc>
		<meta>
			<m n=":forward"/>
			<m n=":transitive"/>
			<m n=":semantics"><e>variable</e></m>
		</meta>
		<impl><class path="haxe.extern._AsVar.AsVar_Impl_" params="" file="D:\Haxe\haxe\std/haxe/extern/AsVar.hx" private="1" module="haxe.extern.AsVar" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.io.Bytes" params="" file="D:\Haxe\haxe\std/haxe/io/Bytes.hx">
		<alloc public="1" set="method" line="549" static="1">
			<f a="length">
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>Returns a new `Bytes` instance with the given `length`. The values of the
		bytes are not initialized and may not be zero.</haxe_doc>
		</alloc>
		<ofString public="1" set="method" line="580" static="1">
			<f a="s:?encoding">
				<c path="String"/>
				<e path="haxe.io.Encoding"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the `Bytes` representation of the given `String`, using the
		specified encoding (UTF-8 by default).</haxe_doc>
		</ofString>
		<length public="1" set="null"><x path="Int"/></length>
		<b><t path="haxe.io.BytesData"/></b>
		<new set="method" line="34"><f a="length:b">
	<x path="Int"/>
	<t path="haxe.io.BytesData"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<typedef path="haxe.io.BytesData" params="" file="D:\Haxe\haxe\std/haxe/io/BytesData.hx"><c path="Array"><x path="cpp.UInt8"/></c></typedef>
	<enum path="haxe.io.Encoding" params="" file="D:\Haxe\haxe\std/haxe/io/Encoding.hx">
		<UTF8/>
		<RawNative><haxe_doc>Output the string the way the platform represent it in memory. This is the most efficient but is platform-specific</haxe_doc></RawNative>
		<haxe_doc>String binary encoding supported by Haxe I/O</haxe_doc>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="haxe.io.Eof" params="" file="D:\Haxe\haxe\std/haxe/io/Eof.hx">
		<toString set="method" line="32">
			<f a=""><c path="String"/></f>
			<meta><m n=":ifFeature"><e>"haxe.io.Eof.*"</e></m></meta>
		</toString>
		<new public="1" set="method" line="29"><f a=""><x path="Void"/></f></new>
		<haxe_doc>This exception is raised when reading while data is no longer available in the `haxe.io.Input`.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<enum path="haxe.io.Error" params="" file="D:\Haxe\haxe\std/haxe/io/Error.hx">
		<Blocked><haxe_doc>The IO is set into nonblocking mode and some data cannot be read or written</haxe_doc></Blocked>
		<Overflow><haxe_doc>An integer value is outside its allowed range</haxe_doc></Overflow>
		<OutsideBounds><haxe_doc>An operation on Bytes is outside of its valid range</haxe_doc></OutsideBounds>
		<Custom a="e">
			<d/>
			<haxe_doc>Other errors</haxe_doc>
		</Custom>
		<haxe_doc>The possible IO errors that can occur</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="haxe.io.Input" params="" file="D:\Haxe\haxe\std/haxe/io/Input.hx">
		<readByte public="1" set="method" line="49">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Read and return one byte.</haxe_doc>
		</readByte>
		<readBytes public="1" set="method" line="64">
			<f a="s:pos:len">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Read `len` bytes and write them into `s` to the position specified by `pos`.

		Returns the actual length of read data that can be smaller than `len`.

		See `readFullBytes` that tries to read the exact amount of specified bytes.</haxe_doc>
		</readBytes>
		<close public="1" set="method" line="92">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Close the input source.

		Behaviour while reading after calling this method is unspecified.</haxe_doc>
		</close>
		<haxe_doc>An Input is an abstract reader. See other classes in the `haxe.io` package
	for several possible implementations.

	All functions which read data throw `Eof` when the end of the stream
	is reached.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.io.Output" params="" file="D:\Haxe\haxe\std/haxe/io/Output.hx">
		<writeByte public="1" set="method" line="46">
			<f a="c">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write one byte.</haxe_doc>
		</writeByte>
		<writeBytes public="1" set="method" line="57">
			<f a="s:pos:len">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Write `len` bytes from `s` starting by position specified by `pos`.

		Returns the actual length of written data that can differ from `len`.

		See `writeFullBytes` that tries to write the exact amount of specified bytes.</haxe_doc>
		</writeBytes>
		<close public="1" set="method" line="92">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Close the output.

		Behaviour while writing after calling this method is unspecified.</haxe_doc>
		</close>
		<writeFullBytes public="1" set="method" line="120">
			<f a="s:pos:len">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write `len` bytes from `s` starting by position specified by `pos`.

		Unlike `writeBytes`, this method tries to write the exact `len` amount of bytes.</haxe_doc>
		</writeFullBytes>
		<writeInput public="1" set="method" line="254">
			<f a="i:?bufsize">
				<c path="haxe.io.Input"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Read all available data from `i` and write it.

		The `bufsize` optional argument specifies the size of chunks by
		which data is read and written. Its default value is 4096.</haxe_doc>
		</writeInput>
		<writeString public="1" set="method" line="278">
			<f a="s:?encoding">
				<c path="String"/>
				<e path="haxe.io.Encoding"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write `s` string.</haxe_doc>
		</writeString>
		<haxe_doc>An Output is an abstract write. A specific output implementation will only
	have to override the `writeByte` and maybe the `write`, `flush` and `close`
	methods. See `File.write` and `String.write` for two ways of creating an
	Output.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.io.Path" params="" file="D:\Haxe\haxe\std/haxe/io/Path.hx">
		<directory public="1" set="method" line="147" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the directory of `path`.

		If the directory is `null`, the empty String `""` is returned.

		If `path` is `null`, the result is unspecified.</haxe_doc>
		</directory>
		<join public="1" set="method" line="189" static="1">
			<f a="paths">
				<c path="Array"><c path="String"/></c>
				<c path="String"/>
			</f>
			<haxe_doc>Joins all paths in `paths` together.

		If `paths` is empty, the empty String `""` is returned. Otherwise the
		paths are joined with a slash between them.

		If `paths` is `null`, the result is unspecified.</haxe_doc>
		</join>
		<normalize public="1" set="method" line="210" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Normalize a given `path` (e.g. turn `'/usr/local/../lib'` into `'/usr/lib'`).

		Also replaces backslashes `\` with slashes `/` and afterwards turns
		multiple slashes into a single one.

		If `path` is `null`, the result is unspecified.</haxe_doc>
		</normalize>
		<addTrailingSlash public="1" set="method" line="271" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Adds a trailing slash to `path`, if it does not have one already.

		If the last slash in `path` is a backslash, a backslash is appended to
		`path`.

		If the last slash in `path` is a slash, or if no slash is found, a slash
		is appended to `path`. In particular, this applies to the empty String
		`""`.

		If `path` is `null`, the result is unspecified.</haxe_doc>
		</addTrailingSlash>
		<removeTrailingSlashes public="1" set="method" line="299" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes trailing slashes from `path`.

		If `path` does not end with a `/` or `\`, `path` is returned unchanged.

		Otherwise the substring of `path` excluding the trailing slashes or
		backslashes is returned.

		If `path` is `null`, the result is unspecified.</haxe_doc>
		</removeTrailingSlashes>
		<dir public="1">
			<x path="Null"><c path="String"/></x>
			<haxe_doc>The directory.

		This is the leading part of the path that is not part of the file name
		and the extension.

		Does not end with a `/` or `\` separator.

		If the path has no directory, the value is `null`.</haxe_doc>
		</dir>
		<file public="1">
			<c path="String"/>
			<haxe_doc>The file name.

		This is the part of the part between the directory and the extension.

		If there is no file name, e.g. for `".htaccess"` or `"/dir/"`, the value
		is the empty String `""`.</haxe_doc>
		</file>
		<ext public="1">
			<x path="Null"><c path="String"/></x>
			<haxe_doc>The file extension.

		It is separated from the file name by a dot. This dot is not part of
		the extension.

		If the path has no extension, the value is `null`.</haxe_doc>
		</ext>
		<backslash public="1">
			<x path="Bool"/>
			<haxe_doc>`true` if the last directory separator is a backslash, `false` otherwise.</haxe_doc>
		</backslash>
		<toString public="1" set="method" line="114">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String representation of `this` path.

		If `this.backslash` is `true`, backslash is used as directory separator,
		otherwise slash is used. This only affects the separator between
		`this.dir` and `this.file`.

		If `this.directory` or `this.extension` is `null`, their representation
		is the empty String `""`.</haxe_doc>
		</toString>
		<new public="1" set="method" line="76">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new `Path` instance by parsing `path`.

		Path information can be retrieved by accessing the `dir`, `file` and `ext`
		properties.</haxe_doc>
		</new>
		<haxe_doc>This class provides a convenient way of working with paths. It supports the
	common path formats:

	- `directory1/directory2/filename.extension`
	- `directory1\directory2\filename.extension`</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.iterators.ArrayIterator" params="T" file="D:\Haxe\haxe\std/haxe/iterators/ArrayIterator.hx">
		<array final="1"><c path="Array"><c path="haxe.iterators.ArrayIterator.T"/></c></array>
		<current expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</current>
		<hasNext public="1" get="inline" set="null" line="44">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>See `Iterator.hasNext`</haxe_doc>
		</hasNext>
		<next public="1" get="inline" set="null" line="52">
			<f a=""><c path="haxe.iterators.ArrayIterator.T"/></f>
			<haxe_doc>See `Iterator.next`</haxe_doc>
		</next>
		<new public="1" get="inline" set="null" line="35">
			<f a="array">
				<c path="Array"><c path="haxe.iterators.ArrayIterator.T"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>Create a new `ArrayIterator`.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[This iterator is used only when `Array<T>` is passed to `Iterable<T>`]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="hxray.Main" params="" file="hxray/Main.hx">
		<main set="method" line="8" static="1"><f a=""><x path="Void"/></f></main>
		<meta><m n=":dox"><e>hide</e></m></meta>
	</class>
	<class path="hxray.RlVector2" params="" file="hxray/RgBindingFix.hx" module="hxray.RgBindingFix" extern="1">
		<create public="1" get="inline" set="null" line="13" static="1">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<t path="Vector2"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</create>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<meta>
			<m n=":include"><e>"raylib.h"</e></m>
			<m n=":native"><e>"Vector2"</e></m>
			<m n=":structAccess"/>
		</meta>
	</class>
	<class path="hxray.RgControls" params="" file="hxray/RgControls.hx">
		<actionMap public="1" set="null" static="1">
			<t path="Map">
				<c path="String"/>
				<c path="Array"><x path="Int"/></c>
			</t>
			<haxe_doc>* Map of keycodes to actions</haxe_doc>
		</actionMap>
		<keyMapPath public="1" static="1">
			<c path="String"/>
			<haxe_doc>* Path to the keymap, used for reloading and saving</haxe_doc>
		</keyMapPath>
		<readKeyMap public="1" set="method" line="25" static="1">
			<f a="?filePath" v="&quot;./assets/keymap.txt&quot;">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ filePath : "./assets/keymap.txt" }</e></m></meta>
			<haxe_doc>* Reads the keymap from a file
     * @param filePath path to the keymap relative to the exe</haxe_doc>
		</readKeyMap>
		<bindSingleAction public="1" set="method" line="56" static="1">
			<f a="action:keyCodes">
				<c path="String"/>
				<c path="Array"><x path="Int"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Rebinds an action, will delete any existing binding.
     * @param action the action to bind
     * @param keyCodes the keycodes to use</haxe_doc>
		</bindSingleAction>
		<unbindSingleAction public="1" set="method" line="64" static="1">
			<f a="action">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Unbinds an action.
     * @param action the action to unbind</haxe_doc>
		</unbindSingleAction>
		<saveToKeyMap public="1" set="method" line="72" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Saves the current ActionMap to a file.</haxe_doc>
		</saveToKeyMap>
		<reloadKeyMap public="1" set="method" line="92" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Reloads the actionmap</haxe_doc>
		</reloadKeyMap>
		<isDown public="1" set="method" line="121" static="1">
			<f a="action">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Checks whether any key of an action is pressed.
     * @param action the action to check
     * @return true if the action is pressed</haxe_doc>
		</isDown>
		<isUp public="1" set="method" line="137" static="1">
			<f a="action">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Checks whether any key of an action isn't down.
     * @param action the action to check
     * @return true if the action is pressed</haxe_doc>
		</isUp>
		<haxe_doc>* Class used for mapping controls to certain actions</haxe_doc>
	</class>
	<class path="hxray.RgGame" params="" file="hxray/RgGame.hx">
		<main set="method" line="15" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</main>
		<new public="1" set="method" line="27">
			<f a="sc:width:height:title:targetFPS">
				<c path="hxray.RgScene"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Makes a new instance of a game. does everything like setting up the window.
     * @param sc The scene you want to start on
     * @param width The width of the window
     * @param height The height of the window
     * @param title The title of the window
     * @param targetFPS The max FPS</haxe_doc>
		</new>
		<haxe_doc>* Basic game object.</haxe_doc>
	</class>
	<class path="hxray.RgGlobal" params="" file="hxray/RgGlobal.hx">
		<windowWidth public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":allow"><e>hxray.RgGame</e></m></meta>
		</windowWidth>
		<windowHeight public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":allow"><e>hxray.RgGame</e></m></meta>
		</windowHeight>
		<targetFPS public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":allow"><e>hxray.RgGame</e></m></meta>
		</targetFPS>
		<bgColor public="1" static="1"><t path="Color"/></bgColor>
		<bugreportline public="1" expr="&quot;[PUT BUG REPORT INSTRUCTIONS HERE BY EDITING RgGlobal.bugreportline]&quot;" line="21" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"[PUT BUG REPORT INSTRUCTIONS HERE BY EDITING RgGlobal.bugreportline]"</e></m></meta>
			<haxe_doc>* Used incase RayGen sends you to the error screen.
     * 
     * Gets placed at the end of the error screen. use for bug reporting instructions.</haxe_doc>
		</bugreportline>
		<haxe_doc>* Contains some global variables and functions you would commonly use in games.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxray.RgScene" params="" file="hxray/RgScene.hx">
		<assetQueue public="1">
			<c path="Array"><c path="hxray.assets.base.RgAsset"/></c>
			<haxe_doc>* Current registered assets. only directly modify this if you know what you're doing, use `register` and `unregister` instead.</haxe_doc>
		</assetQueue>
		<init public="1" set="method" line="27">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Does nothing by default, can be used to initialize and register your objects.</haxe_doc>
		</init>
		<update public="1" set="method" line="35">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Runs every frame, updates every asset by default.</haxe_doc>
		</update>
		<draw public="1" set="method" line="46">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Runs every frame, calls `draw` on every asset by default.</haxe_doc>
		</draw>
		<unload final="1" public="1" set="method" line="59">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* **CANNOT BE OVERRIDEN!**
     * 
     * Runs upon scene-switch. used to unload and free all the remaining resources.</haxe_doc>
		</unload>
		<register final="1" public="1" set="method" line="76">
			<f a="asset">
				<c path="hxray.assets.base.RgAsset"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* **CANNOT BE OVERRIDEN!**
     * 
     * Used to add assets to the asset-queue
     * @param asset The asset you want to add.</haxe_doc>
		</register>
		<unregister final="1" public="1" set="method" line="88">
			<f a="asset">
				<c path="hxray.assets.base.RgAsset"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* **CANNOT BE OVERRIDEN!**
     * 
     * Used to remove assets from the asset-queue. Automatically calls `unload`.
     * @param asset the asset to remove.</haxe_doc>
		</unregister>
		<new public="1" set="method" line="19">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Initializes the assetQueue. Please don't override this, use `init` instead.</haxe_doc>
		</new>
		<haxe_doc>* Basic Scene object, extend this to make a scene.</haxe_doc>
	</class>
	<typedef path="hxray.Rect" params="" file="hxray/RgTypes.hx" module="hxray.RgTypes">
		<a>
			<y><x path="Int"/></y>
			<x><x path="Int"/></x>
			<w><x path="Int"/></w>
			<h><x path="Int"/></h>
		</a>
		<haxe_doc>* Basic Rectangle, contains X, Y, Width, and Height.</haxe_doc>
	</typedef>
	<enum path="hxray.Axies" params="" file="hxray/RgTypes.hx" module="hxray.RgTypes">
		<X/>
		<Y/>
		<XY/>
		<haxe_doc>* Axies used for the `center` method on Sprites</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="hxray.ErrorStep" params="" file="hxray/RgTypes.hx" module="hxray.RgTypes">
		<DRAW/>
		<UPDATE/>
		<SCENESWITCH/>
		<UNKNOWN/>
		<TEST/>
		<haxe_doc>* Different Steps an error can happen in.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="hxray.assets.base.RgAsset" params="" file="hxray/assets/base/RgAsset.hx">
		<update public="1" set="method" line="17">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called every frame.</haxe_doc>
		</update>
		<draw public="1" set="method" line="25">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called every frame during the drawing step.</haxe_doc>
		</draw>
		<unload public="1" set="method" line="33">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called upon scene-switch or deregistration.</haxe_doc>
		</unload>
		<new public="1" set="method" line="9"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Most basic asset, no logic.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxray.assets.base.RgObject" params="" file="hxray/assets/base/RgObject.hx">
		<extends path="hxray.assets.base.RgAsset"/>
		<pos public="1">
			<t path="hxray.Rect"/>
			<haxe_doc>* Position and scaling of the object.</haxe_doc>
		</pos>
		<new public="1" set="method" line="15"><f a="x:y:w:h">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Basic object with X, Y, W, and H values.</haxe_doc>
	</class>
	<class path="hxray.assets.RgSprite" params="" file="hxray/assets/RgSprite.hx">
		<extends path="hxray.assets.base.RgObject"/>
		<_tex><t path="Texture"/></_tex>
		<color public="1" expr="Rl.Colors.WHITE">
			<t path="Color"/>
			<meta><m n=":value"><e>Rl.Colors.WHITE</e></m></meta>
			<haxe_doc>* Tint of the sprite.</haxe_doc>
		</color>
		<angle public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The rotation of the sprite</haxe_doc>
		</angle>
		<scale public="1" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* The scale of the sprite</haxe_doc>
		</scale>
		<update public="1" set="method" line="45" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Used to update internal variables upon every frame. called automatically.</haxe_doc>
		</update>
		<draw public="1" set="method" line="53" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Used to draw the sprite on every frame</haxe_doc>
		</draw>
		<unload public="1" set="method" line="66" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Used to unload and free all allocated resources, it is not recommended to override this, Called automatically upon scene switch or when un-registering the sprite.</haxe_doc>
		</unload>
		<center public="1" set="method" line="75">
			<f a="?axies">
				<e path="hxray.Axies"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Automatically centers the sprite on the scree
     * @param axies the axies to center the sprite on. Takes either `X`, `Y`, or `XY`. If left empty, `XY` is used.</haxe_doc>
		</center>
		<new public="1" set="method" line="35">
			<f a="x:y:sprite">
				<x path="Int"/>
				<x path="Int"/>
				<t path="Texture"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Constructor used to initialize internal variables. **It is not recommended to override this! use `init` instead!!**
     * @param x X position of the sprite
     * @param y Y position of the sprite
     * @param sprite Texture of the sprite</haxe_doc>
		</new>
		<haxe_doc>* A 2D texture that can be displayed on screen.</haxe_doc>
	</class>
	<class path="hxray.assets.RgText" params="" file="hxray/assets/RgText.hx">
		<extends path="hxray.assets.base.RgObject"/>
		<text public="1" expr="&quot;&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</text>
		<fontSize public="1" expr="32">
			<x path="Int"/>
			<meta><m n=":value"><e>32</e></m></meta>
		</fontSize>
		<fieldWidth public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</fieldWidth>
		<color public="1" expr="Rl.Colors.WHITE">
			<t path="Color"/>
			<meta><m n=":value"><e>Rl.Colors.WHITE</e></m></meta>
			<haxe_doc>* Color of the text.</haxe_doc>
		</color>
		<update public="1" set="method" line="40" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Used to update internal variables upon every frame. called automatically.</haxe_doc>
		</update>
		<draw public="1" set="method" line="48" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Used to draw the text on every frame, only override this if you know what you're doing!</haxe_doc>
		</draw>
		<unload public="1" set="method" line="56" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Used to unload and free all allocated resources, it is not recommended to override this, Called automatically upon scene switch or when un-registering the sprite.</haxe_doc>
		</unload>
		<center public="1" set="method" line="65">
			<f a="?axies">
				<e path="hxray.Axies"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Automatically centers the text on the screen
     * @param axies the axies to center the sprite on. Takes either `X`, `Y`, or `XY`. If left empty, `XY` is used.</haxe_doc>
		</center>
		<new public="1" set="method" line="21">
			<f a="x:y:text:?fieldWidth:?fontSize" v=":::0:32">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ fontSize : 32, fieldWidth : 0 }</e></m></meta>
		</new>
		<haxe_doc>* A 2D texture that can be displayed on screen.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxray.internal.RgErrorScene" params="" file="hxray/internal/RgErrorScene.hx">
		<extends path="hxray.RgScene"/>
		<errorCode public="1"><c path="String"/></errorCode>
		<errorStep public="1"><c path="String"/></errorStep>
		<inScene public="1"><c path="hxray.RgScene"/></inScene>
		<init public="1" set="method" line="27" override="1"><f a=""><x path="Void"/></f></init>
		<update public="1" set="method" line="38" override="1"><f a=""><x path="Void"/></f></update>
		<new public="1" set="method" line="18"><f a="errorCode:errorStep:inScene">
	<c path="String"/>
	<c path="String"/>
	<c path="hxray.RgScene"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* A screen automatically called in the event of an error.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="hxray.internal.macros.AssetBuilder" params="" file="hxray/internal/macros/AssetBuilder.hx"><meta><m n=":dox"><e>hide</e></m></meta></class>
	<class path="hxray.management.RgGameMnger" params="" file="hxray/management/RgGameMnger.hx">
		<currentScene public="1" static="1">
			<c path="hxray.RgScene"/>
			<haxe_doc>* The current loaded scene. It is recommended to not change this manually unless you know what you're doing.</haxe_doc>
		</currentScene>
		<switchScene public="1" set="method" line="21" static="1">
			<f a="scene">
				<c path="hxray.RgScene"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Used to switch scenes. Automatically calls `unload` on the last scene, and `init` on the next.
     * @param scene the scene to switch to.</haxe_doc>
		</switchScene>
		<callError public="1" set="dynamic" line="46" static="1">
			<f a="msg:step:scene">
				<c path="String"/>
				<e path="hxray.ErrorStep"/>
				<c path="hxray.RgScene"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Decides what to do in the event of an error.
     * 
     * **Can be rebound for your own logic.**
     * @param msg The error message
     * @param step The error step
     * @param scene The scene the error happened in. In the event of a SceneSwitch error, the scene the error happened in is used.</haxe_doc>
		</callError>
		<haxe_doc>* Used to switch scenes</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="massive.haxe.Exception" params="" file="D:\Haxe\haxe\lib\mlib/2,0,3/massive/haxe/Exception.hx">
		<type public="1" set="null">
			<c path="String"/>
			<haxe_doc>* The exception type. 
	 * 
	 * Should be the fully qualified name of the Exception class. e.g. 'massive.io.IOException'</haxe_doc>
		</type>
		<message public="1" set="null">
			<c path="String"/>
			<haxe_doc>* A description of the exception</haxe_doc>
		</message>
		<info public="1" set="null">
			<t path="haxe.PosInfos"/>
			<haxe_doc>* The pos infos from where the exception was created.</haxe_doc>
		</info>
		<toString public="1" set="method" line="79">
			<f a=""><c path="String"/></f>
			<haxe_doc><![CDATA[* Returns a string representation of this exception.
	 * 
	 * Format: <type>: <message> at <className>#<methodName> (<lineNumber>)]]></haxe_doc>
		</toString>
		<new public="1" set="method" line="67">
			<f a="message:?info">
				<c path="String"/>
				<t path="haxe.PosInfos"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @param	message			a description of the exception</haxe_doc>
		</new>
		<haxe_doc>* Instances of the class Exception and its subclasses, when thrown, provide information about
 * the type and location of erroneous behavior.
 * 
 * An application should lookout for and handle raised exceptions through try/catch blocks located
 * in an appropriate place.
 * 
 * @author Mike Stead</haxe_doc>
	</class>
	<class path="massive.haxe.log.ILogClient" params="" file="D:\Haxe\haxe\lib\mlib/2,0,3/massive/haxe/log/ILogClient.hx" interface="1"><print public="1" set="method"><f a="message:level">
	<c path="String"/>
	<e path="massive.haxe.log.LogLevel"/>
	<x path="Void"/>
</f></print></class>
	<class path="massive.haxe.log.LogClient" params="" file="D:\Haxe\haxe\lib\mlib/2,0,3/massive/haxe/log/LogClient.hx">
		<implements path="massive.haxe.log.ILogClient"/>
		<print public="1" set="method" line="42"><f a="message:level">
	<c path="String"/>
	<e path="massive.haxe.log.LogLevel"/>
	<x path="Void"/>
</f></print>
		<new public="1" set="method" line="37"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="massive.haxe.log.LogLevel" params="" file="D:\Haxe\haxe\lib\mlib/2,0,3/massive/haxe/log/Log.hx" module="massive.haxe.log.Log">
		<all/>
		<debug/>
		<info/>
		<warn/>
		<error/>
		<fatal/>
		<console/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="massive.haxe.log.Log" params="" file="D:\Haxe\haxe\lib\mlib/2,0,3/massive/haxe/log/Log.hx">
		<logLevel public="1" expr="LogLevel.console" line="34" static="1">
			<e path="massive.haxe.log.LogLevel"/>
			<meta><m n=":value"><e>LogLevel.console</e></m></meta>
		</logLevel>
		<logClient public="1" expr="new LogClient()" line="36" static="1">
			<c path="massive.haxe.log.ILogClient"/>
			<meta><m n=":value"><e>new LogClient()</e></m></meta>
		</logClient>
		<debug public="1" set="method" line="42" static="1"><f a="message">
	<d/>
	<x path="Void"/>
</f></debug>
		<info public="1" set="method" line="47" static="1"><f a="message">
	<d/>
	<x path="Void"/>
</f></info>
		<warn public="1" set="method" line="52" static="1"><f a="message">
	<d/>
	<x path="Void"/>
</f></warn>
		<error public="1" set="method" line="57" static="1"><f a="message">
	<d/>
	<x path="Void"/>
</f></error>
		<fatal public="1" set="method" line="62" static="1"><f a="message">
	<d/>
	<x path="Void"/>
</f></fatal>
		<console public="1" set="method" line="67" static="1"><f a="message">
	<d/>
	<x path="Void"/>
</f></console>
		<log public="1" set="method" line="72" static="1"><f a="message:?level">
	<d/>
	<e path="massive.haxe.log.LogLevel"/>
	<x path="Void"/>
</f></log>
		<convertLogLevelToInt public="1" set="method" line="88" static="1"><f a="type">
	<e path="massive.haxe.log.LogLevel"/>
	<x path="Int"/>
</f></convertLogLevelToInt>
		<convertLogLevelToString public="1" set="method" line="102" static="1"><f a="type">
	<e path="massive.haxe.log.LogLevel"/>
	<c path="String"/>
</f></convertLogLevelToString>
		<setLogLevelFromString public="1" set="method" line="116" static="1"><f a="type">
	<c path="String"/>
	<x path="Void"/>
</f></setLogLevelFromString>
		<getLogLevelFromString set="method" line="125" static="1"><f a="type">
	<c path="String"/>
	<e path="massive.haxe.log.LogLevel"/>
</f></getLogLevelFromString>
		<new public="1" set="method" line="38"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="massive.haxe.util.ReflectUtil" params="" file="D:\Haxe\haxe\lib\mlib/2,0,3/massive/haxe/util/ReflectUtil.hx">
		<here public="1" set="method" line="44" static="1">
			<f a="?info">
				<t path="haxe.PosInfos"/>
				<t path="haxe.PosInfos"/>
			</f>
			<haxe_doc>* Return information about the location this method is called.</haxe_doc>
		</here>
		<haxe_doc>* Utility class to help with reflection.
 * 
 * @author Mike Stead</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="massive.sys.io.File" params="" file="D:\Haxe\haxe\lib\mlib/2,0,3/massive/sys/io/File.hx">
		<seperator public="1" get="accessor" set="null" static="1"><c path="String"/></seperator>
		<current public="1" get="accessor" set="null" static="1"><c path="massive.sys.io.File"/></current>
		<tempCount expr="0" line="49" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</tempCount>
		<temp expr="new StringMap()" line="50" static="1">
			<c path="haxe.ds.StringMap"><c path="massive.sys.io.File"/></c>
			<meta><m n=":value"><e>new StringMap()</e></m></meta>
		</temp>
		<get_current set="method" line="53" static="1"><f a=""><c path="massive.sys.io.File"/></f></get_current>
		<get_seperator set="method" line="59" static="1"><f a=""><c path="String"/></f></get_seperator>
		<create public="1" set="method" line="71" static="1">
			<f a="path:?file:?createImmediately:?posInfos" v=":null:false:">
				<c path="String"/>
				<c path="massive.sys.io.File"/>
				<x path="Bool"/>
				<x path="Null"><t path="haxe.PosInfos"/></x>
				<c path="massive.sys.io.File"/>
			</f>
			<meta><m n=":value"><e>{ createImmediately : false, file : null }</e></m></meta>
		</create>
		<createTempFile public="1" set="method" line="112" static="1">
			<f a="?content:?extension" v="&quot;&quot;:&quot;.tmp&quot;">
				<c path="String"/>
				<c path="String"/>
				<c path="massive.sys.io.File"/>
			</f>
			<meta><m n=":value"><e>{ extension : ".tmp", content : "" }</e></m></meta>
			<haxe_doc>*  creates a temporary file in the current directory.</haxe_doc>
		</createTempFile>
		<createTempDirectory public="1" set="method" line="125" static="1">
			<f a=""><c path="massive.sys.io.File"/></f>
			<haxe_doc>*  creates a temporary directory in the current directory.</haxe_doc>
		</createTempDirectory>
		<deleteTempFiles public="1" set="method" line="143" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>*  deletes all temporary files and directories created during this session.</haxe_doc>
		</deleteTempFiles>
		<exists public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>*  @return true if file exists.</haxe_doc>
		</exists>
		<isDirectory public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>*  @return true if it is a valid directory path. This is different from sys.FileSystem.isDirectory() that throws error if the path doesn't exist.</haxe_doc>
		</isDirectory>
		<isFile public="1" get="accessor" set="null"><x path="Bool"/></isFile>
		<isUnknown public="1" get="accessor" set="null"><x path="Bool"/></isUnknown>
		<isNativeDirectory public="1" get="accessor" set="null"><x path="Bool"/></isNativeDirectory>
		<nativePath public="1" get="accessor" set="null">
			<c path="String"/>
			<haxe_doc>*  @return full native os path</haxe_doc>
		</nativePath>
		<fileName public="1" get="accessor" set="null">
			<c path="String"/>
			<haxe_doc>*  @return filename.ext if a file, returns null if a directory</haxe_doc>
		</fileName>
		<name public="1" get="accessor" set="null">
			<c path="String"/>
			<haxe_doc>*  @return name of file without extension (if a file) and directory name if a directory</haxe_doc>
		</name>
		<extension public="1" get="accessor" set="null">
			<c path="String"/>
			<haxe_doc>*  @return the file extension or null if a directory</haxe_doc>
		</extension>
		<parent public="1" get="accessor" set="null">
			<c path="massive.sys.io.File"/>
			<haxe_doc>*  @return the directory of file, or the parent directory of a directory.</haxe_doc>
		</parent>
		<raw>
			<c path="String"/>
			<haxe_doc>*  @return the original string passed through in the constructor</haxe_doc>
		</raw>
		<path public="1" set="null">
			<c path="haxe.io.Path"/>
			<haxe_doc>*  @return a neko path instance for the file</haxe_doc>
		</path>
		<isEmpty public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>*  @return true if directory  is empty (or if it is a file);</haxe_doc>
		</isEmpty>
		<type><e path="massive.sys.io.FileType"/></type>
		<setInternalPath set="method" line="240">
			<f a="filePath:?fileType" v=":null">
				<c path="String"/>
				<e path="massive.sys.io.FileType"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ fileType : null }</e></m></meta>
		</setInternalPath>
		<toString public="1" set="method" line="300"><f a=""><c path="String"/></f></toString>
		<resolvePath public="1" set="method" line="310">
			<f a="value:?createImmediately:?fileType:?posInfos" v=":false:null:">
				<c path="String"/>
				<x path="Bool"/>
				<e path="massive.sys.io.FileType"/>
				<x path="Null"><t path="haxe.PosInfos"/></x>
				<c path="massive.sys.io.File"/>
			</f>
			<meta><m n=":value"><e>{ fileType : null, createImmediately : false }</e></m></meta>
			<haxe_doc>*  @param a relative path to resolve (e.g. "sub/example.txt")
	*  @return a new File instance</haxe_doc>
		</resolvePath>
		<resolveDirectory public="1" set="method" line="380">
			<f a="value:?createImmediately" v=":false">
				<c path="String"/>
				<x path="Bool"/>
				<c path="massive.sys.io.File"/>
			</f>
			<meta><m n=":value"><e>{ createImmediately : false }</e></m></meta>
		</resolveDirectory>
		<resolveFile public="1" set="method" line="399">
			<f a="value:?createImmediately" v=":false">
				<c path="String"/>
				<x path="Bool"/>
				<c path="massive.sys.io.File"/>
			</f>
			<meta><m n=":value"><e>{ createImmediately : false }</e></m></meta>
		</resolveFile>
		<getRelativePath public="1" set="method" line="412">
			<f a="ref:?useDotDot" v=":true">
				<c path="massive.sys.io.File"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ useDotDot : true }</e></m></meta>
			<haxe_doc>*  @param ref:File - a reference file to determine the path to
	*  @param useDotDot:Bool - uses ../../ syntax if true. Otherwise returns null if ref file path is not inside same directory as file
	*  @return a relative path string</haxe_doc>
		</getRelativePath>
		<clone public="1" set="method" line="510">
			<f a=""><c path="massive.sys.io.File"/></f>
			<haxe_doc>*  @returns a copy of the current file instance</haxe_doc>
		</clone>
		<createDirectory public="1" set="method" line="521">
			<f a="?force:?posInfos" v="false:">
				<x path="Bool"/>
				<x path="Null"><t path="haxe.PosInfos"/></x>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ force : false }</e></m></meta>
			<haxe_doc>* Creates the current directory in the filesystem
	*  
	*  @returns true if directory is created
	* @returns false if directory already exists or if file isn't a directory</haxe_doc>
		</createDirectory>
		<deleteDirectory public="1" set="method" line="564">
			<f a="?deleteContents:?posInfos" v="true:">
				<x path="Bool"/>
				<x path="Null"><t path="haxe.PosInfos"/></x>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ deleteContents : true }</e></m></meta>
			<haxe_doc>*  deletes the current directory 
	*  @param deleteContents: set to true to allow deleting of directory that contains files/directories
	*  @returns true if directory was removed
	*  @returns false if directory couldn't be removed because it contains files</haxe_doc>
		</deleteDirectory>
		<deleteDirectoryContents public="1" set="method" line="601">
			<f a="?filter:?exclude" v="null:false">
				<c path="EReg"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ exclude : false, filter : null }</e></m></meta>
			<haxe_doc>*  deletes the contents of the current directory</haxe_doc>
		</deleteDirectoryContents>
		<createFile public="1" set="method" line="624">
			<f a="?value" v="&quot;&quot;">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ value : "" }</e></m></meta>
		</createFile>
		<deleteFile public="1" set="method" line="648">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* deletes the current file</haxe_doc>
		</deleteFile>
		<copyTo public="1" set="method" line="672">
			<f a="dst:?overwrite:?filter:?exclude" v=":true:null:false">
				<c path="massive.sys.io.File"/>
				<x path="Bool"/>
				<c path="EReg"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ exclude : false, filter : null, overwrite : true }</e></m></meta>
			<haxe_doc>*  copies the current file to a destination
	*  @param dst:File - a destination directory (or file if copying a single file);
	*  @param overwrite:Bool - flag to decide whether or not to copy over existing files
	*  @param filter:EReg - optional filter for directory contents (if no filter is set it wil exclude .svn and .DS_STORE by default);
	*  @param exclude:Bool - falg whether or not filter is used to include or exclude files</haxe_doc>
		</copyTo>
		<copyInto public="1" set="method" line="747">
			<f a="dst:?overwrite:?filter:?exclude" v=":true:null:false">
				<c path="massive.sys.io.File"/>
				<x path="Bool"/>
				<c path="EReg"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ exclude : false, filter : null, overwrite : true }</e></m></meta>
			<haxe_doc>*  copies the current file/directory into another directory (using the same name as the current directory)
	*  @param dst:File - a destination parent directory
	*  @see File#copyTo</haxe_doc>
		</copyInto>
		<moveTo public="1" set="method" line="769">
			<f a="dst:?overwrite:?filter:?exclude" v=":true:null:false">
				<c path="massive.sys.io.File"/>
				<x path="Bool"/>
				<c path="EReg"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ exclude : false, filter : null, overwrite : true }</e></m></meta>
			<haxe_doc>*  copies the current file to a destination and then deletes the current version
	*  @see File#copyTo</haxe_doc>
		</moveTo>
		<moveInto public="1" set="method" line="789">
			<f a="dst:?overwrite:?filter:?exclude" v=":true:null:false">
				<c path="massive.sys.io.File"/>
				<x path="Bool"/>
				<c path="EReg"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ exclude : false, filter : null, overwrite : true }</e></m></meta>
			<haxe_doc>*  moves the current file/directory into another directory (using the same name as the current directory)
	*  @param dst:File - a destination parent directory
	*  @see File#moveTo</haxe_doc>
		</moveInto>
		<writeString public="1" set="method" line="812">
			<f a="value:?binary" v=":true">
				<d/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ binary : true }</e></m></meta>
			<haxe_doc>*  Writes a string to the current file. Creates the file if it doesn't exist yet.
	*  @param value:String - contents to write;
	*  @param binary:Bool - flag to decide whether to write as binary or not</haxe_doc>
		</writeString>
		<readString public="1" set="method" line="836">
			<f a=""><c path="String"/></f>
			<haxe_doc>*  Reads the contents of a file as a string</haxe_doc>
		</readString>
		<getDirectoryListing public="1" set="method" line="866">
			<f a="?filter:?exclude" v="null:false">
				<c path="EReg"/>
				<x path="Bool"/>
				<c path="Array"><c path="massive.sys.io.File"/></c>
			</f>
			<meta><m n=":value"><e>{ exclude : false, filter : null }</e></m></meta>
			<haxe_doc>*  returns an list of files and subdirectories in the current directory.</haxe_doc>
		</getDirectoryListing>
		<getRecursiveDirectoryListing public="1" set="method" line="905">
			<f a="?filter:?exclude:?orderDirectoriesBeforeFiles:?rootDir" v="null:false:false:null">
				<c path="EReg"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="massive.sys.io.File"/>
				<c path="Array"><c path="massive.sys.io.File"/></c>
			</f>
			<meta><m n=":value"><e>{ rootDir : null, orderDirectoriesBeforeFiles : false, exclude : false, filter : null }</e></m></meta>
			<haxe_doc>*  returns an list of files and subdirectories. This method is recursive.
	*  @param filter:EReg - optional filter for directory contents (if no filter is set it wil exclude .svn and .DS_STORE by default);
	*  @param exclude:Bool - flag whether or not filter is used to include or exclude files
	*  @param orderDirectoriesBeforeFiles:Bool - flag whether or not to list sub directories before or after their children.
	*         This is useful to get directories after when deleting and before when copying
	*  @param rootDir - used to run regex filter based on relative paths from a specified directory</haxe_doc>
		</getRecursiveDirectoryListing>
		<get_exists set="method" line="943"><f a=""><x path="Bool"/></f></get_exists>
		<get_isDirectory set="method" line="953"><f a=""><x path="Bool"/></f></get_isDirectory>
		<get_isNativeDirectory set="method" line="960"><f a=""><x path="Bool"/></f></get_isNativeDirectory>
		<get_isFile set="method" line="970"><f a=""><x path="Bool"/></f></get_isFile>
		<get_isUnknown set="method" line="975"><f a=""><x path="Bool"/></f></get_isUnknown>
		<get_name set="method" line="981"><f a=""><c path="String"/></f></get_name>
		<get_fileName set="method" line="994"><f a=""><c path="String"/></f></get_fileName>
		<get_extension set="method" line="1006"><f a=""><c path="String"/></f></get_extension>
		<get_nativePath set="method" line="1016"><f a=""><c path="String"/></f></get_nativePath>
		<get_parent set="method" line="1023"><f a=""><c path="massive.sys.io.File"/></f></get_parent>
		<get_isEmpty set="method" line="1046">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>*  returns an list of files and subdirectories in the current directory.</haxe_doc>
		</get_isEmpty>
		<toDebugString public="1" set="method" line="1061"><f a=""><c path="String"/></f></toDebugString>
		<new set="method" line="229">
			<f a="filePath:?fileType:?createImmediately" v=":null:false">
				<c path="String"/>
				<e path="massive.sys.io.FileType"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ createImmediately : false, fileType : null }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="massive.sys.io.FileType" params="" file="D:\Haxe\haxe\lib\mlib/2,0,3/massive/sys/io/File.hx" module="massive.sys.io.File">
		<DIRECTORY/>
		<FILE/>
		<UNKNOWN/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="massive.sys.io.FileException" params="" file="D:\Haxe\haxe\lib\mlib/2,0,3/massive/sys/io/FileException.hx">
		<extends path="massive.haxe.Exception"/>
		<file public="1"><c path="massive.sys.io.File"/></file>
		<toString public="1" set="method" line="44" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="38">
			<f a="message:?file:?posInfos" v=":null:">
				<c path="String"/>
				<c path="massive.sys.io.File"/>
				<t path="haxe.PosInfos"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ file : null }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="massive.sys.io.FileSys" params="" file="D:\Haxe\haxe\lib\mlib/2,0,3/massive/sys/io/FileSys.hx">
		<_isWindows static="1"><x path="Null"><x path="Bool"/></x></_isWindows>
		<isWindows public="1" get="accessor" set="null" static="1"><x path="Bool"/></isWindows>
		<_isMac static="1"><x path="Null"><x path="Bool"/></x></_isMac>
		<isMac public="1" get="accessor" set="null" static="1"><x path="Bool"/></isMac>
		<_isLinux static="1"><x path="Null"><x path="Bool"/></x></_isLinux>
		<isLinux public="1" get="accessor" set="null" static="1"><x path="Bool"/></isLinux>
		<get_isWindows set="method" line="51" static="1"><f a=""><x path="Bool"/></f></get_isWindows>
		<get_isMac set="method" line="60" static="1"><f a=""><x path="Bool"/></f></get_isMac>
		<get_isLinux set="method" line="69" static="1"><f a=""><x path="Bool"/></f></get_isLinux>
		<safePath set="method" line="81" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>*  Fix to remove trailing slash from directories in windows (throws errors on FileSystem methods)
	*</haxe_doc>
		</safePath>
		<getCwd public="1" set="method" line="99" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>*  fix for getCwd returning the wrong slash on a directory in windows</haxe_doc>
		</getCwd>
		<setCwd public="1" set="method" line="116" static="1"><f a="path">
	<c path="String"/>
	<x path="Void"/>
</f></setCwd>
		<exists public="1" set="method" line="129" static="1"><f a="path">
	<c path="String"/>
	<x path="Bool"/>
</f></exists>
		<isDirectory public="1" set="method" line="142" static="1"><f a="path">
	<c path="String"/>
	<x path="Bool"/>
</f></isDirectory>
		<readDirectory public="1" set="method" line="157" static="1"><f a="path">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</f></readDirectory>
		<createDirectory public="1" set="method" line="172" static="1"><f a="path">
	<c path="String"/>
	<x path="Void"/>
</f></createDirectory>
		<deleteDirectory public="1" set="method" line="187" static="1"><f a="path">
	<c path="String"/>
	<x path="Void"/>
</f></deleteDirectory>
		<deleteFile public="1" set="method" line="201" static="1"><f a="path">
	<c path="String"/>
	<x path="Void"/>
</f></deleteFile>
		<new public="1" set="method" line="230"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="massive.sys.util.PathUtil" params="" file="D:\Haxe\haxe\lib\mlib/2,0,3/massive/sys/util/PathUtil.hx">
		<DIRECTORY_NAME public="1" expr="~/\.?[a-zA-Z0-9\-_ ]*$/" line="34" static="1">
			<c path="EReg"/>
			<meta><m n=":value"><e>~/\.?[a-zA-Z0-9\-_ ]*$/</e></m></meta>
		</DIRECTORY_NAME>
		<HAXE_CLASS_NAME public="1" expr="~/[A-Z]([a-zA-Z0-9]+)\.hx/" line="35" static="1">
			<c path="EReg"/>
			<meta><m n=":value"><e>~/[A-Z]([a-zA-Z0-9]+)\.hx/</e></m></meta>
		</HAXE_CLASS_NAME>
		<isAbsolutePath public="1" set="method" line="43" static="1"><f a="path">
	<c path="String"/>
	<x path="Bool"/>
</f></isAbsolutePath>
		<cleanUpPath public="1" set="method" line="61" static="1"><f a="path">
	<c path="String"/>
	<c path="String"/>
</f></cleanUpPath>
		<lastCharIsSlash public="1" set="method" line="85" static="1"><f a="path">
	<c path="String"/>
	<x path="Bool"/>
</f></lastCharIsSlash>
		<isRelativePath public="1" set="method" line="92" static="1"><f a="path">
	<c path="String"/>
	<x path="Bool"/>
</f></isRelativePath>
		<isValidDirectoryName public="1" set="method" line="97" static="1"><f a="path">
	<c path="String"/>
	<x path="Bool"/>
</f></isValidDirectoryName>
		<isValidHaxeClassName public="1" set="method" line="102" static="1"><f a="path">
	<c path="String"/>
	<x path="Bool"/>
</f></isValidHaxeClassName>
		<new public="1" set="method" line="38"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="sys.FileStat" params="" file="D:\Haxe\haxe\std/sys/FileStat.hx">
		<a>
			<uid>
				<x path="Int"/>
				<haxe_doc>The user id for the file owner.</haxe_doc>
			</uid>
			<size>
				<x path="Int"/>
				<haxe_doc>The size of the file, in bytes.</haxe_doc>
			</size>
			<rdev>
				<x path="Int"/>
				<haxe_doc>The device type on which stat resides (special files only).</haxe_doc>
			</rdev>
			<nlink>
				<x path="Int"/>
				<haxe_doc>The number of hard links to stat.</haxe_doc>
			</nlink>
			<mtime>
				<c path="Date"/>
				<haxe_doc>The last modification time for the file.</haxe_doc>
			</mtime>
			<mode>
				<x path="Int"/>
				<haxe_doc>The permission bits of stat. The meaning of the bits is platform dependent.</haxe_doc>
			</mode>
			<ino>
				<x path="Int"/>
				<haxe_doc>The inode number for stat.</haxe_doc>
			</ino>
			<gid>
				<x path="Int"/>
				<haxe_doc>The user group id for the file owner.</haxe_doc>
			</gid>
			<dev>
				<x path="Int"/>
				<haxe_doc>The device on which stat resides.</haxe_doc>
			</dev>
			<ctime>
				<c path="Date"/>
				<haxe_doc>The creation time for the file (not all file systems support this).</haxe_doc>
			</ctime>
			<atime>
				<c path="Date"/>
				<haxe_doc>The last access time for the file (when enabled by the file system).</haxe_doc>
			</atime>
		</a>
		<haxe_doc>File information, as given by `sys.FileSystem.stat`.</haxe_doc>
	</typedef>
	<class path="sys.FileSystem" params="" file="D:\Haxe\haxe\std/cpp/_std/sys/FileSystem.hx">
		<exists public="1" set="method" line="30" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns `true` if the file or directory specified by `path` exists.</haxe_doc>
		</exists>
		<isDirectory public="1" set="method" line="74" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns `true` if the file or directory specified by `path` is a directory.

		If `path` is not a valid file system entry or if its destination is not
		accessible, an exception is thrown.</haxe_doc>
		</isDirectory>
		<createDirectory public="1" set="method" line="78" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a directory specified by `path`.

		This method is recursive: The parent directories don't have to exist.

		If the directory cannot be created, an exception is thrown.</haxe_doc>
		</createDirectory>
		<deleteFile public="1" set="method" line="92" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Deletes the file specified by `path`.

		If `path` does not denote a valid file, or if that file cannot be
		deleted, an exception is thrown.</haxe_doc>
		</deleteFile>
		<deleteDirectory public="1" set="method" line="96" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Deletes the directory specified by `path`. Only empty directories can
		be deleted.

		If `path` does not denote a valid directory, or if that directory cannot
		be deleted, an exception is thrown.</haxe_doc>
		</deleteDirectory>
		<readDirectory public="1" set="method" line="100" static="1">
			<f a="path">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns the names of all files and directories in the directory specified
		by `path`. `"."` and `".."` are not included in the output.

		If `path` does not denote a valid directory, an exception is thrown.</haxe_doc>
		</readDirectory>
		<haxe_doc>This class provides information about files and directories.

	If `null` is passed as a file path to any function in this class, the
	result is unspecified, and may differ from target to target.

	See `sys.io.File` for the complementary file API.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":buildXml"><e><![CDATA["<include name=\"${HXCPP}/src/hx/libs/std/Build.xml\"/>"]]></e></m>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="sys.io.File" params="" file="D:\Haxe\haxe\std/cpp/_std/sys/io/File.hx">
		<getContent public="1" set="method" line="29" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Retrieves the content of the file specified by `path` as a String.

		If the file does not exist or can not be read, an exception is thrown.

		`sys.FileSystem.exists` can be used to check for existence.

		If `path` is null, the result is unspecified.</haxe_doc>
		</getContent>
		<saveContent public="1" set="method" line="38" static="1">
			<f a="path:content">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Stores `content` in the file specified by `path`.

		If the file cannot be written to, an exception is thrown.

		If `path` or `content` are null, the result is unspecified.</haxe_doc>
		</saveContent>
		<read public="1" set="method" line="50" static="1">
			<f a="path:?binary" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="sys.io.FileInput"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":value"><e>{ binary : true }</e></m>
			</meta>
			<haxe_doc>Returns an `FileInput` handle to the file specified by `path`.

		If `binary` is true, the file is opened in binary mode. Otherwise it is
		opened in non-binary mode.

		If the file does not exist or can not be read, an exception is thrown.

		Operations on the returned `FileInput` handle read on the opened file.

		File handles should be closed via `FileInput.close` once the operation
		is complete.

		If `path` is null, the result is unspecified.</haxe_doc>
		</read>
		<write public="1" set="method" line="54" static="1">
			<f a="path:?binary" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="sys.io.FileOutput"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":value"><e>{ binary : true }</e></m>
			</meta>
			<haxe_doc>Returns an `FileOutput` handle to the file specified by `path`.

		If `binary` is true, the file is opened in binary mode. Otherwise it is
		opened in non-binary mode.

		If the file cannot be written to, an exception is thrown.

		Operations on the returned `FileOutput` handle write to the opened file.
		If the file existed, its previous content is overwritten.

		File handles should be closed via `FileOutput.close` once the operation
		is complete.

		If `path` is null, the result is unspecified.</haxe_doc>
		</write>
		<copy public="1" set="method" line="69" static="1">
			<f a="srcPath:dstPath">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Copies the contents of the file specified by `srcPath` to the file
		specified by `dstPath`.

		If the `srcPath` does not exist or cannot be read, or if the `dstPath`
		file cannot be written to, an exception is thrown.

		If the file at `dstPath` exists, its contents are overwritten.

		If `srcPath` or `dstPath` are null, the result is unspecified.</haxe_doc>
		</copy>
		<haxe_doc>API for reading and writing files.

	See `sys.FileSystem` for the complementary file system API.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="sys.io.FileInput" params="" file="D:\Haxe\haxe\std/cpp/_std/sys/io/FileInput.hx">
		<extends path="haxe.io.Input"/>
		<__f><d/></__f>
		<readByte public="1" set="method" line="36" override="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":has_untyped"/></meta>
		</readByte>
		<readBytes public="1" set="method" line="47" override="1">
			<f a="s:p:l">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</readBytes>
		<close public="1" set="method" line="58" override="1"><f a=""><x path="Void"/></f></close>
		<new set="method" line="32"><f a="f">
	<d/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Use `sys.io.File.read` to create a `FileInput`.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="sys.io.FileOutput" params="" file="D:\Haxe\haxe\std/cpp/_std/sys/io/FileOutput.hx">
		<extends path="haxe.io.Output"/>
		<__f><d/></__f>
		<writeByte public="1" set="method" line="36" override="1"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method" line="43" override="1"><f a="s:p:l">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></writeBytes>
		<flush public="1" set="method" line="47"><f a=""><x path="Void"/></f></flush>
		<close public="1" set="method" line="51" override="1"><f a=""><x path="Void"/></f></close>
		<new set="method" line="32"><f a="f">
	<d/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Use `sys.io.File.write` to create a `FileOutput`.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
</haxe>